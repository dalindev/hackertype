[
  [
    {
      "id": "1. Two Sum",
      "code": "class Solution {\n public:\n  vector<int> twoSum(vector<int>& nums, int target) {\n    unordered_map<int, int> numToIndex;\n\n    for (int i = 0; i < nums.size(); ++i) {\n      if (const auto it = numToIndex.find(target - nums[i]);\n          it != cend(numToIndex))\n        return {it->second, i};\n      numToIndex[nums[i]] = i;\n    }\n\n    throw;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "2. Add Two Numbers",
      "code": "class Solution {\n public:\n  ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n    ListNode dummy(0);\n    ListNode* curr = &dummy;\n    int carry = 0;\n\n    while (l1 || l2 || carry) {\n      if (l1 != nullptr) {\n        carry += l1->val;\n        l1 = l1->next;\n      }\n      if (l2 != nullptr) {\n        carry += l2->val;\n        l2 = l2->next;\n      }\n      curr->next = new ListNode(carry % 10);\n      carry /= 10;\n      curr = curr->next;\n    }\n\n    return dummy.next;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "3. Longest Substring Without Repeating Characters",
      "code": "class Solution {\n public:\n  int lengthOfLongestSubstring(string s) {\n    int ans = 0;\n    vector<int> count(128);\n\n    for (int l = 0, r = 0; r < s.length(); ++r) {\n      ++count[s[r]];\n      while (count[s[r]] > 1)\n        --count[s[l++]];\n      ans = max(ans, r - l + 1);\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "4. Median of Two Sorted Arrays",
      "code": "class Solution {\n public:\n  double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n    const int n1 = nums1.size();\n    const int n2 = nums2.size();\n    if (n1 > n2)\n      return findMedianSortedArrays(nums2, nums1);\n\n    int l = 0;\n    int r = n1;\n\n    while (l <= r) {\n      const int partition1 = (l + r) / 2;\n      const int partition2 = (n1 + n2 + 1) / 2 - partition1;\n      const int maxLeft1 = partition1 == 0 ? INT_MIN : nums1[partition1 - 1];\n      const int maxLeft2 = partition2 == 0 ? INT_MIN : nums2[partition2 - 1];\n      const int minRight1 = partition1 == n1 ? INT_MAX : nums1[partition1];\n      const int minRight2 = partition2 == n2 ? INT_MAX : nums2[partition2];\n      if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1)\n        return (n1 + n2) % 2 == 0\n                   ? (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) * 0.5\n                   : max(maxLeft1, maxLeft2);\n      else if (maxLeft1 > minRight2)\n        r = partition1 - 1;\n      else\n        l = partition1 + 1;\n    }\n\n    throw;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "5. Longest Palindromic Substring",
      "code": "class Solution {\n public:\n  string longestPalindrome(string s) {\n    if (s.empty())\n      return \"\";\n\n    // [start, end] indices of the longest palindrome in s\n    pair<int, int> indices{0, 0};\n\n    for (int i = 0; i < s.length(); ++i) {\n      const auto [l1, r1] = extend(s, i, i);\n      if (r1 - l1 > indices.second - indices.first)\n        indices = {l1, r1};\n      if (i + 1 < s.length() && s[i] == s[i + 1]) {\n        const auto [l2, r2] = extend(s, i, i + 1);\n        if (r2 - l2 > indices.second - indices.first)\n          indices = {l2, r2};\n      }\n    }\n\n    return s.substr(indices.first, indices.second - indices.first + 1);\n  }\n\n private:\n  // Returns [start, end] indices of the longest palindrome extended from\n  // s[i..j]\n  pair<int, int> extend(const string& s, int i, int j) {\n    for (; i >= 0 && j < s.length(); --i, ++j)\n      if (s[i] != s[j])\n        break;\n    return {i + 1, j - 1};\n  }\n };\n"
    }
  ],
  [
    {
      "id": "6. Zigzag Conversion",
      "code": "class Solution {\n public:\n  string convert(string s, int numRows) {\n    string ans;\n    vector<vector<char>> rows(numRows);\n    int k = 0;\n    int direction = (numRows == 1) - 1;\n\n    for (const char c : s) {\n      rows[k].push_back(c);\n      if (k == 0 || k == numRows - 1)\n        direction *= -1;\n      k += direction;\n    }\n\n    for (const vector<char>& row : rows)\n      for (const char c : row)\n        ans += c;\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "7. Reverse Integer",
      "code": "class Solution {\n public:\n  int reverse(int x) {\n    long ans = 0;\n\n    while (x) {\n      ans = ans * 10 + x % 10;\n      x /= 10;\n    }\n\n    return (ans < INT_MIN || ans > INT_MAX) ? 0 : ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "8. String to Integer (atoi)",
      "code": "class Solution {\n public:\n  int myAtoi(string s) {\n    trim(s);\n    if (s.empty())\n      return 0;\n\n    const int sign = s[0] == '-' ? -1 : 1;\n    if (s[0] == '+' || s[0] == '-')\n      s = s.substr(1);\n\n    long num = 0;\n\n    for (const char c : s) {\n      if (!isdigit(c))\n        break;\n      num = num * 10 + (c - '0');\n      if (sign * num < INT_MIN)\n        return INT_MIN;\n      if (sign * num > INT_MAX)\n        return INT_MAX;\n    }\n\n    return sign * num;\n  }\n\n private:\n  void trim(string& s) {\n    s.erase(0, s.find_first_not_of(' '));\n    s.erase(s.find_last_not_of(' ') + 1);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "9. Palindrome Number",
      "code": "class Solution {\n public:\n  bool isPalindrome(int x) {\n    if (x < 0)\n      return false;\n\n    long reversed = 0;\n    int y = x;\n\n    while (y) {\n      reversed = reversed * 10 + y % 10;\n      y /= 10;\n    }\n\n    return reversed == x;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "10. Regular Expression Matching",
      "code": "class Solution {\n public:\n  bool isMatch(string s, string p) {\n    const int m = s.length();\n    const int n = p.length();\n    // dp[i][j] := true if s[0..i) matches p[0..j)\n    vector<vector<bool>> dp(m + 1, vector<bool>(n + 1));\n    dp[0][0] = true;\n\n    auto isMatch = [&](int i, int j) -> bool {\n      return j >= 0 && p[j] == '.' || s[i] == p[j];\n    };\n\n    for (int j = 0; j < p.length(); ++j)\n      if (p[j] == '*' && dp[0][j - 1])\n        dp[0][j + 1] = true;\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (p[j] == '*') {\n          const bool noRepeat = dp[i + 1][j - 1];  // Min index of '*' is 1\n          const bool doRepeat = isMatch(i, j - 1) && dp[i][j + 1];\n          dp[i + 1][j + 1] = noRepeat || doRepeat;\n        } else if (isMatch(i, j)) {\n          dp[i + 1][j + 1] = dp[i][j];\n        }\n\n    return dp[m][n];\n  }\n };\n"
    }
  ],
  [
    {
      "id": "11. Container With Most Water",
      "code": "class Solution {\n public:\n  int maxArea(vector<int>& height) {\n    int ans = 0;\n    int l = 0;\n    int r = height.size() - 1;\n\n    while (l < r) {\n      const int minHeight = min(height[l], height[r]);\n      ans = max(ans, minHeight * (r - l));\n      if (height[l] < height[r])\n        ++l;\n      else\n        --r;\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "12. Integer to Roman",
      "code": "class Solution {\n public:\n  string intToRoman(int num) {\n    const vector<pair<int, string>> valueSymbols{\n        {1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"}, {100, \"C\"},\n        {90, \"XC\"},  {50, \"L\"},   {40, \"XL\"}, {10, \"X\"},   {9, \"IX\"},\n        {5, \"V\"},    {4, \"IV\"},   {1, \"I\"}};\n    string ans;\n\n    for (const auto& [value, symbol] : valueSymbols) {\n      if (num == 0)\n        break;\n      while (num >= value) {\n        num -= value;\n        ans += symbol;\n      }\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "13. Roman to Integer",
      "code": "class Solution {\n public:\n  int romanToInt(string s) {\n    int ans = 0;\n    vector<int> roman(128);\n\n    roman['I'] = 1;\n    roman['V'] = 5;\n    roman['X'] = 10;\n    roman['L'] = 50;\n    roman['C'] = 100;\n    roman['D'] = 500;\n    roman['M'] = 1000;\n\n    for (int i = 0; i + 1 < s.length(); ++i)\n      if (roman[s[i]] < roman[s[i + 1]])\n        ans -= roman[s[i]];\n      else\n        ans += roman[s[i]];\n\n    return ans + roman[s.back()];\n  }\n };\n"
    }
  ],
  [
    {
      "id": "14. Longest Common Prefix",
      "code": "class Solution {\n public:\n  string longestCommonPrefix(vector<string>& strs) {\n    if (strs.empty())\n      return \"\";\n\n    for (int i = 0; i < strs[0].length(); ++i)\n      for (int j = 1; j < strs.size(); ++j)\n        if (i == strs[j].length() || strs[j][i] != strs[0][i])\n          return strs[0].substr(0, i);\n\n    return strs[0];\n  }\n };\n"
    }
  ],
  [
    {
      "id": "15. 3Sum",
      "code": "class Solution {\n public:\n  vector<vector<int>> threeSum(vector<int>& nums) {\n    if (nums.size() < 3)\n      return {};\n\n    vector<vector<int>> ans;\n\n    sort(begin(nums), end(nums));\n\n    for (int i = 0; i + 2 < nums.size(); ++i) {\n      if (i > 0 && nums[i] == nums[i - 1])\n        continue;\n      // Choose nums[i] as the first num in the triplet,\n      // and search the remaining nums in [i + 1, n - 1]\n      int l = i + 1;\n      int r = nums.size() - 1;\n      while (l < r) {\n        const int sum = nums[i] + nums[l] + nums[r];\n        if (sum == 0) {\n          ans.push_back({nums[i], nums[l++], nums[r--]});\n          while (l < r && nums[l] == nums[l - 1])\n            ++l;\n          while (l < r && nums[r] == nums[r + 1])\n            --r;\n        } else if (sum < 0) {\n          ++l;\n        } else {\n          --r;\n        }\n      }\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "16. 3Sum Closest",
      "code": "class Solution {\n public:\n  int threeSumClosest(vector<int>& nums, int target) {\n    int ans = nums[0] + nums[1] + nums[2];\n\n    sort(begin(nums), end(nums));\n\n    for (int i = 0; i + 2 < nums.size(); ++i) {\n      if (i > 0 && nums[i] == nums[i - 1])\n        continue;\n      // Choose nums[i] as the first num in the triplet,\n      // and search the remaining nums in [i + 1, n - 1]\n      int l = i + 1;\n      int r = nums.size() - 1;\n      while (l < r) {\n        const int sum = nums[i] + nums[l] + nums[r];\n        if (sum == target)\n          return sum;\n        if (abs(sum - target) < abs(ans - target))\n          ans = sum;\n        if (sum < target)\n          ++l;\n        else\n          --r;\n      }\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "17. Letter Combinations of a Phone Number",
      "code": "class Solution {\n public:\n  vector<string> letterCombinations(string digits) {\n    if (digits.empty())\n      return {};\n\n    vector<string> ans;\n\n    dfs(digits, 0, \"\", ans);\n    return ans;\n  }\n\n private:\n  const vector<string> digitToLetters{\"\",    \"\",    \"abc\",  \"def\", \"ghi\",\n                                      \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n\n  void dfs(const string& digits, int i, string&& path, vector<string>& ans) {\n    if (i == digits.length()) {\n      ans.push_back(path);\n      return;\n    }\n\n    for (const char letter : digitToLetters[digits[i] - '0']) {\n      path.push_back(letter);\n      dfs(digits, i + 1, move(path), ans);\n      path.pop_back();\n    }\n  }\n };\n"
    }
  ],
  [
    {
      "id": "18. 4Sum",
      "code": "class Solution {\n public:\n  vector<vector<int>> fourSum(vector<int>& nums, int target) {\n    vector<vector<int>> ans;\n    vector<int> path;\n    sort(begin(nums), end(nums));\n    nSum(nums, 4, target, 0, nums.size() - 1, path, ans);\n    return ans;\n  }\n\n private:\n  // In [l, r], find n numbers add up to the target\n  void nSum(const vector<int>& nums, long n, long target, int l, int r,\n            vector<int>& path, vector<vector<int>>& ans) {\n    if (r - l + 1 < n || target < nums[l] * n || target > nums[r] * n)\n      return;\n    if (n == 2) {\n      // Very simliar to the sub procedure in 15. 3Sum\n      while (l < r) {\n        const int sum = nums[l] + nums[r];\n        if (sum == target) {\n          path.push_back(nums[l]);\n          path.push_back(nums[r]);\n          ans.push_back(path);\n          path.pop_back();\n          path.pop_back();\n          ++l;\n          --r;\n          while (l < r && nums[l] == nums[l - 1])\n            ++l;\n          while (l < r && nums[r] == nums[r + 1])\n            --r;\n        } else if (sum < target) {\n          ++l;\n        } else {\n          --r;\n        }\n      }\n      return;\n    }\n\n    for (int i = l; i <= r; ++i) {\n      if (i > l && nums[i] == nums[i - 1])\n        continue;\n      path.push_back(nums[i]);\n      nSum(nums, n - 1, target - nums[i], i + 1, r, path, ans);\n      path.pop_back();\n    }\n  }\n };\n"
    }
  ],
  [
    {
      "id": "19. Remove Nth Node From End of List",
      "code": "class Solution {\n public:\n  ListNode* removeNthFromEnd(ListNode* head, int n) {\n    ListNode* slow = head;\n    ListNode* fast = head;\n\n    while (n--)\n      fast = fast->next;\n    if (fast == nullptr)\n      return head->next;\n\n    while (fast->next) {\n      slow = slow->next;\n      fast = fast->next;\n    }\n    slow->next = slow->next->next;\n\n    return head;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "20. Valid Parentheses",
      "code": "class Solution {\n public:\n  bool isValid(string s) {\n    stack<char> stack;\n\n    for (const char c : s)\n      if (c == '(')\n        stack.push(')');\n      else if (c == '{')\n        stack.push('}');\n      else if (c == '[')\n        stack.push(']');\n      else if (stack.empty() || pop(stack) != c)\n        return false;\n\n    return stack.empty();\n  }\n\n private:\n  int pop(stack<char>& stack) {\n    const int c = stack.top();\n    stack.pop();\n    return c;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "21. Merge Two Sorted Lists",
      "code": "class Solution {\n public:\n  ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n    if (!list1 || !list2)\n      return list1 ? list1 : list2;\n    if (list1->val > list2->val)\n      swap(list1, list2);\n    list1->next = mergeTwoLists(list1->next, list2);\n    return list1;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "22. Generate Parentheses",
      "code": "class Solution {\n public:\n  vector<string> generateParenthesis(int n) {\n    vector<string> ans;\n    dfs(n, n, \"\", ans);\n    return ans;\n  }\n\n private:\n  void dfs(int l, int r, string&& path, vector<string>& ans) {\n    if (l == 0 && r == 0) {\n      ans.push_back(path);\n      return;\n    }\n\n    if (l > 0) {\n      path.push_back('(');\n      dfs(l - 1, r, move(path), ans);\n      path.pop_back();\n    }\n    if (l < r) {\n      path.push_back(')');\n      dfs(l, r - 1, move(path), ans);\n      path.pop_back();\n    }\n  }\n };\n"
    }
  ],
  [
    {
      "id": "23. Merge k Sorted Lists",
      "code": "class Solution {\n public:\n  ListNode* mergeKLists(vector<ListNode*>& lists) {\n    ListNode dummy(0);\n    ListNode* curr = &dummy;\n    auto compare = [](ListNode* a, ListNode* b) { return a->val > b->val; };\n    priority_queue<ListNode*, vector<ListNode*>, decltype(compare)> minHeap(\n        compare);\n\n    for (ListNode* list : lists)\n      if (list != nullptr)\n        minHeap.push(list);\n\n    while (!minHeap.empty()) {\n      ListNode* minNode = minHeap.top();\n      minHeap.pop();\n      if (minNode->next)\n        minHeap.push(minNode->next);\n      curr->next = minNode;\n      curr = curr->next;\n    }\n\n    return dummy.next;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "24. Swap Nodes in Pairs",
      "code": "class Solution {\n public:\n  ListNode* swapPairs(ListNode* head) {\n    const int length = getLength(head);\n    ListNode dummy(0, head);\n    ListNode* prev = &dummy;\n    ListNode* curr = head;\n\n    for (int i = 0; i < length / 2; ++i) {\n      ListNode* next = curr->next;\n      curr->next = next->next;\n      next->next = prev->next;\n      prev->next = next;\n      prev = curr;\n      curr = curr->next;\n    }\n\n    return dummy.next;\n  }\n\n private:\n  int getLength(ListNode* head) {\n    int length = 0;\n    for (ListNode* curr = head; curr; curr = curr->next)\n      ++length;\n    return length;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "25. Reverse Nodes in k-Group",
      "code": "class Solution {\n public:\n  ListNode* reverseKGroup(ListNode* head, int k) {\n    if (head == nullptr)\n      return nullptr;\n\n    ListNode* tail = head;\n\n    for (int i = 0; i < k; ++i) {\n      if (tail == nullptr)  // Less than k nodes, do nothing\n        return head;\n      tail = tail->next;\n    }\n\n    ListNode* newHead = reverse(head, tail);\n    head->next = reverseKGroup(tail, k);\n    return newHead;\n  }\n\n private:\n  // Reverses [head, tail)\n  ListNode* reverse(ListNode* head, ListNode* tail) {\n    ListNode* prev = nullptr;\n    ListNode* curr = head;\n\n    while (curr != tail) {\n      ListNode* next = curr->next;\n      curr->next = prev;\n      prev = curr;\n      curr = next;\n    }\n\n    return prev;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "26. Remove Duplicates from Sorted Array",
      "code": "class Solution {\n public:\n  int removeDuplicates(vector<int>& nums) {\n    int i = 0;\n\n    for (const int num : nums)\n      if (i < 1 || num > nums[i - 1])\n        nums[i++] = num;\n\n    return i;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "27. Remove Element",
      "code": "class Solution {\n public:\n  int removeElement(vector<int>& nums, int val) {\n    int i = 0;\n\n    for (const int num : nums)\n      if (num != val)\n        nums[i++] = num;\n\n    return i;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "28. Find the Index of the First Occurrence in a String",
      "code": "class Solution {\n public:\n  int strStr(string haystack, string needle) {\n    const int m = haystack.length();\n    const int n = needle.length();\n\n    for (int i = 0; i < m - n + 1; i++)\n      if (haystack.substr(i, n) == needle)\n        return i;\n\n    return -1;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "29. Divide Two Integers",
      "code": "class Solution {\n public:\n  int divide(int dividend, int divisor) {\n    // -2^{31} / -1 = 2^31 -> overflow so return 2^31 - 1\n    if (dividend == INT_MIN && divisor == -1)\n      return INT_MAX;\n\n    const int sign = dividend > 0 ^ divisor > 0 ? -1 : 1;\n    long ans = 0;\n    long dvd = labs(dividend);\n    long dvs = labs(divisor);\n\n    while (dvd >= dvs) {\n      long k = 1;\n      while (k * 2 * dvs <= dvd)\n        k *= 2;\n      dvd -= k * dvs;\n      ans += k;\n    }\n\n    return sign * ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "30. Substring with Concatenation of All Words",
      "code": "class Solution {\n public:\n  vector<int> findSubstring(string s, vector<string>& words) {\n    if (s.empty() || words.empty())\n      return {};\n\n    const int k = words.size();\n    const int n = words[0].length();\n    vector<int> ans;\n    unordered_map<string, int> count;\n\n    for (const string& word : words)\n      ++count[word];\n\n    for (int i = 0; i < s.length() - k * n + 1; ++i) {\n      unordered_map<string, int> seen;\n      int j;\n      for (j = 0; j < k; ++j) {\n        const string& word = s.substr(i + j * n, n);\n        if (++seen[word] > count[word])\n          break;\n      }\n      if (j == k)\n        ans.push_back(i);\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "31. Next Permutation",
      "code": "class Solution {\n public:\n  void nextPermutation(vector<int>& nums) {\n    const int n = nums.size();\n\n    // From back to front, find the first num < nums[i + 1]\n    int i;\n    for (i = n - 2; i >= 0; --i)\n      if (nums[i] < nums[i + 1])\n        break;\n\n    // From back to front, find the first num > nums[i], swap it with nums[i]\n    if (i >= 0)\n      for (int j = n - 1; j > i; --j)\n        if (nums[j] > nums[i]) {\n          swap(nums[i], nums[j]);\n          break;\n        }\n\n    // Reverse nums[i + 1..n - 1]\n    reverse(nums, i + 1, n - 1);\n  }\n\n private:\n  void reverse(vector<int>& nums, int l, int r) {\n    while (l < r)\n      swap(nums[l++], nums[r--]);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "32. Longest Valid Parentheses",
      "code": "class Solution {\n public:\n  int longestValidParentheses(string s) {\n    const string s2 = \")\" + s;\n    // dp[i] := Length of longest valid parentheses substring of s2[1..i]\n    vector<int> dp(s2.length());\n\n    for (int i = 1; i < s2.length(); ++i)\n      if (s2[i] == ')' && s2[i - dp[i - 1] - 1] == '(')\n        dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2;\n\n    return *max_element(begin(dp), end(dp));\n  }\n };\n"
    }
  ],
  [
    {
      "id": "33. Search in Rotated Sorted Array",
      "code": "class Solution {\n public:\n  int search(vector<int>& nums, int target) {\n    int l = 0;\n    int r = nums.size() - 1;\n\n    while (l <= r) {\n      const int m = (l + r) / 2;\n      if (nums[m] == target)\n        return m;\n      if (nums[l] <= nums[m]) {  // nums[l..m] are sorted\n        if (nums[l] <= target && target < nums[m])\n          r = m - 1;\n        else\n          l = m + 1;\n      } else {  // nums[m..n - 1] are sorted\n        if (nums[m] < target && target <= nums[r])\n          l = m + 1;\n        else\n          r = m - 1;\n      }\n    }\n\n    return -1;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "34. Find First and Last Position of Element in Sorted Array",
      "code": "class Solution {\n public:\n  vector<int> searchRange(vector<int>& nums, int target) {\n    const int l = lower_bound(begin(nums), end(nums), target) - begin(nums);\n    if (l == nums.size() || nums[l] != target)\n      return {-1, -1};\n    const int r = upper_bound(begin(nums), end(nums), target) - begin(nums) - 1;\n    return {l, r};\n  }\n };\n"
    }
  ],
  [
    {
      "id": "35. Search Insert Position",
      "code": "class Solution {\n public:\n  int searchInsert(vector<int>& nums, int target) {\n    int l = 0;\n    int r = nums.size();\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (nums[m] == target)\n        return m;\n      if (nums[m] < target)\n        l = m + 1;\n      else\n        r = m;\n    }\n\n    return l;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "36. Valid Sudoku",
      "code": "class Solution {\n public:\n  bool isValidSudoku(vector<vector<char>>& board) {\n    unordered_set<string> seen;\n\n    for (int i = 0; i < 9; ++i)\n      for (int j = 0; j < 9; ++j) {\n        if (board[i][j] == '.')\n          continue;\n        const string c(1, board[i][j]);\n        if (!seen.insert(c + \"@row\" + to_string(i)).second ||\n            !seen.insert(c + \"@col\" + to_string(j)).second ||\n            !seen.insert(c + \"@box\" + to_string(i / 3) + to_string(j / 3))\n                 .second)\n          return false;\n      }\n\n    return true;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "37. Sudoku Solver",
      "code": "class Solution {\n public:\n  void solveSudoku(vector<vector<char>>& board) {\n    solve(board, 0);\n  }\n\n private:\n  bool solve(vector<vector<char>>& board, int s) {\n    if (s == 81)\n      return true;\n\n    const int i = s / 9;\n    const int j = s % 9;\n\n    if (board[i][j] != '.')\n      return solve(board, s + 1);\n\n    for (char c = '1'; c <= '9'; ++c)\n      if (isValid(board, i, j, c)) {\n        board[i][j] = c;\n        if (solve(board, s + 1))\n          return true;\n        board[i][j] = '.';\n      }\n\n    return false;\n  }\n\n  bool isValid(vector<vector<char>>& board, int row, int col, char c) {\n    for (int i = 0; i < 9; ++i)\n      if (board[i][col] == c || board[row][i] == c ||\n          board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\n        return false;\n    return true;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "38. Count and Say",
      "code": "class Solution {\n public:\n  string countAndSay(int n) {\n    string ans = \"1\";\n\n    while (--n) {\n      string next;\n      for (int i = 0; i < ans.length(); ++i) {\n        int count = 1;\n        while (i + 1 < ans.length() && ans[i] == ans[i + 1]) {\n          ++count;\n          ++i;\n        }\n        next += to_string(count) + ans[i];\n      }\n      ans = move(next);\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "39. Combination Sum",
      "code": "class Solution {\n public:\n  vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n    vector<vector<int>> ans;\n    sort(begin(candidates), end(candidates));\n    dfs(candidates, 0, target, {}, ans);\n    return ans;\n  }\n\n private:\n  void dfs(const vector<int>& A, int s, int target, vector<int>&& path,\n           vector<vector<int>>& ans) {\n    if (target < 0)\n      return;\n    if (target == 0) {\n      ans.push_back(path);\n      return;\n    }\n\n    for (int i = s; i < A.size(); ++i) {\n      path.push_back(A[i]);\n      dfs(A, i, target - A[i], move(path), ans);\n      path.pop_back();\n    }\n  }\n };\n"
    }
  ],
  [
    {
      "id": "40. Combination Sum II",
      "code": "class Solution {\n public:\n  vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n    vector<vector<int>> ans;\n    sort(begin(candidates), end(candidates));\n    dfs(candidates, 0, target, {}, ans);\n    return ans;\n  }\n\n private:\n  void dfs(const vector<int>& A, int s, int target, vector<int>&& path,\n           vector<vector<int>>& ans) {\n    if (target < 0)\n      return;\n    if (target == 0) {\n      ans.push_back(path);\n      return;\n    }\n\n    for (int i = s; i < A.size(); ++i) {\n      if (i > s && A[i] == A[i - 1])\n        continue;\n      path.push_back(A[i]);\n      dfs(A, i + 1, target - A[i], move(path), ans);\n      path.pop_back();\n    }\n  }\n };\n"
    }
  ],
  [
    {
      "id": "41. First Missing Positive",
      "code": "class Solution {\n public:\n  int firstMissingPositive(vector<int>& nums) {\n    const int n = nums.size();\n\n    // Correct slot:\n    // nums[i] = i + 1\n    // nums[i] - 1 = i\n    // nums[nums[i] - 1] = nums[i]\n    for (int i = 0; i < n; ++i)\n      while (nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i] - 1])\n        swap(nums[i], nums[nums[i] - 1]);\n\n    for (int i = 0; i < n; ++i)\n      if (nums[i] != i + 1)\n        return i + 1;\n\n    return n + 1;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "42. Trapping Rain Water",
      "code": "class Solution {\n public:\n  int trap(vector<int>& height) {\n    const int n = height.size();\n    int ans = 0;\n    vector<int> l(n);  // l[i] := max(height[0..i])\n    vector<int> r(n);  // r[i] := max(height[i..n))\n\n    for (int i = 0; i < n; ++i)\n      l[i] = i == 0 ? height[i] : max(height[i], l[i - 1]);\n\n    for (int i = n - 1; i >= 0; --i)\n      r[i] = i == n - 1 ? height[i] : max(height[i], r[i + 1]);\n\n    for (int i = 0; i < n; ++i)\n      ans += min(l[i], r[i]) - height[i];\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "43. Multiply Strings",
      "code": "class Solution {\n public:\n  string multiply(string num1, string num2) {\n    string s(num1.length() + num2.length(), '0');\n\n    for (int i = num1.length() - 1; i >= 0; --i)\n      for (int j = num2.length() - 1; j >= 0; --j) {\n        const int mult = (num1[i] - '0') * (num2[j] - '0');\n        const int sum = mult + (s[i + j + 1] - '0');\n        s[i + j] += sum / 10;\n        s[i + j + 1] = '0' + sum % 10;\n      }\n\n    const int i = s.find_first_not_of('0');\n    return i == -1 ? \"0\" : s.substr(i);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "44. Wildcard Matching",
      "code": "class Solution {\n public:\n  bool isMatch(string s, string p) {\n    const int m = s.length();\n    const int n = p.length();\n    // dp[i][j] := true if s[0..i) matches p[0..j)\n    vector<vector<bool>> dp(m + 1, vector<bool>(n + 1));\n    dp[0][0] = true;\n\n    auto isMatch = [&](int i, int j) -> bool {\n      return j >= 0 && p[j] == '?' || s[i] == p[j];\n    };\n\n    for (int j = 0; j < p.length(); ++j)\n      if (p[j] == '*')\n        dp[0][j + 1] = dp[0][j];\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (p[j] == '*') {\n          const bool matchEmpty = dp[i + 1][j];\n          const bool matchSome = dp[i][j + 1];\n          dp[i + 1][j + 1] = matchEmpty || matchSome;\n        } else if (isMatch(i, j)) {\n          dp[i + 1][j + 1] = dp[i][j];\n        }\n\n    return dp[m][n];\n  }\n };\n"
    }
  ],
  [
    {
      "id": "45. Jump Game II",
      "code": "class Solution {\n public:\n  int jump(vector<int>& nums) {\n    int ans = 0;\n    int end = 0;\n    int farthest = 0;\n\n    // Implicit BFS\n    for (int i = 0; i < nums.size() - 1; ++i) {\n      farthest = max(farthest, i + nums[i]);\n      if (farthest >= nums.size() - 1) {\n        ++ans;\n        break;\n      }\n      if (i == end) {    // Visited all the items on the current level\n        ++ans;           // Increment the level\n        end = farthest;  // Make the queue size for the next level\n      }\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "46. Permutations",
      "code": "class Solution {\n public:\n  vector<vector<int>> permute(vector<int>& nums) {\n    vector<vector<int>> ans;\n\n    dfs(nums, vector<bool>(nums.size()), {}, ans);\n    return ans;\n  }\n\n private:\n  void dfs(const vector<int>& nums, vector<bool>&& used, vector<int>&& path,\n           vector<vector<int>>& ans) {\n    if (path.size() == nums.size()) {\n      ans.push_back(path);\n      return;\n    }\n\n    for (int i = 0; i < nums.size(); ++i) {\n      if (used[i])\n        continue;\n      used[i] = true;\n      path.push_back(nums[i]);\n      dfs(nums, move(used), move(path), ans);\n      path.pop_back();\n      used[i] = false;\n    }\n  }\n };\n"
    }
  ],
  [
    {
      "id": "47. Permutations II",
      "code": "class Solution {\n public:\n  vector<vector<int>> permuteUnique(vector<int>& nums) {\n    vector<vector<int>> ans;\n    sort(begin(nums), end(nums));\n    dfs(nums, vector<bool>(nums.size()), {}, ans);\n    return ans;\n  }\n\n private:\n  void dfs(const vector<int>& nums, vector<bool>&& used, vector<int>&& path,\n           vector<vector<int>>& ans) {\n    if (path.size() == nums.size()) {\n      ans.push_back(path);\n      return;\n    }\n\n    for (int i = 0; i < nums.size(); ++i) {\n      if (used[i])\n        continue;\n      if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1])\n        continue;\n      used[i] = true;\n      path.push_back(nums[i]);\n      dfs(nums, move(used), move(path), ans);\n      path.pop_back();\n      used[i] = false;\n    }\n  }\n };\n"
    }
  ],
  [
    {
      "id": "48. Rotate Image",
      "code": "class Solution {\n public:\n  void rotate(vector<vector<int>>& matrix) {\n    reverse(begin(matrix), end(matrix));\n    for (int i = 0; i < matrix.size(); ++i)\n      for (int j = i + 1; j < matrix.size(); ++j)\n        swap(matrix[i][j], matrix[j][i]);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "49. Group Anagrams",
      "code": "class Solution {\n public:\n  vector<vector<string>> groupAnagrams(vector<string>& strs) {\n    vector<vector<string>> ans;\n    unordered_map<string, vector<string>> keyToAnagrams;\n\n    for (const string& str : strs) {\n      string key = str;\n      sort(begin(key), end(key));\n      keyToAnagrams[key].push_back(str);\n    }\n\n    for (const auto& [_, anagrams] : keyToAnagrams)\n      ans.push_back(anagrams);\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "50. Pow(x, n)",
      "code": "class Solution {\n public:\n  double myPow(double x, long n) {\n    if (n == 0)\n      return 1;\n    if (n < 0)\n      return 1 / myPow(x, -n);\n    if (n & 1)\n      return x * myPow(x, n - 1);\n    return myPow(x * x, n / 2);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "51. N-Queens",
      "code": "class Solution {\n public:\n  vector<vector<string>> solveNQueens(int n) {\n    vector<vector<string>> ans;\n    dfs(n, 0, vector<bool>(n), vector<bool>(2 * n - 1), vector<bool>(2 * n - 1),\n        vector<string>(n, string(n, '.')), ans);\n    return ans;\n  }\n\n private:\n  void dfs(int n, int i, vector<bool>&& cols, vector<bool>&& diag1,\n           vector<bool>&& diag2, vector<string>&& board,\n           vector<vector<string>>& ans) {\n    if (i == n) {\n      ans.push_back(board);\n      return;\n    }\n\n    for (int j = 0; j < n; ++j) {\n      if (cols[j] || diag1[i + j] || diag2[j - i + n - 1])\n        continue;\n      board[i][j] = 'Q';\n      cols[j] = diag1[i + j] = diag2[j - i + n - 1] = true;\n      dfs(n, i + 1, move(cols), move(diag1), move(diag2), move(board), ans);\n      cols[j] = diag1[i + j] = diag2[j - i + n - 1] = false;\n      board[i][j] = '.';\n    }\n  }\n };\n"
    }
  ],
  [
    {
      "id": "52. N-Queens II",
      "code": "class Solution {\n public:\n  int totalNQueens(int n) {\n    int ans = 0;\n    dfs(n, 0, vector<bool>(n), vector<bool>(2 * n - 1), vector<bool>(2 * n - 1),\n        ans);\n    return ans;\n  }\n\n private:\n  void dfs(int n, int i, vector<bool>&& cols, vector<bool>&& diag1,\n           vector<bool>&& diag2, int& ans) {\n    if (i == n) {\n      ++ans;\n      return;\n    }\n\n    for (int j = 0; j < n; ++j) {\n      if (cols[j] || diag1[i + j] || diag2[j - i + n - 1])\n        continue;\n      cols[j] = diag1[i + j] = diag2[j - i + n - 1] = true;\n      dfs(n, i + 1, move(cols), move(diag1), move(diag2), ans);\n      cols[j] = diag1[i + j] = diag2[j - i + n - 1] = false;\n    }\n  }\n };\n"
    }
  ],
  [
    {
      "id": "53. Maximum Subarray",
      "code": "class Solution {\n public:\n  int maxSubArray(vector<int>& nums) {\n    // dp[i] := max sum subarray ending w/ i.\n    vector<int> dp(nums.size());\n\n    dp[0] = nums[0];\n    for (int i = 1; i < nums.size(); ++i)\n      dp[i] = max(nums[i], dp[i - 1] + nums[i]);\n\n    return *max_element(begin(dp), end(dp));\n  }\n };\n"
    }
  ],
  [
    {
      "id": "54. Spiral Matrix",
      "code": "class Solution {\n public:\n  vector<int> spiralOrder(vector<vector<int>>& matrix) {\n    if (matrix.empty())\n      return {};\n\n    const int m = matrix.size();\n    const int n = matrix[0].size();\n    vector<int> ans;\n    int r1 = 0;\n    int c1 = 0;\n    int r2 = m - 1;\n    int c2 = n - 1;\n\n    // Repeatedly add matrix[r1..r2][c1..c2] to ans\n    while (ans.size() < m * n) {\n      for (int j = c1; j <= c2 && ans.size() < m * n; ++j)\n        ans.push_back(matrix[r1][j]);\n      for (int i = r1 + 1; i <= r2 - 1 && ans.size() < m * n; ++i)\n        ans.push_back(matrix[i][c2]);\n      for (int j = c2; j >= c1 && ans.size() < m * n; --j)\n        ans.push_back(matrix[r2][j]);\n      for (int i = r2 - 1; i >= r1 + 1 && ans.size() < m * n; --i)\n        ans.push_back(matrix[i][c1]);\n      ++r1, ++c1, --r2, --c2;\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "55. Jump Game",
      "code": "class Solution {\n public:\n  bool canJump(vector<int>& nums) {\n    int i = 0;\n\n    for (int reach = 0; i < nums.size() && i <= reach; ++i)\n      reach = max(reach, i + nums[i]);\n\n    return i == nums.size();\n  }\n };\n"
    }
  ],
  [
    {
      "id": "56. Merge Intervals",
      "code": "class Solution {\n public:\n  vector<vector<int>> merge(vector<vector<int>>& intervals) {\n    vector<vector<int>> ans;\n\n    sort(begin(intervals), end(intervals));\n\n    for (const vector<int>& interval : intervals)\n      if (ans.empty() || ans.back()[1] < interval[0])\n        ans.push_back(interval);\n      else\n        ans.back()[1] = max(ans.back()[1], interval[1]);\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "57. Insert Interval",
      "code": "class Solution {\n public:\n  vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n    const int n = intervals.size();\n    vector<vector<int>> ans;\n    int i = 0;\n\n    while (i < n && intervals[i][1] < newInterval[0])\n      ans.push_back(intervals[i++]);\n\n    // Merge overlapping intervals\n    while (i < n && intervals[i][0] <= newInterval[1]) {\n      newInterval[0] = min(newInterval[0], intervals[i][0]);\n      newInterval[1] = max(newInterval[1], intervals[i][1]);\n      ++i;\n    }\n\n    ans.push_back(newInterval);\n\n    while (i < n)\n      ans.push_back(intervals[i++]);\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "58. Length of Last Word",
      "code": "class Solution {\n public:\n  int lengthOfLastWord(string s) {\n    int i = s.length() - 1;\n\n    while (i >= 0 && s[i] == ' ')\n      --i;\n    const int lastIndex = i;\n    while (i >= 0 && s[i] != ' ')\n      --i;\n\n    return lastIndex - i;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "59. Spiral Matrix II",
      "code": "class Solution {\n public:\n  vector<vector<int>> generateMatrix(int n) {\n    vector<vector<int>> ans(n, vector<int>(n));\n    int count = 1;\n\n    for (int min = 0; min < n / 2; ++min) {\n      const int max = n - min - 1;\n      for (int i = min; i < max; ++i)\n        ans[min][i] = count++;\n      for (int i = min; i < max; ++i)\n        ans[i][max] = count++;\n      for (int i = max; i > min; --i)\n        ans[max][i] = count++;\n      for (int i = max; i > min; --i)\n        ans[i][min] = count++;\n    }\n\n    if (n & 1)\n      ans[n / 2][n / 2] = count;\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "60. Permutation Sequence",
      "code": "class Solution {\n public:\n  string getPermutation(int n, int k) {\n    string ans;\n    vector<int> nums(n);\n    vector<int> fact(n + 1, 1);  // fact[i] := i!\n\n    iota(begin(nums), end(nums), 1);\n\n    for (int i = 2; i <= n; ++i)\n      fact[i] = fact[i - 1] * i;\n\n    --k;  // 0-indexed\n\n    for (int i = n - 1; i >= 0; --i) {\n      const int j = k / fact[i];\n      k %= fact[i];\n      ans += to_string(nums[j]);\n      nums.erase(begin(nums) + j);\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "61. Rotate List",
      "code": "class Solution {\n public:\n  ListNode* rotateRight(ListNode* head, int k) {\n    if (!head || !head->next || k == 0)\n      return head;\n\n    ListNode* tail;\n    int length = 1;\n    for (tail = head; tail->next; tail = tail->next)\n      ++length;\n    tail->next = head;  // Circle the list\n\n    const int t = length - k % length;\n    for (int i = 0; i < t; ++i)\n      tail = tail->next;\n    ListNode* newHead = tail->next;\n    tail->next = nullptr;\n\n    return newHead;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "62. Unique Paths",
      "code": "class Solution {\n public:\n  int uniquePaths(int m, int n) {\n    // dp[i][j] := unique paths from (0, 0) to (i, j)\n    vector<vector<int>> dp(m, vector<int>(n, 1));\n\n    for (int i = 1; i < m; ++i)\n      for (int j = 1; j < n; ++j)\n        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n\n    return dp[m - 1][n - 1];\n  }\n };\n"
    }
  ],
  [
    {
      "id": "63. Unique Paths II",
      "code": "class Solution {\n public:\n  int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\n    const int m = obstacleGrid.size();\n    const int n = obstacleGrid[0].size();\n    // dp[i][j] := unique paths from (0, 0) to (i - 1, j - 1)\n    vector<vector<long>> dp(m + 1, vector<long>(n + 1, 0));\n    dp[0][1] = 1;  // Can also set dp[1][0] = 1\n\n    for (int i = 1; i <= m; ++i)\n      for (int j = 1; j <= n; ++j)\n        if (!obstacleGrid[i - 1][j - 1])\n          dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n\n    return dp[m][n];\n  }\n };\n"
    }
  ],
  [
    {
      "id": "64. Minimum Path Sum",
      "code": "class Solution {\n public:\n  int minPathSum(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (i > 0 && j > 0)\n          grid[i][j] += min(grid[i - 1][j], grid[i][j - 1]);\n        else if (i > 0)\n          grid[i][0] += grid[i - 1][0];\n        else if (j > 0)\n          grid[0][j] += grid[0][j - 1];\n\n    return grid[m - 1][n - 1];\n  }\n };\n"
    }
  ],
  [
    {
      "id": "65. Valid Number",
      "code": "class Solution {\n public:\n  bool isNumber(string s) {\n    trim(s);\n    if (s.empty())\n      return false;\n\n    bool seenNum = false;\n    bool seenDot = false;\n    bool seenE = false;\n\n    for (int i = 0; i < s.length(); ++i) {\n      switch (s[i]) {\n        case '.':\n          if (seenDot || seenE)\n            return false;\n          seenDot = true;\n          break;\n        case 'e':\n        case 'E':\n          if (seenE || !seenNum)\n            return false;\n          seenE = true;\n          seenNum = false;\n          break;\n        case '+':\n        case '-':\n          if (i > 0 && s[i - 1] != 'e')\n            return false;\n          seenNum = false;\n          break;\n        default:\n          if (!isdigit(s[i]))\n            return false;\n          seenNum = true;\n      }\n    }\n\n    return seenNum;\n  }\n\n private:\n  void trim(string& s) {\n    s.erase(0, s.find_first_not_of(' '));\n    s.erase(s.find_last_not_of(' ') + 1);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "66. Plus One",
      "code": "class Solution {\n public:\n  vector<int> plusOne(vector<int>& digits) {\n    for (int i = digits.size() - 1; i >= 0; --i) {\n      if (digits[i] < 9) {\n        ++digits[i];\n        return digits;\n      }\n      digits[i] = 0;\n    }\n\n    digits.insert(begin(digits), 1);\n    return digits;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "67. Add Binary",
      "code": "class Solution {\n public:\n  string addBinary(string a, string b) {\n    string ans;\n    int carry = 0;\n    int i = a.length() - 1;\n    int j = b.length() - 1;\n\n    while (i >= 0 || j >= 0 || carry) {\n      if (i >= 0)\n        carry += a[i--] - '0';\n      if (j >= 0)\n        carry += b[j--] - '0';\n      ans += carry % 2 + '0';\n      carry /= 2;\n    }\n\n    reverse(begin(ans), end(ans));\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "68. Text Justification",
      "code": "class Solution {\n public:\n  vector<string> fullJustify(vector<string>& words, size_t maxWidth) {\n    vector<string> ans;\n    vector<string> row;\n    size_t rowLetters = 0;\n\n    for (const string& word : words) {\n      // If we put the word in this row, it'll exceed the maxWidth,\n      // So we cannot put the word to this row and have to pad spaces to\n      // Each word in this row\n      if (rowLetters + row.size() + word.length() > maxWidth) {\n        const int spaces = maxWidth - rowLetters;\n        if (row.size() == 1) {\n          // Pad all spaces after row[0]\n          for (int i = 0; i < spaces; ++i)\n            row[0] += \" \";\n        } else {\n          // Evenly pad spaces to each word (expect the last one) in this row\n          for (int i = 0; i < spaces; ++i)\n            row[i % (row.size() - 1)] += \" \";\n        }\n        ans.push_back(join(row, \"\"));\n        row.clear();\n        rowLetters = 0;\n      }\n      row.push_back(word);\n      rowLetters += word.length();\n    }\n    ans.push_back(ljust(join(row, \" \"), maxWidth));\n\n    return ans;\n  }\n\n private:\n  string join(const vector<string>& words, const string& s) {\n    string joined;\n    for (int i = 0; i < words.size(); ++i) {\n      joined += words[i];\n      if (i != words.size() - 1)\n        joined += s;\n    }\n    return joined;\n  }\n\n  string ljust(string s, int width) {\n    for (int i = 0; i < s.length() - width; ++i)\n      s += \" \";\n    return s;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "69. Sqrt(x)",
      "code": "class Solution {\n public:\n  int mySqrt(int x) {\n    unsigned l = 1;\n    unsigned r = x + 1u;\n\n    while (l < r) {\n      const unsigned m = (l + r) / 2;\n      if (m > x / m)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    // L: smallest number s.t. l * l > x\n    return l - 1;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "70. Climbing Stairs",
      "code": "class Solution {\n public:\n  int climbStairs(int n) {\n    // dp[i] := # of distinct ways to climb to i-th stair\n    vector<int> dp(n + 1);\n    dp[0] = 1;\n    dp[1] = 1;\n\n    for (int i = 2; i <= n; ++i)\n      dp[i] = dp[i - 1] + dp[i - 2];\n\n    return dp[n];\n  }\n };\n"
    }
  ],
  [
    {
      "id": "71. Simplify Path",
      "code": "class Solution {\n public:\n  string simplifyPath(string path) {\n    string ans;\n    istringstream iss(path);\n    vector<string> stack;\n\n    for (string dir; getline(iss, dir, '/');) {\n      if (dir.empty() || dir == \".\")\n        continue;\n      if (dir == \"..\") {\n        if (!stack.empty())\n          stack.pop_back();\n      } else {\n        stack.push_back(dir);\n      }\n    }\n\n    for (const string& s : stack)\n      ans += \"/\" + s;\n\n    return ans.empty() ? \"/\" : ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "72. Edit Distance",
      "code": "class Solution {\n public:\n  int minDistance(string word1, string word2) {\n    const int m = word1.length();\n    const int n = word2.length();\n    // dp[i][j] := min # of operations to convert word1[0..i) to word2[0..j)\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1));\n\n    for (int i = 1; i <= m; ++i)\n      dp[i][0] = i;\n\n    for (int j = 1; j <= n; ++j)\n      dp[0][j] = j;\n\n    for (int i = 1; i <= m; ++i)\n      for (int j = 1; j <= n; ++j)\n        if (word1[i - 1] == word2[j - 1])\n          dp[i][j] = dp[i - 1][j - 1];\n        else\n          dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;\n\n    return dp[m][n];\n  }\n };\n"
    }
  ],
  [
    {
      "id": "73. Set Matrix Zeroes",
      "code": "class Solution {\n public:\n  void setZeroes(vector<vector<int>>& matrix) {\n    const int m = matrix.size();\n    const int n = matrix[0].size();\n    bool shouldFillFirstRow = false;\n    bool shouldFillFirstCol = false;\n\n    for (int j = 0; j < n; ++j)\n      if (matrix[0][j] == 0) {\n        shouldFillFirstRow = true;\n        break;\n      }\n\n    for (int i = 0; i < m; ++i)\n      if (matrix[i][0] == 0) {\n        shouldFillFirstCol = true;\n        break;\n      }\n\n    // Store the information in the 1st row/col\n    for (int i = 1; i < m; ++i)\n      for (int j = 1; j < n; ++j)\n        if (matrix[i][j] == 0) {\n          matrix[i][0] = 0;\n          matrix[0][j] = 0;\n        }\n\n    // Fill 0s for the matrix except the 1st row/col\n    for (int i = 1; i < m; ++i)\n      for (int j = 1; j < n; ++j)\n        if (matrix[i][0] == 0 || matrix[0][j] == 0)\n          matrix[i][j] = 0;\n\n    // Fill 0s for the 1st row if needed\n    if (shouldFillFirstRow)\n      for (int j = 0; j < n; ++j)\n        matrix[0][j] = 0;\n\n    // Fill 0s for the 1st col if needed\n    if (shouldFillFirstCol)\n      for (int i = 0; i < m; ++i)\n        matrix[i][0] = 0;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "74. Search a 2D Matrix",
      "code": "class Solution {\n public:\n  bool searchMatrix(vector<vector<int>>& matrix, int target) {\n    if (matrix.empty())\n      return false;\n\n    const int m = matrix.size();\n    const int n = matrix[0].size();\n    int l = 0;\n    int r = m * n;\n\n    while (l < r) {\n      const int mid = (l + r) / 2;\n      const int i = mid / n;\n      const int j = mid % n;\n      if (matrix[i][j] == target)\n        return true;\n      if (matrix[i][j] < target)\n        l = mid + 1;\n      else\n        r = mid;\n    }\n\n    return false;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "75. Sort Colors",
      "code": "class Solution {\n public:\n  void sortColors(vector<int>& nums) {\n    int zero = -1;\n    int one = -1;\n    int two = -1;\n\n    for (const int num : nums)\n      if (num == 0) {\n        nums[++two] = 2;\n        nums[++one] = 1;\n        nums[++zero] = 0;\n      } else if (num == 1) {\n        nums[++two] = 2;\n        nums[++one] = 1;\n      } else {\n        nums[++two] = 2;\n      }\n  }\n };\n"
    }
  ],
  [
    {
      "id": "76. Minimum Window Substring",
      "code": "class Solution {\n public:\n  string minWindow(string s, string t) {\n    vector<int> count(128);\n    int required = t.length();\n    int bestLeft = -1;\n    int minLength = s.length() + 1;\n\n    for (const char c : t)\n      ++count[c];\n\n    for (int l = 0, r = 0; r < s.length(); ++r) {\n      if (--count[s[r]] >= 0)\n        --required;\n      while (required == 0) {\n        if (r - l + 1 < minLength) {\n          bestLeft = l;\n          minLength = r - l + 1;\n        }\n        if (++count[s[l++]] > 0)\n          ++required;\n      }\n    }\n\n    return bestLeft == -1 ? \"\" : s.substr(bestLeft, minLength);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "77. Combinations",
      "code": "class Solution {\n public:\n  vector<vector<int>> combine(int n, int k) {\n    vector<vector<int>> ans;\n    dfs(n, k, 1, {}, ans);\n    return ans;\n  }\n\n private:\n  void dfs(int n, int k, int s, vector<int>&& path, vector<vector<int>>& ans) {\n    if (path.size() == k) {\n      ans.push_back(path);\n      return;\n    }\n\n    for (int i = s; i <= n; ++i) {\n      path.push_back(i);\n      dfs(n, k, i + 1, move(path), ans);\n      path.pop_back();\n    }\n  }\n };\n"
    }
  ],
  [
    {
      "id": "78. Subsets",
      "code": "class Solution {\n public:\n  vector<vector<int>> subsets(vector<int>& nums) {\n    vector<vector<int>> ans;\n    dfs(nums, 0, {}, ans);\n    return ans;\n  }\n\n private:\n  void dfs(const vector<int>& nums, int s, vector<int>&& path,\n           vector<vector<int>>& ans) {\n    ans.push_back(path);\n\n    for (int i = s; i < nums.size(); ++i) {\n      path.push_back(nums[i]);\n      dfs(nums, i + 1, move(path), ans);\n      path.pop_back();\n    }\n  }\n };\n"
    }
  ],
  [
    {
      "id": "79. Word Search",
      "code": "class Solution {\n public:\n  bool exist(vector<vector<char>>& board, string word) {\n    for (int i = 0; i < board.size(); ++i)\n      for (int j = 0; j < board[0].size(); ++j)\n        if (dfs(board, word, i, j, 0))\n          return true;\n    return false;\n  }\n\n private:\n  bool dfs(vector<vector<char>>& board, const string& word, int i, int j,\n           int s) {\n    if (i < 0 || i == board.size() || j < 0 || j == board[0].size())\n      return false;\n    if (board[i][j] != word[s] || board[i][j] == '*')\n      return false;\n    if (s == word.length() - 1)\n      return true;\n\n    const char cache = board[i][j];\n    board[i][j] = '*';\n    const bool isExist = dfs(board, word, i + 1, j, s + 1) ||\n                         dfs(board, word, i - 1, j, s + 1) ||\n                         dfs(board, word, i, j + 1, s + 1) ||\n                         dfs(board, word, i, j - 1, s + 1);\n    board[i][j] = cache;\n\n    return isExist;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "80. Remove Duplicates from Sorted Array II",
      "code": "class Solution {\n public:\n  int removeDuplicates(vector<int>& nums) {\n    int i = 0;\n\n    for (const int num : nums)\n      if (i < 2 || num > nums[i - 2])\n        nums[i++] = num;\n\n    return i;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "81. Search in Rotated Sorted Array II",
      "code": "class Solution {\n public:\n  bool search(vector<int>& nums, int target) {\n    int l = 0;\n    int r = nums.size() - 1;\n\n    while (l <= r) {\n      const int m = (l + r) / 2;\n      if (nums[m] == target)\n        return true;\n      if (nums[l] == nums[m] && nums[m] == nums[r]) {\n        ++l;\n        --r;\n      } else if (nums[l] <= nums[m]) {  // nums[l..m] are sorted\n        if (nums[l] <= target && target < nums[m])\n          r = m - 1;\n        else\n          l = m + 1;\n      } else {  // nums[m..n - 1] are sorted\n        if (nums[m] < target && target <= nums[r])\n          l = m + 1;\n        else\n          r = m - 1;\n      }\n    }\n\n    return false;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "82. Remove Duplicates from Sorted List II",
      "code": "class Solution {\n public:\n  ListNode* deleteDuplicates(ListNode* head) {\n    ListNode dummy(0, head);\n    ListNode* prev = &dummy;\n\n    while (head) {\n      while (head->next && head->val == head->next->val)\n        head = head->next;\n      if (prev->next == head)\n        prev = prev->next;\n      else\n        prev->next = head->next;\n      head = head->next;\n    }\n\n    return dummy.next;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "83. Remove Duplicates from Sorted List",
      "code": "class Solution {\n public:\n  ListNode* deleteDuplicates(ListNode* head) {\n    ListNode* curr = head;\n\n    while (curr) {\n      while (curr->next && curr->val == curr->next->val)\n        curr->next = curr->next->next;\n      curr = curr->next;\n    }\n\n    return head;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "84. Largest Rectangle in Histogram",
      "code": "class Solution {\n public:\n  int largestRectangleArea(vector<int>& heights) {\n    int ans = 0;\n    stack<int> stack;\n\n    for (int i = 0; i <= heights.size(); ++i) {\n      while (!stack.empty() &&\n             (i == heights.size() || heights[stack.top()] > heights[i])) {\n        const int h = heights[stack.top()];\n        stack.pop();\n        const int w = stack.empty() ? i : i - stack.top() - 1;\n        ans = max(ans, h * w);\n      }\n      stack.push(i);\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "85. Maximal Rectangle",
      "code": "class Solution {\n public:\n  int maximalRectangle(vector<vector<char>>& matrix) {\n    if (matrix.empty())\n      return 0;\n\n    int ans = 0;\n    vector<int> hist(matrix[0].size());\n\n    for (const vector<char>& row : matrix) {\n      for (int i = 0; i < row.size(); ++i)\n        hist[i] = row[i] == '0' ? 0 : hist[i] + 1;\n      ans = max(ans, largestRectangleArea(hist));\n    }\n\n    return ans;\n  }\n\n private:\n  int largestRectangleArea(const vector<int>& heights) {\n    int ans = 0;\n    stack<int> stack;\n\n    for (int i = 0; i <= heights.size(); ++i) {\n      while (!stack.empty() &&\n             (i == heights.size() || heights[stack.top()] > heights[i])) {\n        const int h = heights[stack.top()];\n        stack.pop();\n        const int w = stack.empty() ? i : i - stack.top() - 1;\n        ans = max(ans, h * w);\n      }\n      stack.push(i);\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "86. Partition List",
      "code": "class Solution {\n public:\n  ListNode* partition(ListNode* head, int x) {\n    ListNode beforeHead(0);\n    ListNode afterHead(0);\n    ListNode* before = &beforeHead;\n    ListNode* after = &afterHead;\n\n    for (; head; head = head->next)\n      if (head->val < x) {\n        before->next = head;\n        before = head;\n      } else {\n        after->next = head;\n        after = head;\n      }\n\n    after->next = nullptr;\n    before->next = afterHead.next;\n\n    return beforeHead.next;\n  };\n};\n"
    }
  ],
  [
    {
      "id": "87. Scramble String",
      "code": "class Solution {\n public:\n  bool isScramble(string s1, string s2) {\n    if (s1 == s2)\n      return true;\n    if (s1.length() != s2.length())\n      return false;\n    const string hashedKey = s1 + '+' + s2;\n    if (const auto it = memo.find(hashedKey); it != cend(memo))\n      return it->second;\n\n    vector<int> count(128);\n\n    for (int i = 0; i < s1.length(); ++i) {\n      ++count[s1[i]];\n      --count[s2[i]];\n    }\n\n    if (any_of(begin(count), end(count), [](int c) { return c != 0; }))\n      return memo[hashedKey] = false;\n\n    for (int i = 1; i < s1.length(); ++i) {\n      if (isScramble(s1.substr(0, i), s2.substr(0, i)) &&\n          isScramble(s1.substr(i), s2.substr(i)))\n        return memo[hashedKey] = true;\n      if (isScramble(s1.substr(0, i), s2.substr(s2.length() - i)) &&\n          isScramble(s1.substr(i), s2.substr(0, s2.length() - i)))\n        return memo[hashedKey] = true;\n    }\n\n    return memo[hashedKey] = false;\n  }\n\n private:\n  unordered_map<string, bool> memo;\n};\n"
    }
  ],
  [
    {
      "id": "88. Merge Sorted Array",
      "code": "class Solution {\n public:\n  void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n    int i = m - 1;      // nums1's index (actual nums)\n    int j = n - 1;      // nums2's index\n    int k = m + n - 1;  // nums1's index (next filled position)\n\n    while (j >= 0)\n      if (i >= 0 && nums1[i] > nums2[j])\n        nums1[k--] = nums1[i--];\n      else\n        nums1[k--] = nums2[j--];\n  }\n };\n"
    }
  ],
  [
    {
      "id": "89. Gray Code",
      "code": "class Solution {\n public:\n  vector<int> grayCode(int n) {\n    vector<int> ans{0};\n\n    for (int i = 0; i < n; ++i)\n      for (int j = ans.size() - 1; j >= 0; --j)\n        ans.push_back(ans[j] | 1 << i);\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "90. Subsets II",
      "code": "class Solution {\n public:\n  vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n    vector<vector<int>> ans;\n    sort(begin(nums), end(nums));\n    dfs(nums, 0, {}, ans);\n    return ans;\n  }\n\n private:\n  void dfs(const vector<int>& nums, int s, vector<int>&& path,\n           vector<vector<int>>& ans) {\n    ans.push_back(path);\n\n    for (int i = s; i < nums.size(); ++i) {\n      if (i > s && nums[i] == nums[i - 1])\n        continue;\n      path.push_back(nums[i]);\n      dfs(nums, i + 1, move(path), ans);\n      path.pop_back();\n    }\n  }\n };\n"
    }
  ],
  [
    {
      "id": "91. Decode Ways",
      "code": "class Solution {\n public:\n  int numDecodings(string s) {\n    const int n = s.length();\n    // dp[i] := # of ways to decode s[i..n)\n    vector<int> dp(n + 1);\n    dp[n] = 1;  // \"\"\n    dp[n - 1] = isValid(s[n - 1]);\n\n    for (int i = n - 2; i >= 0; --i) {\n      if (isValid(s[i]))\n        dp[i] += dp[i + 1];\n      if (isValid(s[i], s[i + 1]))\n        dp[i] += dp[i + 2];\n    }\n\n    return dp[0];\n  }\n\n private:\n  bool isValid(char c) {\n    return c != '0';\n  }\n\n  bool isValid(char c1, char c2) {\n    return c1 == '1' || c1 == '2' && c2 < '7';\n  }\n };\n"
    }
  ],
  [
    {
      "id": "92. Reverse Linked List II",
      "code": "class Solution {\n public:\n  ListNode* reverseBetween(ListNode* head, int left, int right) {\n    if (left == 1)\n      return reverseN(head, right);\n\n    head->next = reverseBetween(head->next, left - 1, right - 1);\n\n    return head;\n  }\n\n private:\n  ListNode* reverseN(ListNode* head, int n) {\n    if (n == 1)\n      return head;\n\n    ListNode* newHead = reverseN(head->next, n - 1);\n    ListNode* headNext = head->next;\n    head->next = headNext->next;\n    headNext->next = head;\n\n    return newHead;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "93. Restore IP Addresses",
      "code": "class Solution {\n public:\n  vector<string> restoreIpAddresses(const string& s) {\n    vector<string> ans;\n    dfs(s, 0, {}, ans);\n    return ans;\n  }\n\n private:\n  void dfs(const string& s, int start, vector<string>&& path,\n           vector<string>& ans) {\n    if (path.size() == 4 && start == s.length()) {\n      ans.push_back(path[0] + \".\" + path[1] + \".\" + path[2] + \".\" + path[3]);\n      return;\n    }\n    if (path.size() == 4 || start == s.length())\n      return;\n\n    for (int length = 1; length <= 3; ++length) {\n      if (start + length > s.length())\n        return;  // Out of bound\n      if (length > 1 && s[start] == '0')\n        return;  // Leading '0'\n      const string& num = s.substr(start, length);\n      if (stoi(num) > 255)\n        return;\n      path.push_back(num);\n      dfs(s, start + length, move(path), ans);\n      path.pop_back();\n    }\n  }\n };\n"
    }
  ],
  [
    {
      "id": "94. Binary Tree Inorder Traversal",
      "code": "class Solution {\n public:\n  vector<int> inorderTraversal(TreeNode* root) {\n    vector<int> ans;\n    stack<TreeNode*> stack;\n\n    while (root || !stack.empty()) {\n      while (root) {\n        stack.push(root);\n        root = root->left;\n      }\n      root = stack.top(), stack.pop();\n      ans.push_back(root->val);\n      root = root->right;\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "95. Unique Binary Search Trees II",
      "code": "class Solution {\n public:\n  vector<TreeNode*> generateTrees(int n) {\n    if (n == 0)\n      return {};\n    return generateTrees(1, n);\n  }\n\n private:\n  vector<TreeNode*> generateTrees(int min, int max) {\n    if (min > max)\n      return {nullptr};\n\n    vector<TreeNode*> ans;\n\n    for (int i = min; i <= max; ++i)\n      for (TreeNode* left : generateTrees(min, i - 1))\n        for (TreeNode* right : generateTrees(i + 1, max)) {\n          ans.push_back(new TreeNode(i));\n          ans.back()->left = left;\n          ans.back()->right = right;\n        }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "96. Unique Binary Search Trees",
      "code": "class Solution {\n public:\n  int numTrees(int n) {\n    // G[i] := # of unique BST's that store values 1..i\n    vector<int> G(n + 1);\n    G[0] = 1;\n    G[1] = 1;\n\n    for (int i = 2; i <= n; ++i)\n      for (int j = 0; j < i; ++j)\n        G[i] += G[j] * G[i - j - 1];\n\n    return G[n];\n  }\n };\n"
    }
  ],
  [
    {
      "id": "97. Interleaving String",
      "code": "class Solution {\n public:\n  bool isInterleave(string s1, string s2, string s3) {\n    const int m = s1.length();\n    const int n = s2.length();\n    if (m + n != s3.length())\n      return false;\n\n    // dp[i][j] := true if s3[0..i + j) is formed by the interleaving of\n    //             s1[0..i) and s2[0..j)\n    vector<vector<bool>> dp(m + 1, vector<bool>(n + 1));\n    dp[0][0] = true;\n\n    for (int i = 1; i <= m; ++i)\n      dp[i][0] = dp[i - 1][0] && s1[i - 1] == s3[i - 1];\n\n    for (int j = 1; j <= n; ++j)\n      dp[0][j] = dp[0][j - 1] && s2[j - 1] == s3[j - 1];\n\n    for (int i = 1; i <= m; ++i)\n      for (int j = 1; j <= n; ++j)\n        dp[i][j] = dp[i - 1][j] && s1[i - 1] == s3[i + j - 1] ||\n                   dp[i][j - 1] && s2[j - 1] == s3[i + j - 1];\n\n    return dp[m][n];\n  }\n };\n"
    }
  ],
  [
    {
      "id": "98. Validate Binary Search Tree",
      "code": "class Solution {\n public:\n  bool isValidBST(TreeNode* root) {\n    return isValidBST(root, nullptr, nullptr);\n  }\n\n private:\n  bool isValidBST(TreeNode* root, TreeNode* minNode, TreeNode* maxNode) {\n    if (root == nullptr)\n      return true;\n    if (minNode && root->val <= minNode->val)\n      return false;\n    if (maxNode && root->val >= maxNode->val)\n      return false;\n\n    return isValidBST(root->left, minNode, root) &&\n           isValidBST(root->right, root, maxNode);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "99. Recover Binary Search Tree",
      "code": "class Solution {\n public:\n  void recoverTree(TreeNode* root) {\n    inorder(root);\n    swap(x, y);\n  }\n\n private:\n  TreeNode* pred = nullptr;\n  TreeNode* x = nullptr;  // 1st wrong node\n  TreeNode* y = nullptr;  // 2nd wrond node\n\n  void inorder(TreeNode* root) {\n    if (root == nullptr)\n      return;\n\n    inorder(root->left);\n\n    if (pred && root->val < pred->val) {\n      y = root;\n      if (x == nullptr)\n        x = pred;\n      else\n        return;\n    }\n    pred = root;\n\n    inorder(root->right);\n  }\n\n  void swap(TreeNode* x, TreeNode* y) {\n    const int temp = x->val;\n    x->val = y->val;\n    y->val = temp;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "100. Same Tree",
      "code": "class Solution {\n public:\n  bool isSameTree(TreeNode* p, TreeNode* q) {\n    if (!p || !q)\n      return p == q;\n    return p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "101. Symmetric Tree",
      "code": "class Solution {\n public:\n  bool isSymmetric(TreeNode* root) {\n    return isSymmetric(root, root);\n  }\n\n private:\n  bool isSymmetric(TreeNode* p, TreeNode* q) {\n    if (!p || !q)\n      return p == q;\n\n    return p->val == q->val &&\n           isSymmetric(p->left, q->right) &&\n           isSymmetric(p->right, q->left);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "102. Binary Tree Level Order Traversal",
      "code": "class Solution {\n public:\n  vector<vector<int>> levelOrder(TreeNode* root) {\n    if (root == nullptr)\n      return {};\n\n    vector<vector<int>> ans;\n    queue<TreeNode*> q{{root}};\n\n    while (!q.empty()) {\n      vector<int> currLevel;\n      for (int sz = q.size(); sz > 0; --sz) {\n        TreeNode* node = q.front();\n        q.pop();\n        currLevel.push_back(node->val);\n        if (node->left)\n          q.push(node->left);\n        if (node->right)\n          q.push(node->right);\n      }\n      ans.push_back(currLevel);\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "103. Binary Tree Zigzag Level Order Traversal",
      "code": "class Solution {\n public:\n  vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\n    if (root == nullptr)\n      return {};\n\n    vector<vector<int>> ans;\n    deque<TreeNode*> q{{root}};\n    bool isLeftToRight = true;\n\n    while (!q.empty()) {\n      vector<int> currLevel;\n      for (int sz = q.size(); sz > 0; --sz)\n        if (isLeftToRight) {\n          TreeNode* node = q.front();\n          q.pop_front();\n          currLevel.push_back(node->val);\n          if (node->left)\n            q.push_back(node->left);\n          if (node->right)\n            q.push_back(node->right);\n        } else {\n          TreeNode* node = q.back();\n          q.pop_back();\n          currLevel.push_back(node->val);\n          if (node->right)\n            q.push_front(node->right);\n          if (node->left)\n            q.push_front(node->left);\n        }\n      ans.push_back(currLevel);\n      isLeftToRight = !isLeftToRight;\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "104. Maximum Depth of Binary Tree",
      "code": "class Solution {\n public:\n  int maxDepth(TreeNode* root) {\n    if (root == nullptr)\n      return 0;\n    return 1 + max(maxDepth(root->left), maxDepth(root->right));\n  }\n };\n"
    }
  ],
  [
    {
      "id": "105. Construct Binary Tree from Preorder and Inorder Traversal",
      "code": "class Solution {\n public:\n  TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n    unordered_map<int, int> inToIndex;\n\n    for (int i = 0; i < inorder.size(); ++i)\n      inToIndex[inorder[i]] = i;\n\n    return build(preorder, 0, preorder.size() - 1, inorder, 0,\n                 inorder.size() - 1, inToIndex);\n  }\n\n private:\n  TreeNode* build(const vector<int>& preorder, int preStart, int preEnd,\n                  const vector<int>& inorder, int inStart, int inEnd,\n                  const unordered_map<int, int>& inToIndex) {\n    if (preStart > preEnd)\n      return nullptr;\n\n    const int rootVal = preorder[preStart];\n    const int rootInIndex = inToIndex.at(rootVal);\n    const int leftSize = rootInIndex - inStart;\n\n    TreeNode* root = new TreeNode(rootVal);\n    root->left = build(preorder, preStart + 1, preStart + leftSize, inorder,\n                       inStart, rootInIndex - 1, inToIndex);\n    root->right = build(preorder, preStart + leftSize + 1, preEnd, inorder,\n                        rootInIndex + 1, inEnd, inToIndex);\n    return root;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "106. Construct Binary Tree from Inorder and Postorder Traversal",
      "code": "class Solution {\n public:\n  TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n    unordered_map<int, int> inToIndex;\n\n    for (int i = 0; i < inorder.size(); ++i)\n      inToIndex[inorder[i]] = i;\n\n    return build(inorder, 0, inorder.size() - 1, postorder, 0,\n                 postorder.size() - 1, inToIndex);\n  }\n\n private:\n  TreeNode* build(const vector<int>& inorder, int inStart, int inEnd,\n                  const vector<int>& postorder, int postStart, int postEnd,\n                  const unordered_map<int, int>& inToIndex) {\n    if (inStart > inEnd)\n      return nullptr;\n\n    const int rootVal = postorder[postEnd];\n    const int rootInIndex = inToIndex.at(rootVal);\n    const int leftSize = rootInIndex - inStart;\n\n    TreeNode* root = new TreeNode(rootVal);\n    root->left = build(inorder, inStart, rootInIndex - 1, postorder, postStart,\n                       postStart + leftSize - 1, inToIndex);\n    root->right = build(inorder, rootInIndex + 1, inEnd, postorder,\n                        postStart + leftSize, postEnd - 1, inToIndex);\n    return root;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "107. Binary Tree Level Order Traversal II",
      "code": "class Solution {\n public:\n  vector<vector<int>> levelOrderBottom(TreeNode* root) {\n    if (root == nullptr)\n      return {};\n\n    vector<vector<int>> ans;\n    queue<TreeNode*> q{{root}};\n\n    while (!q.empty()) {\n      vector<int> currLevel;\n      for (int sz = q.size(); sz > 0; --sz) {\n        TreeNode* node = q.front();\n        q.pop();\n        currLevel.push_back(node->val);\n        if (node->left)\n          q.push(node->left);\n        if (node->right)\n          q.push(node->right);\n      }\n      ans.push_back(currLevel);\n    }\n\n    reverse(begin(ans), end(ans));\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "108. Convert Sorted Array to Binary Search Tree",
      "code": "class Solution {\n public:\n  TreeNode* sortedArrayToBST(vector<int>& nums) {\n    return build(nums, 0, nums.size() - 1);\n  }\n\n private:\n  TreeNode* build(const vector<int>& nums, int l, int r) {\n    if (l > r)\n      return nullptr;\n\n    const int m = (l + r) / 2;\n    return new TreeNode(nums[m],\n                        build(nums, l, m - 1),\n                        build(nums, m + 1, r));\n  }\n };\n"
    }
  ],
  [
    {
      "id": "109. Convert Sorted List to Binary Search Tree",
      "code": "class Solution {\n public:\n  TreeNode* sortedListToBST(ListNode* head) {\n    if (head == nullptr)\n      return nullptr;\n    if (!head->next)\n      return new TreeNode(head->val);\n\n    ListNode* mid = findMid(head);\n    TreeNode* root = new TreeNode(mid->val);\n    root->left = sortedListToBST(head);\n    root->right = sortedListToBST(mid->next);\n\n    return root;\n  }\n\n private:\n  ListNode* findMid(ListNode* head) {\n    ListNode* prev = nullptr;\n    ListNode* slow = head;\n    ListNode* fast = head;\n\n    while (fast && fast->next) {\n      prev = slow;\n      slow = slow->next;\n      fast = fast->next->next;\n    }\n    prev->next = nullptr;\n\n    return slow;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "110. Balanced Binary Tree",
      "code": "class Solution {\n public:\n  bool isBalanced(TreeNode* root) {\n    if (root == nullptr)\n      return true;\n    return abs(maxDepth(root->left) - maxDepth(root->right)) <= 1 &&\n           isBalanced(root->left) && isBalanced(root->right);\n  }\n\n private:\n  int maxDepth(TreeNode* root) {\n    if (root == nullptr)\n      return 0;\n    return 1 + max(maxDepth(root->left), maxDepth(root->right));\n  }\n };\n"
    }
  ],
  [
    {
      "id": "111. Minimum Depth of Binary Tree",
      "code": "class Solution {\n public:\n  int minDepth(TreeNode* root) {\n    if (root == nullptr)\n      return 0;\n    if (root->left == nullptr)\n      return minDepth(root->right) + 1;\n    if (root->right == nullptr)\n      return minDepth(root->left) + 1;\n    return min(minDepth(root->left), minDepth(root->right)) + 1;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "112. Path Sum",
      "code": "class Solution {\n public:\n  bool hasPathSum(TreeNode* root, int sum) {\n    if (root == nullptr)\n      return false;\n    if (root->val == sum && root->left == nullptr && root->right == nullptr)\n      return true;\n    return hasPathSum(root->left, sum - root->val) ||\n           hasPathSum(root->right, sum - root->val);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "113. Path Sum II",
      "code": "class Solution {\n public:\n  vector<vector<int>> pathSum(TreeNode* root, int sum) {\n    vector<vector<int>> ans;\n    dfs(root, sum, {}, ans);\n    return ans;\n  }\n\n private:\n  void dfs(TreeNode* root, int sum, vector<int>&& path,\n           vector<vector<int>>& ans) {\n    if (root == nullptr)\n      return;\n    if (root->val == sum && root->left == nullptr && root->right == nullptr) {\n      path.push_back(root->val);\n      ans.push_back(path);\n      path.pop_back();\n      return;\n    }\n\n    path.push_back(root->val);\n    dfs(root->left, sum - root->val, move(path), ans);\n    dfs(root->right, sum - root->val, move(path), ans);\n    path.pop_back();\n  }\n };\n"
    }
  ],
  [
    {
      "id": "114. Flatten Binary Tree to Linked List",
      "code": "class Solution {\n public:\n  void flatten(TreeNode* root) {\n    if (root == nullptr)\n      return;\n\n    flatten(root->left);\n    flatten(root->right);\n\n    TreeNode* const left = root->left;    // Flattened left\n    TreeNode* const right = root->right;  // Flattened right\n\n    root->left = nullptr;\n    root->right = left;\n\n    // Connect the original right subtree\n    // To the end of new right subtree\n    TreeNode* rightmost = root;\n    while (rightmost->right)\n      rightmost = rightmost->right;\n    rightmost->right = right;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "115. Distinct Subsequences",
      "code": "class Solution {\n public:\n  int numDistinct(string s, string t) {\n    const int m = s.length();\n    const int n = t.length();\n    vector<vector<unsigned long>> dp(m + 1, vector<unsigned long>(n + 1));\n\n    for (int i = 0; i <= m; ++i)\n      dp[i][0] = 1;\n\n    for (int i = 1; i <= m; ++i)\n      for (int j = 1; j <= n; ++j)\n        if (s[i - 1] == t[j - 1])\n          dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n        else\n          dp[i][j] = dp[i - 1][j];\n\n    return dp[m][n];\n  }\n };\n"
    }
  ],
  [
    {
      "id": "116. Populating Next Right Pointers in Each Node",
      "code": "class Solution {\n public:\n  Node* connect(Node* root) {\n    if (root == nullptr)\n      return nullptr;\n    connectTwoNodes(root->left, root->right);\n    return root;\n  }\n\n private:\n  void connectTwoNodes(Node* p, Node* q) {\n    if (p == nullptr)\n      return;\n    p->next = q;\n    connectTwoNodes(p->left, p->right);\n    connectTwoNodes(q->left, q->right);\n    connectTwoNodes(p->right, q->left);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "117. Populating Next Right Pointers in Each Node II",
      "code": "class Solution {\n public:\n  Node* connect(Node* root) {\n    Node* node = root;  // The node just above current needling\n\n    while (node) {\n      Node dummy(0);  // Dummy node before needling\n      // Needle children of node\n      for (Node* needle = &dummy; node; node = node->next) {\n        if (node->left) {  // Needle left child\n          needle->next = node->left;\n          needle = needle->next;\n        }\n        if (node->right) {  // Needle right child\n          needle->next = node->right;\n          needle = needle->next;\n        }\n      }\n      node = dummy.next;  // Move node to the next level\n    }\n\n    return root;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "118. Pascal's Triangle",
      "code": "class Solution {\n public:\n  vector<vector<int>> generate(int numRows) {\n    vector<vector<int>> ans;\n\n    for (int i = 0; i < numRows; ++i)\n      ans.push_back(vector<int>(i + 1, 1));\n\n    for (int i = 2; i < numRows; ++i)\n      for (int j = 1; j < ans[i].size() - 1; ++j)\n        ans[i][j] = ans[i - 1][j - 1] + ans[i - 1][j];\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "119. Pascal's Triangle II",
      "code": "class Solution {\n public:\n  vector<int> getRow(int rowIndex) {\n    vector<int> ans(rowIndex + 1, 1);\n\n    for (int i = 2; i < rowIndex + 1; ++i)\n      for (int j = 1; j < i; ++j)\n        ans[i - j] += ans[i - j - 1];\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "120. Triangle",
      "code": "class Solution {\n public:\n  int minimumTotal(vector<vector<int>>& triangle) {\n    for (int i = triangle.size() - 2; i >= 0; --i)\n      for (int j = 0; j <= i; ++j)\n        triangle[i][j] += min(triangle[i + 1][j], triangle[i + 1][j + 1]);\n    return triangle[0][0];\n  }\n };\n"
    }
  ],
  [
    {
      "id": "121. Best Time to Buy and Sell Stock",
      "code": "class Solution {\n public:\n  int maxProfit(vector<int>& prices) {\n    int sellOne = 0;\n    int holdOne = INT_MIN;\n\n    for (const int price : prices) {\n      sellOne = max(sellOne, holdOne + price);\n      holdOne = max(holdOne, -price);\n    }\n\n    return sellOne;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "122. Best Time to Buy and Sell Stock II",
      "code": "class Solution {\n public:\n  int maxProfit(vector<int>& prices) {\n    int sell = 0;\n    int hold = INT_MIN;\n\n    for (const int price : prices) {\n      sell = max(sell, hold + price);\n      hold = max(hold, sell - price);\n    }\n\n    return sell;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "123. Best Time to Buy and Sell Stock III",
      "code": "class Solution {\n public:\n  int maxProfit(vector<int>& prices) {\n    int sellTwo = 0;\n    int holdTwo = INT_MIN;\n    int sellOne = 0;\n    int holdOne = INT_MIN;\n\n    for (const int price : prices) {\n      sellTwo = max(sellTwo, holdTwo + price);\n      holdTwo = max(holdTwo, sellOne - price);\n      sellOne = max(sellOne, holdOne + price);\n      holdOne = max(holdOne, -price);\n    }\n\n    return sellTwo;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "124. Binary Tree Maximum Path Sum",
      "code": "class Solution {\n public:\n  int maxPathSum(TreeNode* root) {\n    int ans = INT_MIN;\n    maxPathSumDownFrom(root, ans);\n    return ans;\n  }\n\n private:\n  // root->val + 0/1 of its subtrees\n  int maxPathSumDownFrom(TreeNode* root, int& ans) {\n    if (root == nullptr)\n      return 0;\n\n    const int l = max(0, maxPathSumDownFrom(root->left, ans));\n    const int r = max(0, maxPathSumDownFrom(root->right, ans));\n    ans = max(ans, root->val + l + r);\n    return root->val + max(l, r);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "125. Valid Palindrome",
      "code": "class Solution {\n public:\n  bool isPalindrome(string s) {\n    int l = 0;\n    int r = s.length() - 1;\n\n    while (l < r) {\n      while (l < r && !isalnum(s[l]))\n        ++l;\n      while (l < r && !isalnum(s[r]))\n        --r;\n      if (tolower(s[l]) != tolower(s[r]))\n        return false;\n      ++l;\n      --r;\n    }\n\n    return true;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "126. Word Ladder II",
      "code": "class Solution {\n public:\n  vector<vector<string>> findLadders(string beginWord, string endWord,\n                                     vector<string>& wordList) {\n    unordered_set<string> wordSet{begin(wordList), end(wordList)};\n    if (!wordSet.count(endWord))\n      return {};\n\n    // {\"hit\": [\"hot\"], \"hot\": [\"dot\", \"lot\"], ...}\n    unordered_map<string, vector<string>> graph;\n\n    // Build graph from beginWord -> endWord\n    if (!bfs(beginWord, endWord, wordSet, graph))\n      return {};\n\n    vector<vector<string>> ans;\n\n    dfs(graph, beginWord, endWord, {beginWord}, ans);\n    return ans;\n  }\n\n private:\n  bool bfs(const string& beginWord, const string& endWord,\n           unordered_set<string>& wordSet,\n           unordered_map<string, vector<string>>& graph) {\n    unordered_set<string> currentLevelWords{beginWord};\n\n    while (!currentLevelWords.empty()) {\n      for (const string& word : currentLevelWords)\n        wordSet.erase(word);\n      unordered_set<string> nextLevelWords;\n      bool reachEndWord = false;\n      for (const string& parent : currentLevelWords) {\n        vector<string> children;\n        getChildren(parent, wordSet, children);\n        for (const string& child : children) {\n          if (wordSet.count(child)) {\n            nextLevelWords.insert(child);\n            graph[parent].push_back(child);\n          }\n          if (child == endWord)\n            reachEndWord = true;\n        }\n      }\n      if (reachEndWord)\n        return true;\n      currentLevelWords = move(nextLevelWords);\n    }\n\n    return true;\n  }\n\n  void getChildren(const string& parent, const unordered_set<string>& wordSet,\n                   vector<string>& children) {\n    string s(parent);\n\n    for (int i = 0; i < s.length(); ++i) {\n      const char cache = s[i];\n      for (char c = 'a'; c <= 'z'; ++c) {\n        if (c == cache)\n          continue;\n        s[i] = c;  // Now is `child`\n        if (wordSet.count(s))\n          children.push_back(s);\n      }\n      s[i] = cache;\n    }\n  }\n\n  void dfs(const unordered_map<string, vector<string>>& graph,\n           const string& word, const string& endWord, vector<string>&& path,\n           vector<vector<string>>& ans) {\n    if (word == endWord) {\n      ans.push_back(path);\n      return;\n    }\n    if (!graph.count(word))\n      return;\n\n    for (const string& child : graph.at(word)) {\n      path.push_back(child);\n      dfs(graph, child, endWord, move(path), ans);\n      path.pop_back();\n    }\n  }\n };\n"
    }
  ],
  [
    {
      "id": "127. Word Ladder",
      "code": "class Solution {\n public:\n  int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\n    unordered_set<string> wordSet(begin(wordList), end(wordList));\n    if (!wordSet.count(endWord))\n      return 0;\n\n    int ans = 0;\n    queue<string> q{{beginWord}};\n\n    while (!q.empty()) {\n      ++ans;\n      for (int sz = q.size(); sz > 0; --sz) {\n        string word = q.front();\n        q.pop();\n        for (int i = 0; i < word.length(); ++i) {\n          const char cache = word[i];\n          for (char c = 'a'; c <= 'z'; ++c) {\n            word[i] = c;\n            if (word == endWord)\n              return ans + 1;\n            if (wordSet.count(word)) {\n              q.push(word);\n              wordSet.erase(word);\n            }\n          }\n          word[i] = cache;\n        }\n      }\n    }\n\n    return 0;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "128. Longest Consecutive Sequence",
      "code": "class Solution {\n public:\n  int longestConsecutive(vector<int>& nums) {\n    int ans = 0;\n    unordered_set<int> seen{begin(nums), end(nums)};\n\n    for (int num : nums) {\n      // Num is the start of a sequence\n      if (seen.count(num - 1))\n        continue;\n      int length = 1;\n      while (seen.count(++num))\n        ++length;\n      ans = max(ans, length);\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "129. Sum Root to Leaf Numbers",
      "code": "class Solution {\n public:\n  int sumNumbers(TreeNode* root) {\n    int ans = 0;\n    dfs(root, 0, ans);\n    return ans;\n  }\n\n private:\n  void dfs(TreeNode* root, int path, int& ans) {\n    if (root == nullptr)\n      return;\n    if (root->left == nullptr && root->right == nullptr) {\n      ans += path * 10 + root->val;\n      return;\n    }\n\n    dfs(root->left, path * 10 + root->val, ans);\n    dfs(root->right, path * 10 + root->val, ans);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "130. Surrounded Regions",
      "code": "class Solution {\n public:\n  void solve(vector<vector<char>>& board) {\n    if (board.empty())\n      return;\n\n    const int m = board.size();\n    const int n = board[0].size();\n    const vector<int> dirs{0, 1, 0, -1, 0};\n    queue<pair<int, int>> q;\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (i * j == 0 || i == m - 1 || j == n - 1)\n          if (board[i][j] == 'O') {\n            q.emplace(i, j);\n            board[i][j] = '*';\n          }\n\n    // Mark grids that stretch from four sides with '*'\n    while (!q.empty()) {\n      const auto [i, j] = q.front();\n      q.pop();\n      for (int k = 0; k < 4; ++k) {\n        const int x = i + dirs[k];\n        const int y = j + dirs[k + 1];\n        if (x < 0 || x == m || y < 0 || y == n)\n          continue;\n        if (board[x][y] != 'O')\n          continue;\n        q.emplace(x, y);\n        board[x][y] = '*';\n      }\n    }\n\n    for (vector<char>& row : board)\n      for (char& c : row)\n        if (c == '*')\n          c = 'O';\n        else if (c == 'O')\n          c = 'X';\n  }\n };\n"
    }
  ],
  [
    {
      "id": "131. Palindrome Partitioning",
      "code": "class Solution {\n public:\n  vector<vector<string>> partition(string s) {\n    vector<vector<string>> ans;\n    dfs(s, 0, {}, ans);\n    return ans;\n  }\n\n private:\n  void dfs(const string& s, int start, vector<string>&& path,\n           vector<vector<string>>& ans) {\n    if (start == s.length()) {\n      ans.push_back(path);\n      return;\n    }\n\n    for (int i = start; i < s.length(); ++i)\n      if (isPalindrome(s, start, i)) {\n        path.push_back(s.substr(start, i - start + 1));\n        dfs(s, i + 1, move(path), ans);\n        path.pop_back();\n      }\n  }\n\n  bool isPalindrome(const string& s, int l, int r) {\n    while (l < r)\n      if (s[l++] != s[r--])\n        return false;\n    return true;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "132. Palindrome Partitioning II",
      "code": "class Solution {\n public:\n  int minCut(string s) {\n    const int n = s.length();\n    // isPalindrome[i][j] := true if s[i..j] is a palindrome\n    vector<vector<bool>> isPalindrome(n, vector<bool>(n, true));\n    // dp[i] := min cuts needed for a palindrome partitioning of s[0..i]\n    vector<int> dp(n, n);\n\n    for (int l = 2; l <= n; ++l)\n      for (int i = 0, j = l - 1; j < n; ++i, ++j)\n        isPalindrome[i][j] = s[i] == s[j] && isPalindrome[i + 1][j - 1];\n\n    for (int i = 0; i < n; ++i) {\n      if (isPalindrome[0][i]) {\n        dp[i] = 0;\n        continue;\n      }\n\n      // Try all possible partitions\n      for (int j = 0; j < i; ++j)\n        if (isPalindrome[j + 1][i])\n          dp[i] = min(dp[i], dp[j] + 1);\n    }\n\n    return dp.back();\n  }\n };\n"
    }
  ],
  [
    {
      "id": "133. Clone Graph",
      "code": "class Solution {\n public:\n  Node* cloneGraph(Node* node) {\n    if (node == nullptr)\n      return nullptr;\n\n    queue<Node*> q{{node}};\n    unordered_map<Node*, Node*> map{{node, new Node(node->val)}};\n\n    while (!q.empty()) {\n      Node* u = q.front();\n      q.pop();\n      for (Node* v : u->neighbors) {\n        if (!map.count(v)) {\n          map[v] = new Node(v->val);\n          q.push(v);\n        }\n        map[u]->neighbors.push_back(map[v]);\n      }\n    }\n\n    return map[node];\n  }\n };\n"
    }
  ],
  [
    {
      "id": "134. Gas Station",
      "code": "class Solution {\n public:\n  int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n    const int gasses = accumulate(begin(gas), end(gas), 0);\n    const int costs = accumulate(begin(cost), end(cost), 0);\n    if (gasses - costs < 0)\n      return -1;\n\n    int ans = 0;\n    int sum = 0;\n\n    // Try to start from each index\n    for (int i = 0; i < gas.size(); ++i) {\n      sum += gas[i] - cost[i];\n      if (sum < 0) {\n        sum = 0;\n        ans = i + 1;  // Start from next index\n      }\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "135. Candy",
      "code": "class Solution {\n public:\n  int candy(vector<int>& ratings) {\n    const int n = ratings.size();\n    int ans = 0;\n    vector<int> l(n, 1);\n    vector<int> r(n, 1);\n\n    for (int i = 1; i < n; ++i)\n      if (ratings[i] > ratings[i - 1])\n        l[i] = l[i - 1] + 1;\n\n    for (int i = n - 2; i >= 0; --i)\n      if (ratings[i] > ratings[i + 1])\n        r[i] = r[i + 1] + 1;\n\n    for (int i = 0; i < n; ++i)\n      ans += max(l[i], r[i]);\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "136. Single Number",
      "code": "class Solution {\n public:\n  int singleNumber(vector<int>& nums) {\n    int ans = 0;\n\n    for (const int num : nums)\n      ans ^= num;\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "137. Single Number II",
      "code": "class Solution {\n public:\n  int singleNumber(vector<int>& nums) {\n    int ans = 0;\n\n    for (int i = 0; i < 32; ++i) {\n      int sum = 0;\n      for (const int num : nums)\n        sum += num >> i & 1;\n      sum %= 3;\n      ans |= sum << i;\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "138. Copy List with Random Pointer",
      "code": "class Solution {\n public:\n  Node* copyRandomList(Node* head) {\n    if (head == nullptr)\n      return nullptr;\n    if (const auto it = map.find(head); it != cend(map))\n      return it->second;\n\n    Node* newNode = new Node(head->val);\n    map[head] = newNode;\n    newNode->next = copyRandomList(head->next);\n    newNode->random = copyRandomList(head->random);\n    return newNode;\n  }\n\n private:\n  unordered_map<Node*, Node*> map;\n};\n"
    }
  ],
  [
    {
      "id": "139. Word Break",
      "code": "class Solution {\n public:\n  bool wordBreak(string s, vector<string>& wordDict) {\n    return wordBreak(s, {begin(wordDict), end(wordDict)}, {});\n  }\n\n private:\n  bool wordBreak(const string& s, const unordered_set<string>&& wordSet,\n                 unordered_map<string, bool>&& memo) {\n    if (wordSet.count(s))\n      return true;\n    if (const auto it = memo.find(s); it != cend(memo))\n      return it->second;\n\n    // 1 <= prefix.length() < s.length()\n    for (int i = 1; i < s.length(); ++i) {\n      const string& prefix = s.substr(0, i);\n      const string& suffix = s.substr(i);\n      if (wordSet.count(prefix) && wordBreak(suffix, move(wordSet), move(memo)))\n        return memo[s] = true;\n    }\n\n    return memo[s] = false;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "140. Word Break II",
      "code": "class Solution {\n public:\n  vector<string> wordBreak(string s, vector<string>& wordDict) {\n    unordered_set<string> wordSet{begin(wordDict), end(wordDict)};\n    unordered_map<string, vector<string>> memo;\n    return wordBreak(s, wordSet, memo);\n  }\n\n private:\n  vector<string> wordBreak(const string& s,\n                           const unordered_set<string>& wordSet,\n                           unordered_map<string, vector<string>>& memo) {\n    if (const auto it = memo.find(s); it != cend(memo))\n      return it->second;\n\n    vector<string> ans;\n\n    // 1 <= prefix.length() < s.length()\n    for (int i = 1; i < s.length(); ++i) {\n      const string& prefix = s.substr(0, i);\n      const string& suffix = s.substr(i);\n      if (wordSet.count(prefix))\n        for (const string& word : wordBreak(suffix, wordSet, memo))\n          ans.push_back(prefix + \" \" + word);\n    }\n\n    // Contains whole string, so don't add any space\n    if (wordSet.count(s))\n      ans.push_back(s);\n\n    return memo[s] = ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "141. Linked List Cycle",
      "code": "class Solution {\n public:\n  bool hasCycle(ListNode* head) {\n    ListNode* slow = head;\n    ListNode* fast = head;\n\n    while (fast && fast->next) {\n      slow = slow->next;\n      fast = fast->next->next;\n      if (slow == fast)\n        return true;\n    }\n\n    return false;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "142. Linked List Cycle II",
      "code": "class Solution {\n public:\n  ListNode* detectCycle(ListNode* head) {\n    ListNode* slow = head;\n    ListNode* fast = head;\n\n    while (fast && fast->next) {\n      slow = slow->next;\n      fast = fast->next->next;\n      if (slow == fast) {\n        slow = head;\n        while (slow != fast) {\n          slow = slow->next;\n          fast = fast->next;\n        }\n        return slow;\n      }\n    }\n\n    return nullptr;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "143. Reorder List",
      "code": "class Solution {\n public:\n  void reorderList(ListNode* head) {\n    if (!head || !head->next)\n      return;\n\n    ListNode* mid = findMid(head);\n    ListNode* reversed = reverse(mid);\n    merge(head, reversed);\n  }\n\n private:\n  ListNode* findMid(ListNode* head) {\n    ListNode* prev = nullptr;\n    ListNode* slow = head;\n    ListNode* fast = head;\n\n    while (fast && fast->next) {\n      prev = slow;\n      slow = slow->next;\n      fast = fast->next->next;\n    }\n    prev->next = nullptr;\n\n    return slow;\n  }\n\n  ListNode* reverse(ListNode* head) {\n    ListNode* prev = nullptr;\n    ListNode* curr = head;\n\n    while (curr) {\n      ListNode* next = curr->next;\n      curr->next = prev;\n      prev = curr;\n      curr = next;\n    }\n\n    return prev;\n  }\n\n  void merge(ListNode* l1, ListNode* l2) {\n    while (l2) {\n      ListNode* next = l1->next;\n      l1->next = l2;\n      l1 = l2;\n      l2 = next;\n    }\n  }\n };\n"
    }
  ],
  [
    {
      "id": "144. Binary Tree Preorder Traversal",
      "code": "class Solution {\n public:\n  vector<int> preorderTraversal(TreeNode* root) {\n    vector<int> ans;\n    preorder(root, ans);\n    return ans;\n  }\n\n private:\n  void preorder(TreeNode* root, vector<int>& ans) {\n    if (root == nullptr)\n      return;\n\n    ans.push_back(root->val);\n    preorder(root->left, ans);\n    preorder(root->right, ans);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "145. Binary Tree Postorder Traversal",
      "code": "class Solution {\n public:\n  vector<int> postorderTraversal(TreeNode* root) {\n    vector<int> ans;\n    postorder(root, ans);\n    return ans;\n  }\n\n private:\n  void postorder(TreeNode* root, vector<int>& ans) {\n    if (root == nullptr)\n      return;\n\n    postorder(root->left, ans);\n    postorder(root->right, ans);\n    ans.push_back(root->val);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "146. LRU Cache",
      "code": "struct Node {\n  int key;\n  int value;\n  shared_ptr<Node> prev;\n  shared_ptr<Node> next;\n  Node(int key, int value) : key(key), value(value) {}\n };\n\n class LRUCache {\n public:\n  LRUCache(int capacity) : capacity(capacity) {\n    join(head, tail);\n  }\n\n  int get(int key) {\n    const auto it = keyToNode.find(key);\n    if (it == cend(keyToNode))\n      return -1;\n\n    shared_ptr<Node> node = it->second;\n    remove(node);\n    moveToHead(node);\n    return node->value;\n  }\n\n  void put(int key, int value) {\n    if (const auto it = keyToNode.find(key); it != cend(keyToNode)) {\n      shared_ptr<Node> node = it->second;\n      node->value = value;\n      remove(node);\n      moveToHead(node);\n      return;\n    }\n\n    if (keyToNode.size() == capacity) {\n      shared_ptr<Node> lastNode = tail->prev;\n      keyToNode.erase(lastNode->key);\n      remove(lastNode);\n    }\n\n    moveToHead(make_shared<Node>(key, value));\n    keyToNode[key] = head->next;\n  }\n\n private:\n  const int capacity;\n  unordered_map<int, shared_ptr<Node>> keyToNode;\n  shared_ptr<Node> head = make_shared<Node>(-1, -1);\n  shared_ptr<Node> tail = make_shared<Node>(-1, -1);\n\n  void join(shared_ptr<Node> node1, shared_ptr<Node> node2) {\n    node1->next = node2;\n    node2->prev = node1;\n  }\n\n  void moveToHead(shared_ptr<Node> node) {\n    join(node, head->next);\n    join(head, node);\n  }\n\n  void remove(shared_ptr<Node> node) {\n    join(node->prev, node->next);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "147. Insertion Sort List",
      "code": "class Solution {\n public:\n  ListNode* insertionSortList(ListNode* head) {\n    ListNode dummy(0);\n    ListNode* prev = &dummy;\n  // The last (largest) of the sorted list\n    while (head) {\n                  // Current inserting node\n      ListNode* next = head->next;\n  // Cache next inserting node\n      if (prev->val >= head->val)\n   // `prev` >= current inserting node\n        prev = &dummy;\n              // Move `prev` to the front\n      while (prev->next && prev->next->val < head->val)\n        prev = prev->next;\n      head->next = prev->next;\n      prev->next = head;\n      head = next;\n  // Update current inserting node\n    }\n\n    return dummy.next;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "148. Sort List",
      "code": "class Solution {\n public:\n  ListNode* sortList(ListNode* head) {\n    const int length = getLength(head);\n    ListNode dummy(0, head);\n\n    for (int k = 1; k < length; k *= 2) {\n      ListNode* curr = dummy.next;\n      ListNode* tail = &dummy;\n      while (curr) {\n        ListNode* l = curr;\n        ListNode* r = split(l, k);\n        curr = split(r, k);\n        auto [mergedHead, mergedTail] = merge(l, r);\n        tail->next = mergedHead;\n        tail = mergedTail;\n      }\n    }\n\n    return dummy.next;\n  }\n\n private:\n  int getLength(ListNode* head) {\n    int length = 0;\n    for (ListNode* curr = head; curr; curr = curr->next)\n      ++length;\n    return length;\n  }\n\n  ListNode* split(ListNode* head, int k) {\n    while (--k && head)\n      head = head->next;\n    ListNode* rest = head ? head->next : nullptr;\n    if (head != nullptr)\n      head->next = nullptr;\n    return rest;\n  }\n\n  pair<ListNode*, ListNode*> merge(ListNode* l1, ListNode* l2) {\n    ListNode dummy(0);\n    ListNode* tail = &dummy;\n\n    while (l1 && l2) {\n      if (l1->val > l2->val)\n        swap(l1, l2);\n      tail->next = l1;\n      l1 = l1->next;\n      tail = tail->next;\n    }\n    tail->next = l1 ? l1 : l2;\n    while (tail->next)\n      tail = tail->next;\n\n    return {dummy.next, tail};\n  }\n };\n"
    }
  ],
  [
    {
      "id": "149. Max Points on a Line",
      "code": "class Solution {\n public:\n  int maxPoints(vector<vector<int>>& points) {\n    int ans = 0;\n\n    for (int i = 0; i < points.size(); ++i) {\n      unordered_map<pair<int, int>, int, pairHash> slopeCount;\n      const vector<int> p1{points[i]};\n      int samePoints = 1;\n      int maxPoints = 0;  // Maximum number of points with the same slope\n      for (int j = i + 1; j < points.size(); ++j) {\n        const vector<int> p2{points[j]};\n        if (p1 == p2)\n          ++samePoints;\n        else\n          maxPoints = max(maxPoints, ++slopeCount[getSlope(p1, p2)]);\n      }\n      ans = max(ans, samePoints + maxPoints);\n    }\n\n    return ans;\n  }\n\n private:\n  pair<int, int> getSlope(const vector<int>& p, const vector<int>& q) {\n    const int dx = p[0] - q[0];\n    const int dy = p[1] - q[1];\n    if (dx == 0)\n      return {0, p[0]};\n    if (dy == 0)\n      return {p[1], 0};\n    const int d = __gcd(dx, dy);\n    return {dx / d, dy / d};\n  }\n\n  struct pairHash {\n    size_t operator()(const pair<int, int>& p) const {\n      return p.first ^ p.second;\n    }\n  };\n};\n"
    }
  ],
  [
    {
      "id": "150. Evaluate Reverse Polish Notation",
      "code": "class Solution {\n public:\n  int evalRPN(vector<string>& tokens) {\n    stack<long> stack;\n    const unordered_map<string, function<long(long, long)>> op{\n        {\"+\", plus<long>()},\n        {\"-\", minus<long>()},\n        {\"*\", multiplies<long>()},\n        {\"/\", divides<long>()}};\n\n    for (const string& token : tokens)\n      if (op.count(token)) {\n        const long b = stack.top();\n        stack.pop();\n        const long a = stack.top();\n        stack.pop();\n        stack.push(op.at(token)(a, b));\n      } else {\n        stack.push(stoi(token));\n      }\n\n    return stack.top();\n  }\n };\n"
    }
  ],
  [
    {
      "id": "151. Reverse Words in a String",
      "code": "class Solution {\n public:\n  string reverseWords(string s) {\n    reverse(begin(s), end(s));          // Reverse the whole string\n    reverseWords(s, s.length());        // Reverse each word\n    return cleanSpaces(s, s.length());  // Clean up spaces\n  }\n\n private:\n  void reverseWords(string& s, int n) {\n    int i = 0;\n    int j = 0;\n\n    while (i < n) {\n      while (i < j || i < n && s[i] == ' ')  // Skip spaces\n        ++i;\n      while (j < i || j < n && s[j] != ' ')  // Skip non spaces\n        ++j;\n      reverse(begin(s) + i, begin(s) + j);  // Reverse the word\n    }\n  }\n\n  // Trim leading, trailing, and middle spaces\n  string cleanSpaces(string& s, int n) {\n    int i = 0;\n    int j = 0;\n\n    while (j < n) {\n      while (j < n && s[j] == ' ')  // Skip spaces\n        ++j;\n      while (j < n && s[j] != ' ')  // Keep non spaces\n        s[i++] = s[j++];\n      while (j < n && s[j] == ' ')  // Skip spaces\n        ++j;\n      if (j < n)  // Keep only one space\n        s[i++] = ' ';\n    }\n\n    return s.substr(0, i);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "152. Maximum Product Subarray",
      "code": "class Solution {\n public:\n  int maxProduct(vector<int>& nums) {\n    int ans = nums[0];\n    int dpMin = nums[0];  // Min so far\n    int dpMax = nums[0];  // Max so far\n\n    for (int i = 1; i < nums.size(); ++i) {\n      const int num = nums[i];\n      const int prevMin = dpMin;  // dpMin[i - 1]\n      const int prevMax = dpMax;  // dpMax[i - 1]\n      if (num < 0) {\n        dpMin = min(prevMax * num, num);\n        dpMax = max(prevMin * num, num);\n      } else {\n        dpMin = min(prevMin * num, num);\n        dpMax = max(prevMax * num, num);\n      }\n      ans = max(ans, dpMax);\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "153. Find Minimum in Rotated Sorted Array",
      "code": "class Solution {\n public:\n  int findMin(vector<int>& nums) {\n    int l = 0;\n    int r = nums.size() - 1;\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (nums[m] < nums[r])\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return nums[l];\n  }\n };\n"
    }
  ],
  [
    {
      "id": "154. Find Minimum in Rotated Sorted Array II",
      "code": "class Solution {\n public:\n  int findMin(vector<int>& nums) {\n    int l = 0;\n    int r = nums.size() - 1;\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (nums[m] == nums[r])\n        --r;\n      else if (nums[m] < nums[r])\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return nums[l];\n  }\n };\n"
    }
  ],
  [
    {
      "id": "155. Min Stack",
      "code": "class MinStack {\n public:\n  void push(int x) {\n    if (stack.empty())\n      stack.emplace(x, x);\n    else\n      stack.emplace(x, min(x, stack.top().second));\n  }\n\n  void pop() {\n    stack.pop();\n  }\n\n  int top() {\n    return stack.top().first;\n  }\n\n  int getMin() {\n    return stack.top().second;\n  }\n\n private:\n  stack<pair<int, int>> stack;  // {x, min}\n };\n"
    }
  ],
  [
    {
      "id": "156. Binary Tree Upside Down",
      "code": "class Solution {\n public:\n  TreeNode* upsideDownBinaryTree(TreeNode* root) {\n    if (root == nullptr || root->left == nullptr)\n      return root;\n\n    TreeNode* newRoot = upsideDownBinaryTree(root->left);\n    root->left->left = root->right;  // 2's left = 3 (root's right)\n    root->left->right = root;        // 2's right = 1 (root)\n    root->left = nullptr;\n    root->right = nullptr;\n    return newRoot;\n  }\n };\n"
    }
  ],
  null,
  null,
  [
    {
      "id": "159. Longest Substring with At Most Two Distinct Characters",
      "code": "class Solution {\n public:\n  int lengthOfLongestSubstringTwoDistinct(string s) {\n    int ans = 0;\n    int distinct = 0;\n    vector<int> count(128);\n\n    for (int l = 0, r = 0; r < s.length(); ++r) {\n      if (++count[s[r]] == 1)\n        ++distinct;\n      while (distinct == 3)\n        if (--count[s[l++]] == 0)\n          --distinct;\n      ans = max(ans, r - l + 1);\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "160. Intersection of Two Linked Lists",
      "code": "class Solution {\n public:\n  ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {\n    ListNode* a = headA;\n    ListNode* b = headB;\n\n    while (a != b) {\n      a = a ? a->next : headB;\n      b = b ? b->next : headA;\n    }\n\n    return a;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "161. One Edit Distance",
      "code": "class Solution {\n public:\n  bool isOneEditDistance(string s, string t) {\n    const int m = s.length();\n    const int n = t.length();\n    if (m > n)  // Make sure len(s) <= len(t)\n      return isOneEditDistance(t, s);\n\n    for (int i = 0; i < m; ++i)\n      if (s[i] != t[i]) {\n        if (m == n)\n          return s.substr(i + 1) == t.substr(i + 1);  // Replace s[i] with t[i]\n        return s.substr(i) == t.substr(i + 1);        // Delete t[i]\n      }\n\n    return m + 1 == n;  // Delete t[-1]\n  }\n };\n"
    }
  ],
  [
    {
      "id": "162. Find Peak Element",
      "code": "class Solution {\n public:\n  int findPeakElement(vector<int>& nums) {\n    int l = 0;\n    int r = nums.size() - 1;\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (nums[m] >= nums[m + 1])\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return l;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "163. Missing Ranges",
      "code": "class Solution {\n public:\n  vector<string> findMissingRanges(vector<int>& nums, int lower, int upper) {\n    if (nums.empty())\n      return {getRange(lower, upper)};\n\n    vector<string> ans;\n\n    if (nums.front() > lower)\n      ans.push_back(getRange(lower, nums.front() - 1));\n\n    for (int i = 1; i < nums.size(); ++i)\n      if (nums[i] > nums[i - 1] + 1)\n        ans.push_back(getRange(nums[i - 1] + 1, nums[i] - 1));\n\n    if (nums.back() < upper)\n      ans.push_back(getRange(nums.back() + 1, upper));\n\n    return ans;\n  }\n\n private:\n  string getRange(int lo, int hi) {\n    if (lo == hi)\n      return to_string(lo);\n    return to_string(lo) + \"->\" + to_string(hi);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "164. Maximum Gap",
      "code": "struct Bucket {\n  int min;\n  int max;\n};\n\n class Solution {\n public:\n  int maximumGap(vector<int>& nums) {\n    if (nums.size() < 2)\n      return 0;\n\n    const int mini = *min_element(begin(nums), end(nums));\n    const int maxi = *max_element(begin(nums), end(nums));\n    if (mini == maxi)\n      return 0;\n\n    const int gap = ceil((maxi - mini) / (double)(nums.size() - 1));\n    const int bucketSize = (maxi - mini) / gap + 1;\n    vector<Bucket> buckets(bucketSize, {INT_MAX, INT_MIN});\n\n    for (const int num : nums) {\n      const int i = (num - mini) / gap;\n      buckets[i].min = min(buckets[i].min, num);\n      buckets[i].max = max(buckets[i].max, num);\n    }\n\n    int ans = 0;\n    int prevMax = mini;\n\n    for (const Bucket& bucket : buckets) {\n      if (bucket.min == INT_MAX)\n        continue;  // Empty bucket\n      ans = max(ans, bucket.min - prevMax);\n      prevMax = bucket.max;\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "165. Compare Version Numbers",
      "code": "class Solution {\n public:\n  int compareVersion(string version1, string version2) {\n    istringstream iss1(version1);\n    istringstream iss2(version2);\n    int v1;\n    int v2;\n    char dotChar;\n\n    while (bool(iss1 >> v1) + bool(iss2 >> v2)) {\n      if (v1 < v2)\n        return -1;\n      if (v1 > v2)\n        return 1;\n      iss1 >> dotChar;\n      iss2 >> dotChar;\n      v1 = 0;\n      v2 = 0;\n    }\n\n    return 0;\n  };\n};\n"
    }
  ],
  [
    {
      "id": "166. Fraction to Recurring Decimal",
      "code": "class Solution {\n public:\n  string fractionToDecimal(int numerator, int denominator) {\n    if (numerator == 0)\n      return \"0\";\n\n    string ans;\n\n    if (numerator < 0 ^ denominator < 0)\n      ans += \"-\";\n\n    long n = labs(numerator);\n    long d = labs(denominator);\n    ans += to_string(n / d);\n\n    if (n % d == 0)\n      return ans;\n\n    ans += '.';\n    unordered_map<int, int> seen;\n\n    for (long r = n % d; r; r %= d) {\n      if (const auto it = seen.find(r); it != cend(seen)) {\n        ans.insert(it->second, 1, '(');\n        ans += ')';\n        break;\n      }\n      seen[r] = ans.size();\n      r *= 10;\n      ans += to_string(r / d);\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "167. Two Sum II - Input Array Is Sorted",
      "code": "class Solution {\n public:\n  vector<int> twoSum(vector<int>& numbers, int target) {\n    int l = 0;\n    int r = numbers.size() - 1;\n\n    while (numbers[l] + numbers[r] != target)\n      if (numbers[l] + numbers[r] < target)\n        ++l;\n      else\n        --r;\n\n    return {l + 1, r + 1};\n  }\n };\n"
    }
  ],
  [
    {
      "id": "168. Excel Sheet Column Title",
      "code": "class Solution {\n public:\n  string convertToTitle(int n) {\n    return n == 0 ? : convertToTitle((n - 1) / 26) + (char)('A' + ((n - 1) % 26));\n  }\n };\n"
    }
  ],
  [
    {
      "id": "169. Majority Element",
      "code": "class Solution {\n public:\n  int majorityElement(vector<int>& nums) {\n    int ans;\n    int count = 0;\n\n    for (const int num : nums) {\n      if (count == 0)\n        ans = num;\n      count += num == ans ? 1 : -1;\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "170. Two Sum III - Data structure design",
      "code": "class TwoSum {\n public:\n  void add(int number) {\n    ++count[number];\n  }\n\n  bool find(int value) {\n    for (const auto& [key, freq] : count) {\n      const int remain = value - key;\n      if (key == remain && freq > 1)\n        return true;\n      if (key != remain && count.count(remain))\n        return true;\n    }\n\n    return false;\n  }\n\n private:\n  unordered_map<int, int> count;\n};\n"
    }
  ],
  [
    {
      "id": "171. Excel Sheet Column Number",
      "code": "class Solution {\n public:\n  int titleToNumber(string s) {\n    return accumulate(begin(s), end(s), 0, [](int a, int b) { return a * 26 + (b - 'A' + 1); });\n  }\n };\n"
    }
  ],
  [
    {
      "id": "172. Factorial Trailing Zeroes",
      "code": "class Solution {\n public:\n  int trailingZeroes(int n) {\n    return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "173. Binary Search Tree Iterator",
      "code": "class BSTIterator {\n public:\n  BSTIterator(TreeNode* root) {\n    inorder(root);\n  }\n\n  /** @return the next smallest number */\n  int next() {\n    return vals[i++];\n  }\n\n  /** @return whether we have a next smallest number */\n  bool hasNext() {\n    return i < vals.size();\n  }\n\n private:\n  int i = 0;\n  vector<int> vals;\n\n  void inorder(TreeNode* root) {\n    if (root == nullptr)\n      return;\n\n    inorder(root->left);\n    vals.push_back(root->val);\n    inorder(root->right);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "174. Dungeon Game",
      "code": "class Solution {\n public:\n  int calculateMinimumHP(vector<vector<int>>& dungeon) {\n    const int m = dungeon.size();\n    const int n = dungeon[0].size();\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, INT_MAX));\n    dp[m][n - 1] = 1;\n    dp[m - 1][n] = 1;\n\n    for (int i = m - 1; i >= 0; --i)\n      for (int j = n - 1; j >= 0; --j) {\n        dp[i][j] = min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j];\n        dp[i][j] = max(dp[i][j], 1);\n      }\n\n    return dp[0][0];\n  }\n };\n"
    }
  ],
  null,
  null,
  null,
  null,
  [
    {
      "id": "179. Largest Number",
      "code": "class Solution {\n public:\n  string largestNumber(vector<int>& nums) {\n    string ans;\n\n    sort(begin(nums), end(nums), [](int a, int b) {\n      return to_string(a) + to_string(b) > to_string(b) + to_string(a);\n    });\n\n    for (const int num : nums)\n      ans += to_string(num);\n\n    return ans[0] == '0' ? \"0\" : ans;\n  }\n };\n"
    }
  ],
  null,
  null,
  null,
  null,
  null,
  null,
  [
    {
      "id": "186. Reverse Words in a String II",
      "code": "class Solution {\n public:\n  void reverseWords(vector<char>& s) {\n    reverse(begin(s), end(s));  // Reverse the whole string\n    reverseWords(s, s.size());  // Reverse each word\n  }\n\n private:\n  void reverseWords(vector<char>& s, int n) {\n    int i = 0;\n    int j = 0;\n\n    while (i < n) {\n      while (i < j || i < n && s[i] == ' ')  // Skip spaces\n        ++i;\n      while (j < i || j < n && s[j] != ' ')  // Skip non spaces\n        ++j;\n      reverse(begin(s) + i, begin(s) + j);  // Reverse the word\n    }\n  }\n };\n"
    }
  ],
  [
    {
      "id": "187. Repeated DNA Sequences",
      "code": "class Solution {\n public:\n  vector<string> findRepeatedDnaSequences(string s) {\n    unordered_set<string> ans;\n    unordered_set<string_view> seen;\n    const string_view sv(s);\n\n    for (int i = 0; i + 10 <= s.length(); ++i) {\n      if (seen.count(sv.substr(i, 10)))\n        ans.insert(s.substr(i, 10));\n      seen.insert(sv.substr(i, 10));\n    }\n\n    return {begin(ans), end(ans)};\n  }\n };\n"
    }
  ],
  [
    {
      "id": "188. Best Time to Buy and Sell Stock IV",
      "code": "class Solution {\n public:\n  int maxProfit(int k, vector<int>& prices) {\n    if (k >= prices.size() / 2) {\n      int sell = 0;\n      int hold = INT_MIN;\n\n      for (const int price : prices) {\n        sell = max(sell, hold + price);\n        hold = max(hold, sell - price);\n      }\n\n      return sell;\n    }\n\n    vector<int> sell(k + 1);\n    vector<int> hold(k + 1, INT_MIN);\n\n    for (const int price : prices)\n      for (int i = k; i > 0; --i) {\n        sell[i] = max(sell[i], hold[i] + price);\n        hold[i] = max(hold[i], sell[i - 1] - price);\n      }\n\n    return sell[k];\n  }\n };\n"
    }
  ],
  [
    {
      "id": "189. Rotate Array",
      "code": "class Solution {\n public:\n  void rotate(vector<int>& nums, int k) {\n    k %= nums.size();\n    reverse(nums, 0, nums.size() - 1);\n    reverse(nums, 0, k - 1);\n    reverse(nums, k, nums.size() - 1);\n  }\n\n private:\n  void reverse(vector<int>& nums, int l, int r) {\n    while (l < r)\n      swap(nums[l++], nums[r--]);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "190. Reverse Bits",
      "code": "class Solution {\n public:\n  uint32_t reverseBits(uint32_t n) {\n    uint32_t ans = 0;\n\n    for (int i = 0; i < 32; ++i)\n      if (n >> i & 1)\n        ans |= 1 << 31 - i;\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "191. Number of 1 Bits",
      "code": "class Solution {\n public:\n  int hammingWeight(uint32_t n) {\n    int ans = 0;\n\n    for (int i = 0; i < 32; ++i)\n      if ((n >> i) & 1)\n        ++ans;\n\n    return ans;\n  }\n };\n"
    }
  ],
  null,
  null,
  null,
  null,
  null,
  null,
  [
    {
      "id": "198. House Robber",
      "code": "class Solution {\n public:\n  int rob(vector<int>& nums) {\n    if (nums.empty())\n      return 0;\n    if (nums.size() == 1)\n      return nums[0];\n\n    // dp[i] := max money of robbing nums[0..i]\n    vector<int> dp(nums.size());\n    dp[0] = nums[0];\n    dp[1] = max(nums[0], nums[1]);\n\n    for (int i = 2; i < nums.size(); ++i)\n      dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);\n\n    return dp.back();\n  }\n };\n"
    }
  ],
  [
    {
      "id": "199. Binary Tree Right Side View",
      "code": "class Solution {\n public:\n  vector<int> rightSideView(TreeNode* root) {\n    if (root == nullptr)\n      return {};\n\n    vector<int> ans;\n    queue<TreeNode*> q{{root}};\n\n    while (!q.empty()) {\n      const int size = q.size();\n      for (int i = 0; i < size; ++i) {\n        TreeNode* node = q.front();\n        q.pop();\n        if (i == size - 1)\n          ans.push_back(node->val);\n        if (node->left)\n          q.push(node->left);\n        if (node->right)\n          q.push(node->right);\n      }\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "200. Number of Islands",
      "code": "class Solution {\n public:\n  int numIslands(vector<vector<char>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    const vector<int> dirs{0, 1, 0, -1, 0};\n    int ans = 0;\n\n    auto bfs = [&](int r, int c) {\n      queue<pair<int, int>> q{{{r, c}}};\n      grid[r][c] = '2';  // Mark '2' as visited\n      while (!q.empty()) {\n        const auto [i, j] = q.front();\n        q.pop();\n        for (int k = 0; k < 4; ++k) {\n          const int x = i + dirs[k];\n          const int y = j + dirs[k + 1];\n          if (x < 0 || x == m || y < 0 || y == n)\n            continue;\n          if (grid[x][y] != '1')\n            continue;\n          q.emplace(x, y);\n          grid[x][y] = '2';  // Mark '2' as visited\n        }\n      }\n    };\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (grid[i][j] == '1') {\n          bfs(i, j);\n          ++ans;\n        }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "201. Bitwise AND of Numbers Range",
      "code": "class Solution {\n public:\n  int rangeBitwiseAnd(int m, int n) {\n    int shiftBits = 0;\n\n    while (m != n) {\n      m >>= 1;\n      n >>= 1;\n      ++shiftBits;\n    }\n\n    return m << shiftBits;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "202. Happy Number",
      "code": "class Solution {\n public:\n  bool isHappy(int n) {\n    int slow = squaredSum(n);\n    int fast = squaredSum(squaredSum(n));\n\n    while (slow != fast) {\n      slow = squaredSum(slow);\n      fast = squaredSum(squaredSum(fast));\n    }\n\n    return slow == 1;\n  }\n\n private:\n  int squaredSum(int n) {\n    int sum = 0;\n    while (n) {\n      sum += pow(n % 10, 2);\n      n /= 10;\n    }\n    return sum;\n  };\n};\n"
    }
  ],
  [
    {
      "id": "203. Remove Linked List Elements",
      "code": "class Solution {\n public:\n  ListNode* removeElements(ListNode* head, int val) {\n    ListNode dummy(0, head);\n    ListNode* prev = &dummy;\n\n    for (; head; head = head->next)\n      if (head->val != val) {\n        prev->next = head;\n        prev = prev->next;\n      }\n    prev->next = nullptr;  // In case the last val == val\n\n    return dummy.next;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "204. Count Primes",
      "code": "class Solution {\n public:\n  int countPrimes(int n) {\n    if (n <= 2)\n      return 0;\n    const vector<bool> isPrime = sieveEratosthenes(n);\n    return count(begin(isPrime), end(isPrime), true);\n  }\n\n private:\n  vector<bool> sieveEratosthenes(int n) {\n    vector<bool> isPrime(n, true);\n    isPrime[0] = false;\n    isPrime[1] = false;\n    for (int i = 2; i * i < n; ++i)\n      if (isPrime[i])\n        for (int j = i * i; j < n; j += i)\n          isPrime[j] = false;\n    return isPrime;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "205. Isomorphic Strings",
      "code": "class Solution {\n public:\n  bool isIsomorphic(string s, string t) {\n    vector<int> charToIndex_s(128);\n    vector<int> charToIndex_t(128);\n\n    for (int i = 0; i < s.length(); ++i) {\n      if (charToIndex_s[s[i]] != charToIndex_t[t[i]])\n        return false;\n      charToIndex_s[s[i]] = i + 1;\n      charToIndex_t[t[i]] = i + 1;\n    }\n\n    return true;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "206. Reverse Linked List",
      "code": "class Solution {\n public:\n  ListNode* reverseList(ListNode* head) {\n    if (!head || !head->next)\n      return head;\n\n    ListNode* newHead = reverseList(head->next);\n    head->next->next = head;\n    head->next = nullptr;\n    return newHead;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "207. Course Schedule",
      "code": "enum class State { kInit, kVisiting, kVisited };\n\n class Solution {\n public:\n  bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n    vector<vector<int>> graph(numCourses);\n    vector<State> state(numCourses);\n\n    for (const vector<int>& p : prerequisites)\n      graph[p[1]].push_back(p[0]);\n\n    for (int i = 0; i < numCourses; ++i)\n      if (hasCycle(graph, i, state))\n        return false;\n\n    return true;\n  }\n\n private:\n  bool hasCycle(const vector<vector<int>>& graph, int u, vector<State>& state) {\n    if (state[u] == State::kVisiting)\n      return true;\n    if (state[u] == State::kVisited)\n      return false;\n\n    state[u] = State::kVisiting;\n    for (const int v : graph[u])\n      if (hasCycle(graph, v, state))\n        return true;\n    state[u] = State::kVisited;\n\n    return false;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "208. Implement Trie (Prefix Tree)",
      "code": "struct TrieNode {\n  vector<shared_ptr<TrieNode>> children;\n  bool isWord = false;\n  TrieNode() : children(26) {}\n };\n\n class Trie {\n public:\n  void insert(const string& word) {\n    shared_ptr<TrieNode> node = root;\n    for (const char c : word) {\n      const int i = c - 'a';\n      if (node->children[i] == nullptr)\n        node->children[i] = make_shared<TrieNode>();\n      node = node->children[i];\n    }\n    node->isWord = true;\n  }\n\n  bool search(const string& word) {\n    shared_ptr<TrieNode> node = find(word);\n    return node && node->isWord;\n  }\n\n  bool startsWith(const string& prefix) {\n    return find(prefix) != nullptr;\n  }\n\n private:\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n\n  shared_ptr<TrieNode> find(const string& prefix) {\n    shared_ptr<TrieNode> node = root;\n    for (const char c : prefix) {\n      const int i = c - 'a';\n      if (node->children[i] == nullptr)\n        return nullptr;\n      node = node->children[i];\n    }\n    return node;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "209. Minimum Size Subarray Sum",
      "code": "class Solution {\n public:\n  int minSubArrayLen(int s, vector<int>& nums) {\n    int ans = INT_MAX;\n    int sum = 0;\n\n    for (int l = 0, r = 0; r < nums.size(); ++r) {\n      sum += nums[r];\n      while (sum >= s) {\n        ans = min(ans, r - l + 1);\n        sum -= nums[l++];\n      }\n    }\n\n    return ans < INT_MAX ? ans : 0;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "210. Course Schedule II",
      "code": "enum class State { kInit, kVisiting, kVisited };\n\n class Solution {\n public:\n  vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\n    vector<int> ans;\n    vector<vector<int>> graph(numCourses);\n    vector<State> state(numCourses);\n\n    for (const auto& p : prerequisites)\n      graph[p[1]].push_back(p[0]);\n\n    for (int i = 0; i < numCourses; ++i)\n      if (hasCycle(graph, i, state, ans))\n        return {};\n\n    reverse(begin(ans), end(ans));\n    return ans;\n  }\n\n private:\n  bool hasCycle(const vector<vector<int>>& graph, int u, vector<State>& state,\n                vector<int>& ans) {\n    if (state[u] == State::kVisiting)\n      return true;\n    if (state[u] == State::kVisited)\n      return false;\n\n    state[u] = State::kVisiting;\n    for (const int v : graph[u])\n      if (hasCycle(graph, v, state, ans))\n        return true;\n    state[u] = State::kVisited;\n    ans.push_back(u);\n\n    return false;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "211. Design Add and Search Words Data Structure",
      "code": "struct TrieNode {\n  vector<shared_ptr<TrieNode>> children;\n  bool isWord = false;\n  TrieNode() : children(26) {}\n };\n\n class WordDictionary {\n public:\n  void addWord(const string& word) {\n    shared_ptr<TrieNode> node = root;\n    for (const char c : word) {\n      const int i = c - 'a';\n      if (node->children[i] == nullptr)\n        node->children[i] = make_shared<TrieNode>();\n      node = node->children[i];\n    }\n    node->isWord = true;\n  }\n\n  bool search(const string& word) {\n    return dfs(word, 0, root);\n  }\n\n private:\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n\n  bool dfs(const string& word, int s, shared_ptr<TrieNode> node) {\n    if (s == word.length())\n      return node->isWord;\n    if (word[s] != '.') {\n      shared_ptr<TrieNode> next = node->children[word[s] - 'a'];\n      return next ? dfs(word, s + 1, next) : false;\n    }\n\n    // word[s] == '.' -> search all 26 children\n    for (int i = 0; i < 26; ++i)\n      if (node->children[i] && dfs(word, s + 1, node->children[i]))\n        return true;\n\n    return false;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "212. Word Search II",
      "code": "struct TrieNode {\n  vector<shared_ptr<TrieNode>> children;\n  const string* word = nullptr;\n  TrieNode() : children(26) {}\n };\n\n class Solution {\n public:\n  vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\n    vector<string> ans;\n\n    for (const string& word : words)\n      insert(word);\n\n    for (int i = 0; i < board.size(); ++i)\n      for (int j = 0; j < board[0].size(); ++j)\n        dfs(board, i, j, root, ans);\n\n    return ans;\n  }\n\n private:\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n\n  void insert(const string& word) {\n    shared_ptr<TrieNode> node = root;\n    for (const char c : word) {\n      const int i = c - 'a';\n      if (node->children[i] == nullptr)\n        node->children[i] = make_shared<TrieNode>();\n      node = node->children[i];\n    }\n    node->word = &word;\n  }\n\n  void dfs(vector<vector<char>>& board, int i, int j, shared_ptr<TrieNode> node,\n           vector<string>& ans) {\n    if (i < 0 || i == board.size() || j < 0 || j == board[0].size())\n      return;\n    if (board[i][j] == '*')\n      return;\n\n    const char c = board[i][j];\n    shared_ptr<TrieNode> child = node->children[c - 'a'];\n    if (child == nullptr)\n      return;\n    if (child->word != nullptr) {\n      ans.push_back(*child->word);\n      child->word = nullptr;\n    }\n\n    board[i][j] = '*';\n    dfs(board, i + 1, j, child, ans);\n    dfs(board, i - 1, j, child, ans);\n    dfs(board, i, j + 1, child, ans);\n    dfs(board, i, j - 1, child, ans);\n    board[i][j] = c;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "213. House Robber II",
      "code": "class Solution {\n public:\n  int rob(vector<int>& nums) {\n    if (nums.empty())\n      return 0;\n    if (nums.size() == 1)\n      return nums[0];\n\n    auto rob = [&](int l, int r) {\n      int prev1 = 0;  // dp[i - 1]\n      int prev2 = 0;  // dp[i - 2]\n\n      for (int i = l; i <= r; ++i) {\n        const int dp = max(prev1, prev2 + nums[i]);\n        prev2 = prev1;\n        prev1 = dp;\n      }\n\n      return prev1;\n    };\n\n    return max(rob(0, nums.size() - 2), rob(1, nums.size() - 1));\n  }\n };\n"
    }
  ],
  [
    {
      "id": "214. Shortest Palindrome",
      "code": "class Solution {\n public:\n  string shortestPalindrome(string s) {\n    string t = s;\n    reverse(begin(t), end(t));\n\n    const string_view sv_s(s);\n    const string_view sv_t(t);\n\n    for (int i = 0; i < s.length(); ++i)\n      if (sv_s.substr(0, s.length() - i) == sv_t.substr(i))\n        return t.substr(0, i) + s;\n\n    return t + s;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "215. Kth Largest Element in an Array",
      "code": "class Solution {\n public:\n  int findKthLargest(vector<int>& nums, int k) {\n    priority_queue<int, vector<int>, greater<>> minHeap;\n\n    for (const int num : nums) {\n      minHeap.push(num);\n      if (minHeap.size() > k)\n        minHeap.pop();\n    }\n\n    return minHeap.top();\n  }\n };\n"
    }
  ],
  [
    {
      "id": "216. Combination Sum III",
      "code": "class Solution {\n public:\n  vector<vector<int>> combinationSum3(int k, int n) {\n    vector<vector<int>> ans;\n    dfs(k, n, 1, {}, ans);\n    return ans;\n  }\n\n private:\n  void dfs(int k, int n, int s, vector<int>&& path, vector<vector<int>>& ans) {\n    if (k == 0 && n == 0) {\n      ans.push_back(path);\n      return;\n    }\n    if (k == 0 || n <= 0)\n      return;\n\n    for (int i = s; i <= 9; ++i) {\n      path.push_back(i);\n      dfs(k - 1, n - i, i + 1, move(path), ans);\n      path.pop_back();\n    }\n  }\n };\n"
    }
  ],
  [
    {
      "id": "217. Contains Duplicate",
      "code": "class Solution {\n public:\n  bool containsDuplicate(vector<int>& nums) {\n    unordered_set<int> seen;\n\n    for (const int num : nums)\n      if (!seen.insert(num).second)\n        return true;\n\n    return false;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "218. The Skyline Problem",
      "code": "class Solution {\n public:\n  vector<vector<int>> getSkyline(const vector<vector<int>>& buildings) {\n    const int n = buildings.size();\n    if (n == 0)\n      return {};\n    if (n == 1) {\n      const int left = buildings[0][0];\n      const int right = buildings[0][1];\n      const int height = buildings[0][2];\n      return {{left, height}, {right, 0}};\n    }\n\n    const vector<vector<int>> left =\n        getSkyline({begin(buildings), begin(buildings) + n / 2});\n    const vector<vector<int>> right =\n        getSkyline({begin(buildings) + n / 2, end(buildings)});\n    return merge(left, right);\n  }\n\n private:\n  vector<vector<int>> merge(const vector<vector<int>>& left,\n                            const vector<vector<int>>& right) {\n    vector<vector<int>> ans;\n    int i = 0;  // left's index\n    int j = 0;  // right's index\n    int leftY = 0;\n    int rightY = 0;\n\n    while (i < left.size() && j < right.size())\n      // Choose the point with smaller x\n      if (left[i][0] < right[j][0]) {\n        leftY = left[i][1];  // Update the ongoing leftY\n        addPoint(ans, left[i][0], max(left[i++][1], rightY));\n      } else {\n        rightY = right[j][1];  // Update the ongoing rightY\n        addPoint(ans, right[j][0], max(right[j++][1], leftY));\n      }\n\n    while (i < left.size())\n      addPoint(ans, left[i][0], left[i++][1]);\n\n    while (j < right.size())\n      addPoint(ans, right[j][0], right[j++][1]);\n\n    return ans;\n  }\n\n  void addPoint(vector<vector<int>>& ans, int x, int y) {\n    if (!ans.empty() && ans.back()[0] == x) {\n      ans.back()[1] = y;\n      return;\n    }\n    if (!ans.empty() && ans.back()[1] == y)\n      return;\n    ans.push_back({x, y});\n  }\n };\n"
    }
  ],
  [
    {
      "id": "219. Contains Duplicate II",
      "code": "class Solution {\n public:\n  bool containsNearbyDuplicate(vector<int>& nums, int k) {\n    unordered_set<int> seen;\n\n    for (int i = 0; i < nums.size(); ++i) {\n      if (!seen.insert(nums[i]).second)\n        return true;\n      if (i >= k)\n        seen.erase(nums[i - k]);\n    }\n\n    return false;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "220. Contains Duplicate III",
      "code": "class Solution {\n public:\n  bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff,\n                                     int valueDiff) {\n    set<long> window;\n\n    for (int i = 0; i < nums.size(); ++i) {\n      if (const auto it =\n              window.lower_bound(static_cast<long>(nums[i]) - valueDiff);\n          it != cend(window) && *it - nums[i] <= valueDiff)\n        return true;\n      window.insert(nums[i]);\n      if (i >= indexDiff)\n        window.erase(nums[i - indexDiff]);\n    }\n\n    return false;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "221. Maximal Square",
      "code": "class Solution {\n public:\n  int maximalSquare(vector<vector<char>>& matrix) {\n    const int m = matrix.size();\n    const int n = matrix[0].size();\n    vector<vector<int>> dp(m, vector<int>(n));\n    int maxLength = 0;\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j) {\n        if (i == 0 || j == 0 || matrix[i][j] == '0')\n          dp[i][j] = matrix[i][j] == '1' ? 1 : 0;\n        else\n          dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;\n        maxLength = max(maxLength, dp[i][j]);\n      }\n\n    return maxLength * maxLength;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "222. Count Complete Tree Nodes",
      "code": "class Solution {\n public:\n  int countNodes(TreeNode* root) {\n    if (root == nullptr)\n      return 0;\n    return 1 + countNodes(root->left) + countNodes(root->right);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "223. Rectangle Area",
      "code": "class Solution {\n public:\n  int computeArea(long A, long B, long C, long D,\n                  long E, long F, long G, long H) {\n    const long x = max(A, E) < min(C, G) ? (min(C, G) - max(A, E)) : 0;\n    const long y = max(B, F) < min(D, H) ? (min(D, H) - max(B, F)) : 0;\n    return (C - A) * (D - B) + (G - E) * (H - F) - x * y;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "224. Basic Calculator",
      "code": "class Solution {\n public:\n  int calculate(string s) {\n    int ans = 0;\n    int num = 0;\n    int sign = 1;\n    stack<int> stack{{sign}};  // Stack.top(): current env's sign\n\n    for (const char c : s)\n      if (isdigit(c))\n        num = num * 10 + (c - '0');\n      else if (c == '(')\n        stack.push(sign);\n      else if (c == ')')\n        stack.pop();\n      else if (c == '+' || c == '-') {\n        ans += sign * num;\n        sign = (c == '+' ? 1 : -1) * stack.top();\n        num = 0;\n      }\n\n    return ans + sign * num;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "225. Implement Stack using Queues",
      "code": "class MyStack {\n public:\n  void push(int x) {\n    q.push(x);\n    for (int i = 0; i < q.size() - 1; ++i) {\n      q.push(q.front());\n      q.pop();\n    }\n  }\n\n  int pop() {\n    const int val = q.front();\n    q.pop();\n    return val;\n  }\n\n  int top() {\n    return q.front();\n  }\n\n  bool empty() {\n    return q.empty();\n  }\n\n private:\n  queue<int> q;\n};\n"
    }
  ],
  [
    {
      "id": "226. Invert Binary Tree",
      "code": "class Solution {\n public:\n  TreeNode* invertTree(TreeNode* root) {\n    if (root == nullptr)\n      return nullptr;\n\n    TreeNode* const left = root->left;\n    TreeNode* const right = root->right;\n    root->left = invertTree(right);\n    root->right = invertTree(left);\n    return root;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "227. Basic Calculator II",
      "code": "class Solution {\n public:\n  int calculate(string s) {\n    stack<int> nums;  // Stores nums\n    stack<char> ops;  // Stores operators\n\n    for (int i = 0; i < s.length(); ++i) {\n      const char c = s[i];\n      if (isdigit(c)) {\n        int num = c - '0';\n        while (i + 1 < s.length() && isdigit(s[i + 1])) {\n          num = num * 10 + (s[i + 1] - '0');\n          ++i;\n        }\n        nums.push(num);\n      } else if (c == '+' || c == '-' || c == '*' || c == '/') {\n        while (!ops.empty() && compare(ops.top(), c))\n          nums.push(calculate(pop(ops), pop(nums), pop(nums)));\n        ops.push(c);\n      }\n    }\n\n    while (!ops.empty())\n      nums.push(calculate(pop(ops), pop(nums), pop(nums)));\n\n    return nums.top();\n  }\n\n private:\n  int calculate(char op, int b, int a) {\n    switch (op) {\n      case '+':\n        return a + b;\n      case '-':\n        return a - b;\n      case '*':\n        return a * b;\n      case '/':\n        return a / b;\n    }\n    throw;\n  }\n\n  // Returns true if priority(op1) >= priority(op2)\n  bool compare(char op1, char op2) {\n    return op1 == '*' || op1 == '/' || op2 == '+' || op2 == '-';\n  }\n\n  char pop(stack<char>& ops) {\n    const char op = ops.top();\n    ops.pop();\n    return op;\n  }\n\n  int pop(stack<int>& nums) {\n    const int num = nums.top();\n    nums.pop();\n    return num;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "228. Summary Ranges",
      "code": "class Solution {\n public:\n  vector<string> summaryRanges(vector<int>& nums) {\n    vector<string> ans;\n\n    for (int i = 0; i < nums.size(); ++i) {\n      const int begin = nums[i];\n      while (i + 1 < nums.size() && nums[i] == nums[i + 1] - 1)\n        ++i;\n      const int end = nums[i];\n      if (begin == end)\n        ans.push_back(to_string(begin));\n      else\n        ans.push_back(to_string(begin) + \"->\" + to_string(end));\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "229. Majority Element II",
      "code": "class Solution {\n public:\n  vector<int> majorityElement(vector<int>& nums) {\n    vector<int> ans;\n    int candidate1 = 0;\n    int candidate2 = 1;   // Any number different from candidate1\n    int countSoFar1 = 0;  // # of candidate1 so far\n    int countSoFar2 = 0;  // # of candidate2 so far\n\n    for (const int num : nums)\n      if (num == candidate1) {\n        ++countSoFar1;\n      } else if (num == candidate2) {\n        ++countSoFar2;\n      } else if (countSoFar1 == 0) {  // Assign new candidate\n        candidate1 = num;\n        ++countSoFar1;\n      } else if (countSoFar2 == 0) {  // Assign new candidate\n        candidate2 = num;\n        ++countSoFar2;\n      } else {  // Meet a new number, so pair out previous counts\n        --countSoFar1;\n        --countSoFar2;\n      }\n\n    const int count1 = count(begin(nums), end(nums), candidate1);\n    const int count2 = count(begin(nums), end(nums), candidate2);\n\n    if (count1 > nums.size() / 3)\n      ans.push_back(candidate1);\n    if (count2 > nums.size() / 3)\n      ans.push_back(candidate2);\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "230. Kth Smallest Element in a BST",
      "code": "class Solution {\n public:\n  int kthSmallest(TreeNode* root, int k) {\n    const int leftCount = countNodes(root->left);\n\n    if (leftCount == k - 1)\n      return root->val;\n    if (leftCount >= k)\n      return kthSmallest(root->left, k);\n    return kthSmallest(root->right, k - 1 - leftCount);\n  }\n\n private:\n  int countNodes(TreeNode* root) {\n    if (root == nullptr)\n      return 0;\n    return 1 + countNodes(root->left) + countNodes(root->right);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "231. Power of Two",
      "code": "class Solution {\n public:\n  bool isPowerOfTwo(int n) {\n    return n < 0 ? false : __builtin_popcountll(n) == 1;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "232. Implement Queue using Stacks",
      "code": "class MyQueue {\n public:\n  void push(int x) {\n    input.push(x);\n  }\n\n  int pop() {\n    peek();\n    const int val = output.top();\n    output.pop();\n    return val;\n  }\n\n  int peek() {\n    if (output.empty())\n      while (!input.empty())\n        output.push(input.top()), input.pop();\n    return output.top();\n  }\n\n  bool empty() {\n    return input.empty() && output.empty();\n  }\n\n private:\n  stack<int> input;\n  stack<int> output;\n};\n"
    }
  ],
  [
    {
      "id": "233. Number of Digit One",
      "code": "class Solution {\n public:\n  int countDigitOne(int n) {\n    int ans = 0;\n\n    for (long pow10 = 1; pow10 <= n; pow10 *= 10) {\n      const long divisor = pow10 * 10;\n      const int quotient = n / divisor;\n      const int remainder = n % divisor;\n      if (quotient > 0)\n        ans += quotient * pow10;\n      if (remainder >= pow10)\n        ans += min(remainder - pow10 + 1, pow10);\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "234. Palindrome Linked List",
      "code": "class Solution {\n public:\n  bool isPalindrome(ListNode* head) {\n    ListNode* slow = head;\n    ListNode* fast = head;\n\n    while (fast && fast->next) {\n      slow = slow->next;\n      fast = fast->next->next;\n    }\n\n    if (fast != nullptr)\n      slow = slow->next;\n    slow = reverseList(slow);\n\n    while (slow) {\n      if (slow->val != head->val)\n        return false;\n      slow = slow->next;\n      head = head->next;\n    }\n\n    return true;\n  }\n\n private:\n  ListNode* reverseList(ListNode* head) {\n    ListNode* prev = nullptr;\n\n    while (head) {\n      ListNode* next = head->next;\n      head->next = prev;\n      prev = head;\n      head = next;\n    }\n\n    return prev;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "235. Lowest Common Ancestor of a Binary Search Tree",
      "code": "class Solution {\n public:\n  TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n    if (root->val > max(p->val, q->val))\n      return lowestCommonAncestor(root->left, p, q);\n    if (root->val < min(p->val, q->val))\n      return lowestCommonAncestor(root->right, p, q);\n    return root;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "236. Lowest Common Ancestor of a Binary Tree",
      "code": "class Solution {\n public:\n  TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n    if (root == nullptr || root == p || root == q)\n      return root;\n\n    TreeNode* l = lowestCommonAncestor(root->left, p, q);\n    TreeNode* r = lowestCommonAncestor(root->right, p, q);\n\n    if (l && r)\n      return root;\n    return l ? l : r;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "237. Delete Node in a Linked List",
      "code": "class Solution {\n public:\n  void deleteNode(ListNode* node) {\n    node->val = node->next->val;\n    node->next = node->next->next;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "238. Product of Array Except Self",
      "code": "class Solution {\n public:\n  vector<int> productExceptSelf(vector<int>& nums) {\n    const int n = nums.size();\n    vector<int> ans(n);        // Can also use nums as the ans array\n    vector<int> prefix(n, 1);  // Prefix product\n    vector<int> suffix(n, 1);  // Suffix product\n\n    for (int i = 1; i < n; ++i)\n      prefix[i] = prefix[i - 1] * nums[i - 1];\n\n    for (int i = n - 2; i >= 0; --i)\n      suffix[i] = suffix[i + 1] * nums[i + 1];\n\n    for (int i = 0; i < n; ++i)\n      ans[i] = prefix[i] * suffix[i];\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "239. Sliding Window Maximum",
      "code": "class Solution {\n public:\n  vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n    vector<int> ans;\n    deque<int> q;\n  // Max queue\n\n    for (int i = 0; i < nums.size(); ++i) {\n      while (!q.empty() && q.back() < nums[i])\n        q.pop_back();\n      q.push_back(nums[i]);\n      if (i >= k && nums[i - k] == q.front())  // Out of bound\n        q.pop_front();\n      if (i >= k - 1)\n        ans.push_back(q.front());\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "240. Search a 2D Matrix II",
      "code": "class Solution {\n public:\n  bool searchMatrix(vector<vector<int>>& matrix, int target) {\n    int r = 0;\n    int c = matrix[0].size() - 1;\n\n    while (r < matrix.size() && c >= 0) {\n      if (matrix[r][c] == target)\n        return true;\n      if (matrix[r][c] > target)\n        --c;\n      else\n        ++r;\n    }\n\n    return false;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "241. Different Ways to Add Parentheses",
      "code": "class Solution {\n public:\n  vector<int> diffWaysToCompute(string expression) {\n    return ways(expression, {});\n  }\n\n private:\n  vector<int> ways(const string& s, unordered_map<string, vector<int>>&& memo) {\n    if (const auto it = memo.find(s); it != cend(memo))\n      return it->second;\n\n    vector<int> ans;\n\n    for (int i = 0; i < s.length(); ++i)\n      if (ispunct(s[i]))\n        for (const int a : ways(s.substr(0, i), move(memo)))\n          for (const int b : ways(s.substr(i + 1), move(memo)))\n            if (s[i] == '+')\n              ans.push_back(a + b);\n            else if (s[i] == '-')\n              ans.push_back(a - b);\n            else\n              ans.push_back(a * b);\n\n    return memo[s] = (ans.empty() ? vector<int>{stoi(s)} : ans);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "242. Valid Anagram",
      "code": "class Solution {\n public:\n  bool isAnagram(string s, string t) {\n    if (s.length() != t.length())\n      return false;\n\n    vector<int> count(128);\n\n    for (const char c : s)\n      ++count[c];\n\n    for (const char c : t)\n      if (--count[c] < 0)\n        return false;\n\n    return true;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "243. Shortest Word Distance",
      "code": "class Solution {\n public:\n  int shortestDistance(vector<string>& wordsDict, string word1, string word2) {\n    int ans = wordsDict.size();\n    int index1 = -1;  // wordsDict[index1] == word1\n    int index2 = -1;  // wordsDict[index2] == word2\n\n    for (int i = 0; i < wordsDict.size(); ++i) {\n      if (wordsDict[i] == word1) {\n        index1 = i;\n        if (index2 != -1)\n          ans = min(ans, index1 - index2);\n      }\n      if (wordsDict[i] == word2) {\n        index2 = i;\n        if (index1 != -1)\n          ans = min(ans, index2 - index1);\n      }\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "244. Shortest Word Distance II",
      "code": "class WordDistance {\n public:\n  WordDistance(vector<string>& words) {\n    for (int i = 0; i < words.size(); ++i)\n      wordToIndices[words[i]].push_back(i);\n  }\n\n  int shortest(string word1, string word2) {\n    const vector<int> indices1 = wordToIndices[word1];\n    const vector<int> indices2 = wordToIndices[word2];\n    int ans = INT_MAX;\n\n    for (int i = 0, j = 0; i < indices1.size() && j < indices2.size();) {\n      ans = min(ans, abs(indices1[i] - indices2[j]));\n      if (indices1[i] < indices2[j])\n        ++i;\n      else\n        ++j;\n    }\n\n    return ans;\n  }\n\n private:\n  unordered_map<string, vector<int>> wordToIndices;\n};\n"
    }
  ],
  [
    {
      "id": "245. Shortest Word Distance III",
      "code": "class Solution {\n public:\n  int shortestWordDistance(vector<string>& words, string word1, string word2) {\n    const bool isSame = word1 == word2;\n    int ans = INT_MAX;\n    // If word1 == word2, index1 is the newest index\n    int index1 = words.size();\n    // If word1 == word2, index2 is the previous index\n    int index2 = -words.size();\n\n    for (int i = 0; i < words.size(); ++i) {\n      if (words[i] == word1) {\n        if (isSame)\n          index2 = index1;\n        index1 = i;\n      } else if (words[i] == word2) {\n        index2 = i;\n      }\n      ans = min(ans, abs(index1 - index2));\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "246. Strobogrammatic Number",
      "code": "class Solution {\n public:\n  bool isStrobogrammatic(string num) {\n    const vector<char> rotated{'0', '1', 'x', 'x', 'x',\n                               'x', '9', 'x', '8', '6'};\n    int l = 0;\n    int r = num.length() - 1;\n\n    while (l <= r)\n      if (num[l++] != rotated[num[r--] - '0'])\n        return false;\n\n    return true;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "247. Strobogrammatic Number II",
      "code": "class Solution {\n public:\n  vector<string> findStrobogrammatic(int n) {\n    return helper(n, n);\n  }\n\n private:\n  vector<string> helper(int n, int k) {\n    if (n == 0)\n      return {\"\"};\n    if (n == 1)\n      return {\"0\", \"1\", \"8\"};\n\n    vector<string> ans;\n\n    for (const string& inner : helper(n - 2, k)) {\n      if (n < k)\n        ans.push_back(\"0\" + inner + \"0\");\n      ans.push_back(\"1\" + inner + \"1\");\n      ans.push_back(\"6\" + inner + \"9\");\n      ans.push_back(\"8\" + inner + \"8\");\n      ans.push_back(\"9\" + inner + \"6\");\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "248. Strobogrammatic Number III",
      "code": "class Solution {\n public:\n  int strobogrammaticInRange(string low, string high) {\n    int ans = 0;\n\n    for (int n = low.length(); n <= high.length(); ++n) {\n      string s(n, ' ');\n      dfs(low, high, s, 0, n - 1, ans);\n    }\n\n    return ans;\n  }\n\n private:\n  const vector<pair<char, char>> pairs{\n      {'0', '0'}, {'1', '1'}, {'6', '9'}, {'8', '8'}, {'9', '6'}};\n\n  void dfs(const string& low, const string& high, string& s, int l, int r,\n           int& ans) {\n    if (l > r) {\n      if (s.length() == low.length() && s < low)\n        return;\n      if (s.length() == high.length() && s > high)\n        return;\n      ++ans;\n      return;\n    }\n\n    for (const auto& [leftDigit, rightDigit] : pairs) {\n      if (l == r && leftDigit != rightDigit)\n        continue;\n      s[l] = leftDigit;\n      s[r] = rightDigit;\n      if (s.length() > 1 && s[0] == '0')\n        continue;\n      dfs(low, high, s, l + 1, r - 1, ans);\n    }\n  }\n };\n"
    }
  ],
  [
    {
      "id": "249. Group Shifted Strings",
      "code": "class Solution {\n public:\n  vector<vector<string>> groupStrings(vector<string>& strings) {\n    vector<vector<string>> ans;\n    unordered_map<string, vector<string>> keyToStrings;\n\n    for (const string& s : strings)\n      keyToStrings[getKey(s)].push_back(s);\n\n    for (const auto& [_, strings] : keyToStrings)\n      ans.push_back(strings);\n\n    return ans;\n  }\n\n private:\n  // \"abc\" -> \"11\" because diff(a, b) = 1 and diff(b, c) = 1\n  string getKey(const string& s) {\n    string key;\n\n    for (int i = 1; i < s.length(); ++i) {\n      const int diff = (s[i] - s[i - 1] + 26) % 26;\n      key += to_string(diff) + \",\";\n    }\n\n    return key;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "250. Count Univalue Subtrees",
      "code": "class Solution {\n public:\n  int countUnivalSubtrees(TreeNode* root) {\n    int ans = 0;\n    isUnival(root, INT_MAX, ans);\n    return ans;\n  }\n\n private:\n  bool isUnival(TreeNode* root, int val, int& ans) {\n    if (root == nullptr)\n      return true;\n\n    if (isUnival(root->left, root->val, ans) &\n        isUnival(root->right, root->val, ans)) {\n      ++ans;\n      return root->val == val;\n    }\n\n    return false;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "251. Flatten 2D Vector",
      "code": "class Vector2D {\n public:\n  Vector2D(vector<vector<int>>& vec) {\n    for (const vector<int>& A : vec)\n      for (const int a : A)\n        this->vec.push_back(a);\n  }\n\n  int next() {\n    return vec[i++];\n  }\n\n  bool hasNext() {\n    return i < vec.size();\n  }\n\n private:\n  vector<int> vec;\n  int i = 0;\n};\n"
    }
  ],
  [
    {
      "id": "252. Meeting Rooms",
      "code": "class Solution {\n public:\n  bool canAttendMeetings(vector<vector<int>>& intervals) {\n    sort(begin(intervals), end(intervals));\n\n    for (int i = 1; i < intervals.size(); ++i)\n      if (intervals[i - 1][1] > intervals[i][0])\n        return false;\n\n    return true;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "253. Meeting Rooms II",
      "code": "class Solution {\n public:\n  int minMeetingRooms(vector<vector<int>>& intervals) {\n    // Store end times of each room\n    priority_queue<int, vector<int>, greater<>> minHeap;\n\n    sort(begin(intervals), end(intervals));\n\n    for (const vector<int>& interval : intervals) {\n      if (!minHeap.empty() && interval[0] >= minHeap.top())\n        minHeap.pop();  // No overlap, we can reuse the same room\n      minHeap.push(interval[1]);\n    }\n\n    return minHeap.size();\n  }\n };\n"
    }
  ],
  [
    {
      "id": "254. Factor Combinations",
      "code": "class Solution {\n public:\n  vector<vector<int>> getFactors(int n) {\n    vector<vector<int>> ans;\n    dfs(n, 2, {}, ans);  // The smallest factor is 2\n    return ans;\n  }\n\n private:\n  void dfs(int n, int s, vector<int>&& path, vector<vector<int>>& ans) {\n    if (n <= 1) {\n      if (path.size() > 1)\n        ans.push_back(path);\n      return;\n    }\n\n    for (int i = s; i <= n; ++i)\n      if (n % i == 0) {\n        path.push_back(i);\n        dfs(n / i, i, move(path), ans);\n        path.pop_back();\n      }\n  }\n };\n"
    }
  ],
  [
    {
      "id": "255. Verify Preorder Sequence in Binary Search Tree",
      "code": "class Solution {\n public:\n  bool verifyPreorder(vector<int>& preorder) {\n    int i = 0;\n    dfs(preorder, i, INT_MIN, INT_MAX);\n    return i == preorder.size();\n  }\n\n private:\n  void dfs(const vector<int>& preorder, int& i, int min, int max) {\n    if (i == preorder.size())\n      return;\n    if (preorder[i] < min || preorder[i] > max)\n      return;\n\n    const int val = preorder[i++];\n    dfs(preorder, i, min, val);\n    dfs(preorder, i, val, max);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "256. Paint House",
      "code": "class Solution {\n public:\n  int minCost(vector<vector<int>>& costs) {\n    for (int i = 1; i < costs.size(); ++i) {\n      costs[i][0] += min(costs[i - 1][1], costs[i - 1][2]);\n      costs[i][1] += min(costs[i - 1][0], costs[i - 1][2]);\n      costs[i][2] += min(costs[i - 1][0], costs[i - 1][1]);\n    }\n\n    return *min_element(begin(costs.back()), end(costs.back()));\n  }\n };\n"
    }
  ],
  [
    {
      "id": "257. Binary Tree Paths",
      "code": "class Solution {\n public:\n  vector<string> binaryTreePaths(TreeNode* root) {\n    vector<string> ans;\n    dfs(root, {}, ans);\n    return ans;\n  }\n\n private:\n  void dfs(TreeNode* root, vector<string>&& path, vector<string>& ans) {\n    if (root == nullptr)\n      return;\n    if (root->left == nullptr && root->right == nullptr) {\n      ans.push_back(join(path) + to_string(root->val));\n      return;\n    }\n\n    path.push_back(to_string(root->val) + \"->\");\n    dfs(root->left, move(path), ans);\n    dfs(root->right, move(path), ans);\n    path.pop_back();\n  }\n\n  string join(const vector<string>& path) {\n    string joined;\n    for (const string& s : path)\n      joined += s;\n    return joined;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "258. Add Digits",
      "code": "class Solution {\n public:\n  int addDigits(int num) {\n    return 1 + (num - 1) % 9;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "259. 3Sum Smaller",
      "code": "class Solution {\n public:\n  int threeSumSmaller(vector<int>& nums, int target) {\n    if (nums.size() < 3)\n      return 0;\n\n    int ans = 0;\n\n    sort(begin(nums), end(nums));\n\n    for (int i = 0; i + 2 < nums.size(); ++i) {\n      int l = i + 1;\n      int r = nums.size() - 1;\n      while (l < r)\n        if (nums[i] + nums[l] + nums[r] < target) {\n          // (nums[i], nums[l], nums[r])\n          // (nums[i], nums[l], nums[r - 1])\n          // ...,\n          // (nums[i], nums[l], nums[l + 1])\n          ans += r - l;\n          ++l;\n        } else {\n          --r;\n        }\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "260. Single Number III",
      "code": "class Solution {\n public:\n  vector<int> singleNumber(vector<int>& nums) {\n    const int xors = accumulate(begin(nums), end(nums), 0, bit_xor<>());\n    const int lowbit = xors & -xors;\n    vector<int> ans(2);\n\n    // Seperate nums into two groups by the lowbit\n    for (const int num : nums)\n      if (num & lowbit)\n        ans[0] ^= num;\n      else\n        ans[1] ^= num;\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "261. Graph Valid Tree",
      "code": "class Solution {\n public:\n  bool validTree(int n, vector<vector<int>>& edges) {\n    if (n == 0 || edges.size() != n - 1)\n      return false;\n\n    vector<vector<int>> graph(n);\n    queue<int> q{{0}};\n    unordered_set<int> seen{{0}};\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      graph[u].push_back(v);\n      graph[v].push_back(u);\n    }\n\n    while (!q.empty()) {\n      const int u = q.front();\n      q.pop();\n      for (const int v : graph[u])\n        if (!seen.count(v)) {\n          q.push(v);\n          seen.insert(v);\n        }\n    }\n\n    return seen.size() == n;\n  }\n };\n"
    }
  ],
  null,
  [
    {
      "id": "263. Ugly Number",
      "code": "class Solution {\n public:\n  bool isUgly(int n) {\n    if (n == 0)\n      return false;\n\n    for (const int prime : {2, 3, 5})\n      while (n % prime == 0)\n        n /= prime;\n\n    return n == 1;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "264. Ugly Number II",
      "code": "class Solution {\n public:\n  int nthUglyNumber(int n) {\n    vector<int> uglyNums{1};\n    int i2 = 0;\n    int i3 = 0;\n    int i5 = 0;\n\n    while (uglyNums.size() < n) {\n      const int next2 = uglyNums[i2] * 2;\n      const int next3 = uglyNums[i3] * 3;\n      const int next5 = uglyNums[i5] * 5;\n      const int next = min({next2, next3, next5});\n      if (next == next2)\n        ++i2;\n      if (next == next3)\n        ++i3;\n      if (next == next5)\n        ++i5;\n      uglyNums.push_back(next);\n    }\n\n    return uglyNums.back();\n  }\n };\n"
    }
  ],
  [
    {
      "id": "265. Paint House II",
      "code": "class Solution {\n public:\n  int minCostII(vector<vector<int>>& costs) {\n    int prevIndex = -1;  // The previous minimum index\n    int prevMin1 = 0;    // Minimum cost so far\n    int prevMin2 = 0;    // 2nd minimum cost so far\n\n    for (const vector<int>& cost : costs) {  // O(n)\n      int index = -1;  // The painted index s.t. achieve the minimum cost after\n                       // Painting current house\n      int min1 = INT_MAX;  // The minimum cost after painting current house\n      int min2 = INT_MAX;  // The 2nd minimum cost after painting current house\n      for (int i = 0; i < cost.size(); ++i) {  // O(k)\n        const int theCost = cost[i] + (i == prevIndex ? prevMin2 : prevMin1);\n        if (theCost < min1) {\n          index = i;\n          min2 = min1;\n          min1 = theCost;\n        } else if (theCost < min2) {  // Min1 <= theCost < min2\n          min2 = theCost;\n        }\n      }\n      prevIndex = index;\n      prevMin1 = min1;\n      prevMin2 = min2;\n    }\n\n    return prevMin1;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "266. Palindrome Permutation",
      "code": "class Solution {\n public:\n  bool canPermutePalindrome(string s) {\n    unordered_set<char> seen;\n\n    for (const char c : s)\n      if (!seen.insert(c).second)\n        seen.erase(c);\n\n    return seen.size() <= 1;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "267. Palindrome Permutation II",
      "code": "class Solution {\n public:\n  vector<string> generatePalindromes(string s) {\n    int odd = 0;\n    unordered_map<char, int> count;\n\n    // Get character occurrence\n    for (const char c : s)\n      ++count[c];\n\n    // Count odd one\n    for (const auto& [_, value] : count)\n      if (value & 1)\n        ++odd;\n\n    // can't form any palindrome\n    if (odd > 1)\n      return {};\n\n    vector<string> ans;\n    vector<char> candidates;\n    string mid;\n\n    // Get mid and candidates characters\n    for (const auto& [key, value] : count) {\n      if (value & 1)\n        mid += key;\n      for (int i = 0; i < value / 2; ++i)\n        candidates.push_back(key);\n    }\n\n    // Backtracking to generate our ans (strings)\n    dfs(candidates, mid, vector<bool>(candidates.size()), \"\", ans);\n    return ans;\n  }\n\n private:\n  // Generate all unique palindromes from candidates\n  void dfs(const vector<char>& candidates, const string& mid,\n           vector<bool>&& used, string&& path, vector<string>& ans) {\n    if (path.length() == candidates.size()) {\n      string secondHalf = path;\n      reverse(begin(secondHalf), end(secondHalf));\n      ans.push_back(path + mid + secondHalf);\n      return;\n    }\n\n    for (int i = 0; i < candidates.size(); ++i) {\n      if (used[i])\n        continue;\n      if (i > 0 && candidates[i] == candidates[i - 1] && !used[i - 1])\n        continue;\n      used[i] = true;\n      path.push_back(candidates[i]);\n      dfs(candidates, mid, move(used), move(path), ans);\n      path.pop_back();\n      used[i] = false;\n    }\n  }\n };\n"
    }
  ],
  [
    {
      "id": "268. Missing Number",
      "code": "class Solution {\n public:\n  int missingNumber(vector<int>& nums) {\n    int ans = nums.size();\n\n    for (int i = 0; i < nums.size(); ++i)\n      ans ^= i ^ nums[i];\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "269. Alien Dictionary",
      "code": "class Solution {\n public:\n  string alienOrder(vector<string>& words) {\n    unordered_map<char, unordered_set<char>> graph;\n    vector<int> inDegree(26);\n    buildGraph(graph, words, inDegree);\n    return topology(graph, inDegree);\n  }\n\n private:\n  void buildGraph(unordered_map<char, unordered_set<char>>& graph,\n                  const vector<string>& words, vector<int>& inDegree) {\n    // Create node for each character in each word\n    for (const string& word : words)\n      for (const char c : word)\n        if (!graph.count(c))\n          graph[c] = unordered_set<char>();\n\n    for (int i = 1; i < words.size(); ++i) {\n      const string& first = words[i - 1];\n      const string& second = words[i];\n      const int length = min(first.length(), second.length());\n      for (int j = 0; j < length; ++j) {\n        const char u = first[j];\n        const char v = second[j];\n        if (u != v) {\n          if (!graph[u].count(v)) {\n            graph[u].insert(v);\n            ++inDegree[v - 'a'];\n          }\n          break;  // Later characters' order are meaningless\n        }\n        // First = \"ab\", second = \"a\" -> invalid\n        if (j == length - 1 && first.length() > second.length()) {\n          graph.clear();\n          return;\n        }\n      }\n    }\n  }\n\n  string topology(unordered_map<char, unordered_set<char>>& graph,\n                  vector<int>& inDegree) {\n    string s;\n    queue<char> q;\n\n    for (const auto& [c, _] : graph)\n      if (inDegree[c - 'a'] == 0)\n        q.push(c);\n\n    while (!q.empty()) {\n      const char u = q.front();\n      q.pop();\n      s += u;\n      for (const char v : graph[u])\n        if (--inDegree[v - 'a'] == 0)\n          q.push(v);\n    }\n\n    // Words = [\"z\", \"x\", \"y\", \"x\"]\n    return s.length() == graph.size() ? s : \"\";\n  }\n };\n"
    }
  ],
  [
    {
      "id": "270. Closest Binary Search Tree Value",
      "code": "class Solution {\n public:\n  int closestValue(TreeNode* root, double target) {\n    // If target < root->val, search left subtree\n    if (target < root->val && root->left) {\n      const int left = closestValue(root->left, target);\n      if (abs(left - target) < abs(root->val - target))\n        return left;\n    }\n\n    // If target > root->val, search right subtree\n    if (target > root->val && root->right) {\n      const int right = closestValue(root->right, target);\n      if (abs(right - target) < abs(root->val - target))\n        return right;\n    }\n\n    return root->val;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "271. Encode and Decode Strings",
      "code": "class Codec {\n public:\n  // Encodes a list of strings to a single string.\n  string encode(vector<string>& strs) {\n    string encoded;\n\n    for (const string& s : strs)\n      encoded += to_string(s.length()) + '/' + s;\n\n    return encoded;\n  }\n\n  // Decodes a single string to a list of strings.\n  vector<string> decode(string s) {\n    vector<string> decoded;\n\n    for (int i = 0; i < s.length();) {\n      const int slash = s.find('/', i);\n      const int length = stoi(s.substr(i, slash - i));\n      i = slash + length + 1;\n      decoded.push_back(s.substr(slash + 1, i - slash - 1));\n    }\n\n    return decoded;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "272. Closest Binary Search Tree Value II",
      "code": "class Solution {\n public:\n  vector<int> closestKValues(TreeNode* root, double target, int k) {\n    deque<int> q;\n\n    inorder(root, q);\n\n    while (q.size() > k)\n      if (abs(q.front() - target) > abs(q.back() - target))\n        q.pop_front();\n      else\n        q.pop_back();\n\n    return {begin(q), end(q)};\n  }\n\n private:\n  void inorder(TreeNode* root, deque<int>& q) {\n    if (root == nullptr)\n      return;\n\n    inorder(root->left, q);\n    q.push_back(root->val);\n    inorder(root->right, q);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "273. Integer to English Words",
      "code": "class Solution {\n public:\n  string numberToWords(int num) {\n    if (num == 0)\n      return \"Zero\";\n    return helper(num);\n  }\n\n private:\n  const vector<string> belowTwenty{\n      \"\",        \"One\",     \"Two\",       \"Three\",    \"Four\",\n      \"Five\",    \"Six\",     \"Seven\",     \"Eight\",    \"Nine\",\n      \"Ten\",     \"Eleven\",  \"Twelve\",    \"Thirteen\", \"Fourteen\",\n      \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\n  const vector<string> tens{\"\",      \"\",      \"Twenty\",  \"Thirty\", \"Forty\",\n                            \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\n\n  string helper(int num) {\n    string s;\n\n    if (num < 20)\n      s = belowTwenty.at(num);\n    else if (num < 100)\n      s = tens.at(num / 10) + \" \" + belowTwenty.at(num % 10);\n    else if (num < 1000)\n      s = helper(num / 100) + \" Hundred \" + helper(num % 100);\n    else if (num < 1000000)\n      s = helper(num / 1000) + \" Thousand \" + helper(num % 1000);\n    else if (num < 1000000000)\n      s = helper(num / 1000000) + \" Million \" + helper(num % 1000000);\n    else\n      s = helper(num / 1000000000) + \" Billion \" + helper(num % 1000000000);\n\n    trim(s);\n    return s;\n  }\n\n  void trim(string& s) {\n    s.erase(0, s.find_first_not_of(' '));\n    s.erase(s.find_last_not_of(' ') + 1);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "274. H-Index",
      "code": "class Solution {\n public:\n  int hIndex(vector<int>& citations) {\n    const int n = citations.size();\n    int accumulate = 0;\n    vector<int> count(n + 1);\n\n    for (const int citation : citations)\n      ++count[min(citation, n)];\n\n    // To find the largeset h-index, loop from back to front\n    // I is the candidate h-index\n    for (int i = n; i >= 0; --i) {\n      accumulate += count[i];\n      if (accumulate >= i)\n        return i;\n    }\n\n    throw;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "275. H-Index II",
      "code": "class Solution {\n public:\n  int hIndex(vector<int>& citations) {\n    int l = 0;\n    int r = citations.size();\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (citations[m] >= citations.size() - m)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return citations.size() - l;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "276. Paint Fence",
      "code": "class Solution {\n public:\n  int numWays(int n, int k) {\n    if (n == 0)\n      return 0;\n    if (n == 1)\n      return k;\n    if (n == 2)\n      return k * k;\n\n    // dp[i] := # of ways to paint n posts with k colors\n    vector<int> dp(n + 1);\n    dp[0] = 0;\n    dp[1] = k;\n    dp[2] = k * k;\n\n    for (int i = 3; i <= n; ++i)\n      dp[i] = (dp[i - 1] + dp[i - 2]) * (k - 1);\n\n    return dp[n];\n  }\n };\n"
    }
  ],
  [
    {
      "id": "277. Find the Celebrity",
      "code": "class Solution {\n public:\n  int findCelebrity(int n) {\n    int candidate = 0;\n\n    // Everyone knows the celebrity\n    for (int i = 1; i < n; ++i)\n      if (knows(candidate, i))\n        candidate = i;\n\n    // Candidate knows nobody and everyone knows the celebrity\n    for (int i = 0; i < n; ++i) {\n      if (i < candidate && knows(candidate, i) || !knows(i, candidate))\n        return -1;\n      if (i > candidate && !knows(i, candidate))\n        return -1;\n    }\n\n    return candidate;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "278. First Bad Version",
      "code": "bool isBadVersion(int version);\n\n class Solution {\n public:\n  int firstBadVersion(int n) {\n    int l = 1;\n    int r = n;\n\n    while (l < r) {\n      const int m = l + (r - l) / 2;\n      if (isBadVersion(m))\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return l;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "279. Perfect Squares",
      "code": "class Solution {\n public:\n  int numSquares(int n) {\n    vector<int> dp(n + 1, n);  // 1^2 x n\n\n    dp[0] = 0;  // No way\n    dp[1] = 1;  // 1^2\n\n    for (int i = 2; i <= n; ++i)\n      for (int j = 1; j * j <= i; ++j)\n        dp[i] = min(dp[i], dp[i - j * j] + 1);\n\n    return dp[n];\n  }\n };\n"
    }
  ],
  [
    {
      "id": "280. Wiggle Sort",
      "code": "class Solution {\n public:\n  void wiggleSort(vector<int>& nums) {\n    // 1. if i is even, then nums[i] <= nums[i - 1]\n    // 2. if i is odd, then nums[i] >= nums[i - 1]\n    for (int i = 1; i < nums.size(); ++i)\n      if ((!(i & 1) && nums[i] > nums[i - 1]) ||\n          ((i & 1) && nums[i] < nums[i - 1]))\n        swap(nums[i], nums[i - 1]);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "281. Zigzag Iterator",
      "code": "class ZigzagIterator {\n public:\n  ZigzagIterator(vector<int>& v1, vector<int>& v2) {\n    if (!v1.empty())\n      q.emplace(begin(v1), end(v1));\n    if (!v2.empty())\n      q.emplace(begin(v2), end(v2));\n  }\n\n  int next() {\n    const auto [it, endIt] = q.front();\n    q.pop();\n    if (it + 1 != endIt)\n      q.emplace(it + 1, endIt);\n    return *it;\n  }\n\n  bool hasNext() {\n    return !q.empty();\n  }\n\n private:\n  // {{ it, endIt }}\n  queue<pair<vector<int>::iterator, vector<int>::iterator>> q;\n};\n"
    }
  ],
  [
    {
      "id": "282. Expression Add Operators",
      "code": "class Solution {\n public:\n  vector<string> addOperators(string num, int target) {\n    vector<string> ans;\n    dfs(num, target, 0, 0, 0, {}, ans);\n    return ans;\n  }\n\n private:\n  string join(const vector<string>& path) {\n    string joined;\n    for (const string& s : path)\n      joined += s;\n    return joined;\n  }\n\n  // Start index, prev value, current evaluated value\n  void dfs(const string& num, int target, int start, long prev, long eval,\n           vector<string>&& path, vector<string>& ans) {\n    if (start == num.length()) {\n      if (eval == target)\n        ans.push_back(join(path));\n      return;\n    }\n\n    for (int i = start; i < num.length(); ++i) {\n      if (i > start && num[start] == '0')\n        return;\n      const string& s = num.substr(start, i - start + 1);\n      const long curr = stol(s);\n      if (start == 0) {\n        path.push_back(s);\n        dfs(num, target, i + 1, curr, curr, move(path), ans);\n        path.pop_back();\n      } else {\n        for (const string& op : {\"+\", \"-\", \"*\"}) {\n          path.push_back(op + s);\n          if (op == \"+\")\n            dfs(num, target, i + 1, curr, eval + curr, move(path), ans);\n          else if (op == \"-\")\n            dfs(num, target, i + 1, -curr, eval - curr, move(path), ans);\n          else\n            dfs(num, target, i + 1, prev * curr, eval - prev + prev * curr,\n                move(path), ans);\n          path.pop_back();\n        }\n      }\n    }\n  }\n };\n"
    }
  ],
  [
    {
      "id": "283. Move Zeroes",
      "code": "class Solution {\n public:\n  void moveZeroes(vector<int>& nums) {\n    int i = 0;\n    for (const int num : nums)\n      if (num != 0)\n        nums[i++] = num;\n\n    while (i < nums.size())\n      nums[i++] = 0;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "284. Peeking Iterator",
      "code": "class PeekingIterator : public Iterator {\n public:\n  PeekingIterator(const vector<int>& nums) : Iterator(nums) {}\n\n  // Returns the next element in the iteration without advancing the iterator.\n  int peek() {\n    // Iterator(*this) makes a copy of current iterator, then call next on the\n    // Copied iterator to get the next value without affecting current iterator\n    return Iterator(*this).next();\n  }\n\n  // hasNext() and next() should behave the same as in the Iterator interface.\n  // Override them if needed.\n  int next() {\n    return Iterator::next();\n  }\n\n  bool hasNext() const {\n    return Iterator::hasNext();\n  }\n };\n"
    }
  ],
  [
    {
      "id": "285. Inorder Successor in BST",
      "code": "class Solution {\n public:\n  TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {\n    if (root == nullptr)\n      return nullptr;\n    if (root->val <= p->val)\n      return inorderSuccessor(root->right, p);\n\n    TreeNode* left = inorderSuccessor(root->left, p);\n    return left ? left : root;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "286. Walls and Gates",
      "code": "class Solution {\n public:\n  void wallsAndGates(vector<vector<int>>& rooms) {\n    const int m = rooms.size();\n    const int n = rooms[0].size();\n    const vector<int> dirs{0, 1, 0, -1, 0};\n    queue<pair<int, int>> q;\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (rooms[i][j] == 0)\n          q.emplace(i, j);\n\n    while (!q.empty()) {\n      const auto [i, j] = q.front();\n      q.pop();\n      for (int k = 0; k < 4; ++k) {\n        const int x = i + dirs[k];\n        const int y = j + dirs[k + 1];\n        if (x < 0 || x == m || y < 0 || y == n)\n          continue;\n        if (rooms[x][y] != INT_MAX)\n          continue;\n        rooms[x][y] = rooms[i][j] + 1;\n        q.emplace(x, y);\n      }\n    }\n  }\n };\n"
    }
  ],
  [
    {
      "id": "287. Find the Duplicate Number",
      "code": "class Solution {\n public:\n  int findDuplicate(vector<int>& nums) {\n    int slow = nums[nums[0]];\n    int fast = nums[nums[nums[0]]];\n\n    while (slow != fast) {\n      slow = nums[slow];\n      fast = nums[nums[fast]];\n    }\n\n    slow = nums[0];\n\n    while (slow != fast) {\n      slow = nums[slow];\n      fast = nums[fast];\n    }\n\n    return slow;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "288. Unique Word Abbreviation",
      "code": "class ValidWordAbbr {\n public:\n  ValidWordAbbr(vector<string>& dictionary) {\n    dict = unordered_set(begin(dictionary), end(dictionary));\n\n    for (const string& word : dict) {\n      const string& abbr = getAbbr(word);\n      abbrUnique[abbr] = !abbrUnique.count(abbr);\n    }\n  }\n\n  bool isUnique(string word) {\n    const string& abbr = getAbbr(word);\n    return !abbrUnique.count(abbr) || abbrUnique[abbr] && dict.count(word);\n  }\n\n private:\n  unordered_set<string> dict;\n  unordered_map<string, bool> abbrUnique;  // T := unique, F := not unique\n\n  string getAbbr(const string& s) {\n    const int n = s.length();\n    if (n <= 2)\n      return s;\n    return s[0] + to_string(n - 2) + s.back();\n  }\n };\n"
    }
  ],
  [
    {
      "id": "289. Game of Life",
      "code": "class Solution {\n public:\n  void gameOfLife(vector<vector<int>>& board) {\n    const int m = board.size();\n    const int n = board[0].size();\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j) {\n        int ones = 0;\n        for (int x = max(0, i - 1); x < min(m, i + 2); ++x)\n          for (int y = max(0, j - 1); y < min(n, j + 2); ++y)\n            ones += board[x][y] & 1;\n        // Any live cell with 2 or 3 live neighbors\n        // lives on to the next generation\n        if (board[i][j] == 1 && (ones == 3 || ones == 4))\n          board[i][j] |= 0b10;\n        // Any dead cell with exactly 3 live neighbors\n        // becomes a live cell, as if by reproduction\n        if (board[i][j] == 0 && ones == 3)\n          board[i][j] |= 0b10;\n      }\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        board[i][j] >>= 1;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "290. Word Pattern",
      "code": "class Solution {\n public:\n  bool wordPattern(string pattern, string str) {\n    const int n = pattern.length();\n    istringstream iss(str);\n    vector<int> charToIndex(128);\n    unordered_map<string, int> stringToIndex;\n\n    int i = 0;\n    for (string word; iss >> word; ++i) {\n      if (i == n)  // Out of bound\n        return false;\n      if (charToIndex[pattern[i]] != stringToIndex[word])\n        return false;\n      charToIndex[pattern[i]] = i + 1;\n      stringToIndex[word] = i + 1;\n    }\n\n    return i == n;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "291. Word Pattern II",
      "code": "class Solution {\n public:\n  bool wordPatternMatch(string pattern, string s) {\n    return isMatch(pattern, 0, s, 0, unordered_map<char, string>(),\n                   unordered_set<string>());\n  }\n\n private:\n  bool isMatch(const string& pattern, int i, const string& s, int j,\n               unordered_map<char, string>&& charToString,\n               unordered_set<string>&& seen) {\n    if (i == pattern.length() && j == s.length())\n      return true;\n    if (i == pattern.length() || j == s.length())\n      return false;\n\n    const char c = pattern[i];\n\n    if (const auto it = charToString.find(c); it != cend(charToString)) {\n      const string& t = it->second;\n      // Check if we can match t w/ s[j:]\n      if (s.substr(j).find(t) == string::npos)\n        return false;\n\n      // If can match, so continue match the rest\n      return isMatch(pattern, i + 1, s, j + t.length(), move(charToString),\n                     move(seen));\n    }\n\n    for (int k = j; k < s.length(); ++k) {\n      const string& t = s.substr(j, k - j + 1);\n\n      // This string is already mapped by other character\n      if (seen.count(t))\n        continue;\n\n      charToString[c] = t;\n      seen.insert(t);\n\n      if (isMatch(pattern, i + 1, s, k + 1, move(charToString), move(seen)))\n        return true;\n\n      // Backtracking\n      charToString.erase(c);\n      seen.erase(t);\n    }\n\n    return false;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "292. Nim Game",
      "code": "class Solution {\n public:\n  bool canWinNim(int n) {\n    return n % 4 != 0;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "293. Flip Game",
      "code": "class Solution {\n public:\n  vector<string> generatePossibleNextMoves(string currentState) {\n    vector<string> ans;\n\n    for (int i = 0; i + 1 < currentState.length(); ++i)\n      if (currentState[i] == '+' && currentState[i + 1] == '+')\n        ans.push_back(currentState.substr(0, i) + \"--\" +\n                      currentState.substr(i + 2));\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "294. Flip Game II",
      "code": "class Solution {\n public:\n  bool canWin(string currentState) {\n    const auto it = memo.find(currentState);\n    if (it == cend(memo))\n      return it->second;\n\n    // If any of currentState[i:i + 2] == \"++\" and your friend can't win after\n    // Changing currentState[i:i + 2] to \"--\" (or \"-\"), then you can win\n    for (int i = 0; i + 1 < currentState.length(); ++i)\n      if (currentState[i] == '+' && currentState[i + 1] == '+' &&\n          !canWin(currentState.substr(0, i) + '-' + currentState.substr(i + 2)))\n        return memo[currentState] = true;\n\n    return memo[currentState] = false;\n  }\n\n private:\n  unordered_map<string, bool> memo;\n};\n"
    }
  ],
  [
    {
      "id": "295. Find Median from Data Stream",
      "code": "class MedianFinder {\n public:\n  void addNum(int num) {\n    if (maxHeap.empty() || num <= maxHeap.top())\n      maxHeap.push(num);\n    else\n      minHeap.push(num);\n\n    // Balance two heaps s.t.\n    // |maxHeap| >= |minHeap| and |maxHeap| - |minHeap| <= 1\n    if (maxHeap.size() < minHeap.size())\n      maxHeap.push(minHeap.top()), minHeap.pop();\n    else if (maxHeap.size() - minHeap.size() > 1)\n      minHeap.push(maxHeap.top()), maxHeap.pop();\n  }\n\n  double findMedian() {\n    if (maxHeap.size() == minHeap.size())\n      return (maxHeap.top() + minHeap.top()) / 2.0;\n    return maxHeap.top();\n  }\n\n private:\n  priority_queue<int> maxHeap;\n  priority_queue<int, vector<int>, greater<>> minHeap;\n};\n"
    }
  ],
  [
    {
      "id": "296. Best Meeting Point",
      "code": "class Solution {\n public:\n  int minTotalDistance(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    vector<int> I;  // I indices s.t. grid[i][j] == 1\n    vector<int> J;  // J indices s.t. grid[i][j] == 1\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (grid[i][j])\n          I.push_back(i);\n\n    for (int j = 0; j < n; ++j)\n      for (int i = 0; i < m; ++i)\n        if (grid[i][j])\n          J.push_back(j);\n\n    // Sum(i - median(I)) + sum(j - median(J))\n    return minTotalDistance(I) + minTotalDistance(J);\n  }\n\n private:\n  int minTotalDistance(const vector<int>& grid) {\n    int sum = 0;\n    int i = 0;\n    int j = grid.size() - 1;\n\n    while (i < j)\n      sum += grid[j--] - grid[i++];\n\n    return sum;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "297. Serialize and Deserialize Binary Tree",
      "code": "class Codec {\n public:\n  // Encodes a tree to a single string.\n  string serialize(TreeNode* root) {\n    if (root == nullptr)\n      return \"\";\n\n    string s;\n    queue<TreeNode*> q{{root}};\n\n    while (!q.empty()) {\n      TreeNode* node = q.front();\n      q.pop();\n      if (node != nullptr) {\n        s += to_string(node->val) + \" \";\n        q.push(node->left);\n        q.push(node->right);\n      } else {\n        s += \"n \";\n      }\n    }\n\n    return s;\n  }\n\n  // Decodes your encoded data to tree.\n  TreeNode* deserialize(string data) {\n    if (data.empty())\n      return nullptr;\n\n    istringstream iss(data);\n    string word;\n    iss >> word;\n    TreeNode* root = new TreeNode(stoi(word));\n    queue<TreeNode*> q{{root}};\n\n    while (iss >> word) {\n      TreeNode* node = q.front();\n      q.pop();\n      if (word != \"n\") {\n        node->left = new TreeNode(stoi(word));\n        q.push(node->left);\n      }\n      iss >> word;\n      if (word != \"n\") {\n        node->right = new TreeNode(stoi(word));\n        q.push(node->right);\n      }\n    }\n\n    return root;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "298. Binary Tree Longest Consecutive Sequence",
      "code": "class Solution {\n public:\n  int longestConsecutive(TreeNode* root) {\n    if (root == nullptr)\n      return 0;\n    return dfs(root, root->val, 0, 0);\n  }\n\n private:\n  int dfs(TreeNode* root, int target, int length, int maxLength) {\n    if (root == nullptr)\n      return maxLength;\n    if (root->val == target)\n      maxLength = max(maxLength, ++length);\n    else\n      length = 1;\n    return max(dfs(root->left, root->val + 1, length, maxLength),\n               dfs(root->right, root->val + 1, length, maxLength));\n  }\n };\n"
    }
  ],
  [
    {
      "id": "299. Bulls and Cows",
      "code": "class Solution {\n public:\n  string getHint(string secret, string guess) {\n    int A = 0;\n    int B = 0;\n    vector<int> count1(10);\n    vector<int> count2(10);\n\n    for (int i = 0; i < secret.length(); ++i)\n      if (secret[i] == guess[i])\n        ++A;\n      else {\n        ++count1[secret[i] - '0'];\n        ++count2[guess[i] - '0'];\n      }\n\n    for (int i = 0; i < 10; ++i)\n      B += min(count1[i], count2[i]);\n\n    return to_string(A) + \"A\" + to_string(B) + \"B\";\n  }\n };\n"
    }
  ],
  [
    {
      "id": "300. Longest Increasing Subsequence",
      "code": "class Solution {\n public:\n  int lengthOfLIS(vector<int>& nums) {\n    if (nums.empty())\n      return 0;\n\n    // dp[i] := Length of LIS ending at nums[i]\n    vector<int> dp(nums.size(), 1);\n\n    for (int i = 1; i < nums.size(); ++i)\n      for (int j = 0; j < i; ++j)\n        if (nums[j] < nums[i])\n          dp[i] = max(dp[i], dp[j] + 1);\n\n    return *max_element(begin(dp), end(dp));\n  }\n };\n"
    }
  ],
  [
    {
      "id": "301. Remove Invalid Parentheses",
      "code": "class Solution {\n public:\n  vector<string> removeInvalidParentheses(string s) {\n    vector<string> ans;\n    const auto [l, r] = getLeftAndRightCounts(s);\n    dfs(s, 0, l, r, ans);\n    return ans;\n  }\n\n private:\n  // Very simliar to 921. Minimum Add to Make Parentheses Valid\n  // Returns how many '(' and ')' need to be deleted\n  pair<int, int> getLeftAndRightCounts(const string& s) {\n    int l = 0;\n    int r = 0;\n\n    for (const char c : s)\n      if (c == '(')\n        ++l;\n      else if (c == ')') {\n        if (l == 0)\n          ++r;\n        else\n          --l;\n      }\n\n    return {l, r};\n  }\n\n  void dfs(const string& s, int start, int l, int r, vector<string>& ans) {\n    if (l == 0 && r == 0 && isValid(s)) {\n      ans.push_back(s);\n      return;\n    }\n\n    for (int i = start; i < s.length(); ++i) {\n      if (i > start && s[i] == s[i - 1])\n        continue;\n      if (l > 0 && s[i] == '(')  // Delete s[i]\n        dfs(s.substr(0, i) + s.substr(i + 1), i, l - 1, r, ans);\n      if (r > 0 && s[i] == ')')  // Delete s[i]\n        dfs(s.substr(0, i) + s.substr(i + 1), i, l, r - 1, ans);\n    }\n  }\n\n  bool isValid(const string& s) {\n    int count = 0;  // # of '(' - # of ')'\n\n    for (const char c : s) {\n      if (c == '(')\n        ++count;\n      else if (c == ')')\n        --count;\n      if (count < 0)\n        return false;\n    }\n\n    return true;  // Count == 0\n  }\n };\n"
    }
  ],
  [
    {
      "id": "302. Smallest Rectangle Enclosing Black Pixels",
      "code": "class Solution {\n public:\n  int minArea(vector<vector<char>>& image, int x, int y) {\n    const int m = image.size();\n    const int n = image[0].size();\n    const vector<int> dirs{0, 1, 0, -1, 0};\n    vector<int> topLeft{x, y};\n    vector<int> bottomRight{x, y};\n    queue<pair<int, int>> q{{{x, y}}};\n    image[x][y] = '2';  // Visited\n\n    while (!q.empty()) {\n      const auto [i, j] = q.front();\n      q.pop();\n      for (int k = 0; k < 4; ++k) {\n        const int r = i + dirs[k];\n        const int c = j + dirs[k + 1];\n        if (r < 0 || r == m || c < 0 || c == n)\n          continue;\n        if (image[r][c] != '1')\n          continue;\n        topLeft[0] = min(topLeft[0], r);\n        topLeft[1] = min(topLeft[1], c);\n        bottomRight[0] = max(bottomRight[0], r);\n        bottomRight[1] = max(bottomRight[1], c);\n        q.emplace(r, c);\n        image[r][c] = '2';\n      }\n    }\n\n    const int width = bottomRight[1] - topLeft[1] + 1;\n    const int height = bottomRight[0] - topLeft[0] + 1;\n    return width * height;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "303. Range Sum Query - Immutable",
      "code": "class NumArray {\n public:\n  NumArray(vector<int>& nums) : prefix(nums.size() + 1) {\n    partial_sum(begin(nums), end(nums), begin(prefix) + 1);\n  }\n\n  int sumRange(int left, int right) {\n    return prefix[right + 1] - prefix[left];\n  }\n\n private:\n  vector<int> prefix;\n};\n"
    }
  ],
  [
    {
      "id": "304. Range Sum Query 2D - Immutable",
      "code": "class NumMatrix {\n public:\n  NumMatrix(vector<vector<int>>& matrix) {\n    if (matrix.empty())\n      return;\n\n    const int m = matrix.size();\n    const int n = matrix[0].size();\n    // prefix[i][j] := sum of matrix[0..i)[0..j)\n    prefix.resize(m + 1, vector<int>(n + 1));\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        prefix[i + 1][j + 1] =\n            matrix[i][j] + prefix[i][j + 1] + prefix[i + 1][j] - prefix[i][j];\n  }\n\n  int sumRegion(int row1, int col1, int row2, int col2) {\n    return prefix[row2 + 1][col2 + 1] - prefix[row1][col2 + 1] -\n           prefix[row2 + 1][col1] + prefix[row1][col1];\n  }\n\n private:\n  vector<vector<int>> prefix;\n};\n"
    }
  ],
  [
    {
      "id": "305. Number of Islands II",
      "code": "class UnionFind {\n public:\n  vector<int> id;\n\n  UnionFind(int n) : id(n, -1), rank(n) {}\n\n  void unionByRank(int u, int v) {\n    const int i = find(u);\n    const int j = find(v);\n    if (i == j)\n      return;\n    if (rank[i] < rank[j]) {\n      id[i] = id[j];\n    } else if (rank[i] > rank[j]) {\n      id[j] = id[i];\n    } else {\n      id[i] = id[j];\n      ++rank[j];\n    }\n  }\n\n  int find(int u) {\n    return id[u] == u ? u : id[u] = find(id[u]);\n  }\n\n private:\n  vector<int> rank;\n};\n\n class Solution {\n public:\n  vector<int> numIslands2(int m, int n, vector<vector<int>>& positions) {\n    const vector<int> dirs{0, 1, 0, -1, 0};\n    vector<int> ans;\n    vector<vector<bool>> seen(m, vector<bool>(n));\n    UnionFind uf(m * n);\n    int count = 0;\n\n    for (const vector<int>& p : positions) {\n      const int i = p[0];\n      const int j = p[1];\n      if (seen[i][j]) {\n        ans.push_back(count);\n        continue;\n      }\n      seen[i][j] = true;\n      const int id = getId(i, j, n);\n      uf.id[id] = id;\n      ++count;\n      for (int k = 0; k < 4; ++k) {\n        const int x = i + dirs[k];\n        const int y = j + dirs[k + 1];\n        if (x < 0 || x == m || y < 0 || y == n)\n          continue;\n        const int neighborId = getId(x, y, n);\n        if (uf.id[neighborId] == -1)  // Water\n          continue;\n        const int currentRoot = uf.find(id);\n        const int neighborRoot = uf.find(neighborId);\n        if (currentRoot != neighborRoot) {\n          uf.unionByRank(currentRoot, neighborRoot);\n          --count;\n        }\n      }\n      ans.push_back(count);\n    }\n\n    return ans;\n  }\n\n private:\n  int getId(int i, int j, int n) {\n    return i * n + j;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "306. Additive Number",
      "code": "class Solution {\n public:\n  bool isAdditiveNumber(string num) {\n    const int n = num.length();\n\n    // num[0..i] = firstNum\n    for (int i = 0; i < n / 2; ++i) {\n      if (i > 0 && num[0] == '0')\n        return false;\n      const long firstNum = stol(num.substr(0, i + 1));\n      // num[i + 1..j] = secondNum\n      // Len(thirdNum) >= max(len(firstNum), len(secondNum))\n      for (int j = i + 1; max(i, j - i) < n - j; ++j) {\n        if (j > i + 1 && num[i + 1] == '0')\n          break;\n        const long secondNum = stol(num.substr(i + 1, j - i));\n        if (dfs(num, firstNum, secondNum, j + 1))\n          return true;\n      }\n    }\n\n    return false;\n  }\n\n private:\n  bool dfs(const string& num, long firstNum, long secondNum, long s) {\n    if (s == num.length())\n      return true;\n\n    const long thirdNum = firstNum + secondNum;\n    const string& thirdNumStr = to_string(thirdNum);\n    return num.find(thirdNumStr, s) == s &&\n           dfs(num, secondNum, thirdNum, s + thirdNumStr.length());\n  }\n };\n"
    }
  ],
  [
    {
      "id": "307. Range Sum Query - Mutable",
      "code": "class FenwickTree {\n public:\n  FenwickTree(int n) : sums(n + 1) {}\n\n  void update(int i, int delta) {\n    while (i < sums.size()) {\n      sums[i] += delta;\n      i += lowbit(i);\n    }\n  }\n\n  int get(int i) const {\n    int sum = 0;\n    while (i > 0) {\n      sum += sums[i];\n      i -= lowbit(i);\n    }\n    return sum;\n  }\n\n private:\n  vector<int> sums;\n\n  static inline int lowbit(int i) {\n    return i & -i;\n  }\n };\n\n class NumArray {\n public:\n  NumArray(vector<int>& nums) : nums(nums), tree(nums.size()) {\n    for (int i = 0; i < nums.size(); ++i)\n      tree.update(i + 1, nums[i]);\n  }\n\n  void update(int index, int val) {\n    tree.update(index + 1, val - nums[index]);\n    nums[index] = val;\n  }\n\n  int sumRange(int left, int right) {\n    return tree.get(right + 1) - tree.get(left);\n  }\n\n private:\n  vector<int> nums;\n  FenwickTree tree;\n};\n"
    }
  ],
  [
    {
      "id": "308. Range Sum Query 2D - Mutable",
      "code": "class FenwickTree {\n public:\n  FenwickTree(int m, int n) : sums(m + 1, vector<int>(n + 1)) {}\n\n  void update(int row, int col, int delta) {\n    for (int i = row; i < sums.size(); i += i & -i)\n      for (int j = col; j < sums[0].size(); j += j & -j)\n        sums[i][j] += delta;\n  }\n\n  int get(int row, int col) {\n    int sum = 0;\n    for (int i = row; i > 0; i -= i & -i)\n      for (int j = col; j > 0; j -= j & -j)\n        sum += sums[i][j];\n    return sum;\n  }\n\n private:\n  vector<vector<int>> sums;\n};\n\n class NumMatrix {\n public:\n  NumMatrix(vector<vector<int>>& matrix)\n      : matrix(matrix), tree(matrix.size(), matrix[0].size()) {\n    for (int i = 0; i < matrix.size(); ++i)\n      for (int j = 0; j < matrix[0].size(); ++j)\n        tree.update(i + 1, j + 1, matrix[i][j]);\n  }\n\n  void update(int row, int col, int val) {\n    tree.update(row + 1, col + 1, val - matrix[row][col]);\n    matrix[row][col] = val;\n  }\n\n  int sumRegion(int row1, int col1, int row2, int col2) {\n    return tree.get(row2 + 1, col2 + 1) - tree.get(row1, col2 + 1) -\n           tree.get(row2 + 1, col1) + tree.get(row1, col1);\n  }\n\n private:\n  vector<vector<int>> matrix;\n  FenwickTree tree;\n};\n"
    }
  ],
  [
    {
      "id": "309. Best Time to Buy and Sell Stock with Cooldown",
      "code": "class Solution {\n public:\n  int maxProfit(vector<int>& prices) {\n    int sell = 0;\n    int hold = INT_MIN;\n    int prev = 0;\n\n    for (const int price : prices) {\n      const int cache = sell;\n      sell = max(sell, hold + price);\n      hold = max(hold, prev - price);\n      prev = cache;\n    }\n\n    return sell;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "310. Minimum Height Trees",
      "code": "class Solution {\n public:\n  vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\n    if (n == 1 || edges.empty())\n      return {0};\n\n    vector<int> ans;\n    unordered_map<int, unordered_set<int>> graph;\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      graph[u].insert(v);\n      graph[v].insert(u);\n    }\n\n    for (const auto& [label, children] : graph)\n      if (children.size() == 1)\n        ans.push_back(label);\n\n    while (n > 2) {\n      n -= ans.size();\n      vector<int> nextLeaves;\n      for (const int leaf : ans) {\n        const int u = *begin(graph[leaf]);\n        graph[u].erase(leaf);\n        if (graph[u].size() == 1)\n          nextLeaves.push_back(u);\n      }\n      ans = nextLeaves;\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "311. Sparse Matrix Multiplication",
      "code": "class Solution {\n public:\n  vector<vector<int>> multiply(vector<vector<int>>& mat1,\n                               vector<vector<int>>& mat2) {\n    const int m = mat1.size();\n    const int n = mat2.size();\n    const int l = mat2[0].size();\n    vector<vector<int>> ans(m, vector<int>(l));\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < l; ++j)\n        for (int k = 0; k < n; ++k)\n          ans[i][j] += mat1[i][k] * mat2[k][j];\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "312. Burst Balloons",
      "code": "class Solution {\n public:\n  int maxCoins(vector<int>& nums) {\n    const int n = nums.size();\n\n    nums.insert(begin(nums), 1);\n    nums.insert(end(nums), 1);\n\n    // dp[i][j] := maxCoins(nums[i..j])\n    dp.resize(n + 2, vector<int>(n + 2));\n    return maxCoins(nums, 1, n);\n  }\n\n private:\n  vector<vector<int>> dp;\n\n  int maxCoins(vector<int>& nums, int i, int j) {\n    if (i > j)\n      return 0;\n    if (dp[i][j] > 0)\n      return dp[i][j];\n\n    for (int k = i; k <= j; ++k)\n      dp[i][j] =\n          max(dp[i][j], maxCoins(nums, i, k - 1) + maxCoins(nums, k + 1, j) +\n                            nums[i - 1] * nums[k] * nums[j + 1]);\n\n    return dp[i][j];\n  }\n };\n"
    }
  ],
  [
    {
      "id": "313. Super Ugly Number",
      "code": "class Solution {\n public:\n  int nthSuperUglyNumber(int n, vector<int>& primes) {\n    const int k = primes.size();\n    vector<int> indices(k);\n    vector<int> uglyNums{1};\n\n    while (uglyNums.size() < n) {\n      vector<int> nexts(k);\n      for (int i = 0; i < k; ++i)\n        nexts[i] = uglyNums[indices[i]] * primes[i];\n      const int next = *min_element(begin(nexts), end(nexts));\n      for (int i = 0; i < k; ++i)\n        if (next == nexts[i])\n          ++indices[i];\n      uglyNums.push_back(next);\n    }\n\n    return uglyNums.back();\n  }\n };\n"
    }
  ],
  [
    {
      "id": "314. Binary Tree Vertical Order Traversal",
      "code": "class Solution {\n public:\n  vector<vector<int>> verticalOrder(TreeNode* root) {\n    if (root == nullptr)\n      return {};\n\n    vector<int> range(2);\n    getRange(root, range, 0);  // Get the leftmost and rightmost x index\n\n    vector<vector<int>> ans(range[1] - range[0] + 1);\n    queue<pair<TreeNode*, int>> q{{{root, -range[0]}}};  // (TreeNode, x)\n\n    while (!q.empty()) {\n      const auto [node, x] = q.front();\n      q.pop();\n      ans[x].push_back(node->val);\n      if (node->left)\n        q.emplace(node->left, x - 1);\n      if (node->right)\n        q.emplace(node->right, x + 1);\n    }\n\n    return ans;\n  }\n\n private:\n  void getRange(TreeNode* root, vector<int>& range, int x) {\n    if (root == nullptr)\n      return;\n\n    range[0] = min(range[0], x);\n    range[1] = max(range[1], x);\n\n    getRange(root->left, range, x - 1);\n    getRange(root->right, range, x + 1);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "315. Count of Smaller Numbers After Self",
      "code": "class FenwickTree {\n public:\n  FenwickTree(int n) : sums(n + 1) {}\n\n  void update(int i, int delta) {\n    while (i < sums.size()) {\n      sums[i] += delta;\n      i += lowbit(i);\n    }\n  }\n\n  int get(int i) const {\n    int sum = 0;\n    while (i > 0) {\n      sum += sums[i];\n      i -= lowbit(i);\n    }\n    return sum;\n  }\n\n private:\n  vector<int> sums;\n\n  static inline int lowbit(int i) {\n    return i & -i;\n  }\n };\n\n class Solution {\n public:\n  vector<int> countSmaller(vector<int>& nums) {\n    vector<int> ans(nums.size());\n    unordered_map<int, int> ranks;\n    getRanks(nums, ranks);\n    FenwickTree tree(ranks.size());\n\n    for (int i = nums.size() - 1; i >= 0; --i) {\n      const int num = nums[i];\n      ans[i] = tree.get(ranks[num] - 1);\n      tree.update(ranks[num], 1);\n    }\n\n    return ans;\n  }\n\n private:\n  void getRanks(const vector<int>& nums, unordered_map<int, int>& ranks) {\n    set<int> sorted(begin(nums), end(nums));\n    int rank = 0;\n    for (const int num : sorted)\n      ranks[num] = ++rank;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "316. Remove Duplicate Letters",
      "code": "class Solution {\n public:\n  string removeDuplicateLetters(string s) {\n    string ans;\n    vector<int> count(128);\n    vector<bool> used(128);\n\n    for (const char c : s)\n      ++count[c];\n\n    for (const char c : s) {\n      --count[c];\n      if (used[c])\n        continue;\n      while (!ans.empty() && ans.back() > c && count[ans.back()] > 0) {\n        used[ans.back()] = false;\n        ans.pop_back();\n      }\n      used[c] = true;\n      ans.push_back(c);\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "317. Shortest Distance from All Buildings",
      "code": "class Solution {\n public:\n  int shortestDistance(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    const int nBuildings = getBuildingCount(grid);\n    const vector<int> dirs{0, 1, 0, -1, 0};\n    int ans = INT_MAX;\n    // dist[i][j] := total distance of grid[i][j] (0) to reach all buildings (1)\n    vector<vector<int>> dist(m, vector<int>(n));\n    // reachCount[i][j] := # of buildings (1) grid[i][j] (0) can reach\n    vector<vector<int>> reachCount(m, vector<int>(n));\n\n    auto bfs = [&](int row, int col) -> bool {\n      queue<pair<int, int>> q{{{row, col}}};\n      vector<vector<bool>> seen(m, vector<bool>(n));\n      seen[row][col] = true;\n      int depth = 0;\n      int seenBuildings = 1;\n\n      while (!q.empty()) {\n        ++depth;\n        for (int sz = q.size(); sz > 0; --sz) {\n          const auto [i, j] = q.front();\n          q.pop();\n          for (int k = 0; k < 4; ++k) {\n            const int x = i + dirs[k];\n            const int y = j + dirs[k + 1];\n            if (x < 0 || x == m || y < 0 || y == n)\n              continue;\n            if (seen[x][y])\n              continue;\n            seen[x][y] = true;\n            if (!grid[x][y]) {\n              dist[x][y] += depth;\n              ++reachCount[x][y];\n              q.emplace(x, y);\n            } else if (grid[x][y] == 1) {\n              ++seenBuildings;\n            }\n          }\n        }\n      }\n\n      return seenBuildings == nBuildings;\n    };\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (grid[i][j] == 1)  // Bfs from this building\n          if (!bfs(i, j))\n            return -1;\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (reachCount[i][j] == nBuildings)\n          ans = min(ans, dist[i][j]);\n\n    return ans == INT_MAX ? -1 : ans;\n  }\n\n private:\n  int getBuildingCount(vector<vector<int>>& grid) {\n    return accumulate(begin(grid), end(grid), 0, [](int s, vector<int>& row) {\n      return s + count(begin(row), end(row), 1);\n    });\n  }\n };\n"
    }
  ],
  [
    {
      "id": "318. Maximum Product of Word Lengths",
      "code": "class Solution {\n public:\n  int maxProduct(vector<string>& words) {\n    size_t ans = 0;\n    vector<int> masks;\n\n    for (const string& word : words)\n      masks.push_back(getMask(word));\n\n    for (int i = 0; i < words.size(); ++i)\n      for (int j = 0; j < i; ++j)\n        if ((masks[i] & masks[j]) == 0)\n          ans = max(ans, words[i].length() * words[j].length());\n\n    return ans;\n  }\n\n private:\n  int getMask(const string& word) {\n    int mask = 0;\n    for (const char c : word)\n      mask |= 1 << c - 'a';\n    return mask;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "319. Bulb Switcher",
      "code": "class Solution {\n public:\n  int bulbSwitch(int n) {\n    // K-th bulb only be switched when k % i == 0.\n    // So we can reiterate the problem:\n    // To find # of number <= n that have odd factors.\n    // Obviously, only square numbers have odd factor(s).\n    // E.g. n = 10, only 1, 4, and 9 are square numbers that <= 10\n    return sqrt(n);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "320. Generalized Abbreviation",
      "code": "class Solution {\n public:\n  vector<string> generateAbbreviations(string word) {\n    vector<string> ans;\n    dfs(word, 0, 0, {}, ans);\n    return ans;\n  }\n\n private:\n  void dfs(const string& word, int i, int count, vector<string>&& path,\n           vector<string>& ans) {\n    if (i == word.length()) {\n      ans.push_back(join(path) + getCountString(count));\n      return;\n    }\n\n    // Abbreviate word[i]\n    dfs(word, i + 1, count + 1, move(path), ans);\n    // Keep word[i], so consume the count as a string\n    path.push_back(getCountString(count) + word[i]);\n    dfs(word, i + 1, 0, move(path), ans);  // Reset count to 0\n    path.pop_back();\n  }\n\n  string getCountString(int count) {\n    return count > 0 ? to_string(count) : \"\";\n  }\n\n  string join(const vector<string>& path) {\n    string joined;\n    for (const string& s : path)\n      joined += s;\n    return joined;\n  };\n};\n"
    }
  ],
  [
    {
      "id": "321. Create Maximum Number",
      "code": "class Solution {\n public:\n  vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\n    vector<int> ans;\n\n    for (int k1 = 0; k1 <= k; ++k1) {\n      const int k2 = k - k1;\n      if (k1 > nums1.size() || k2 > nums2.size())\n        continue;\n      ans = max(ans, maxNumber(maxNumber(nums1, k1), maxNumber(nums2, k2)));\n    }\n\n    return ans;\n  }\n\n private:\n  vector<int> maxNumber(const vector<int>& nums, int k) {\n    if (k == 0)\n      return {};\n\n    vector<int> ans;\n    int toPop = nums.size() - k;\n\n    for (const int num : nums) {\n      while (!ans.empty() && ans.back() < num && toPop-- > 0)\n        ans.pop_back();\n      ans.push_back(num);\n    }\n\n    return {begin(ans), begin(ans) + k};\n  }\n\n private:\n  vector<int> maxNumber(const vector<int>& nums1, const vector<int>& nums2) {\n    vector<int> ans;\n\n    auto s1 = cbegin(nums1);\n    auto s2 = cbegin(nums2);\n\n    while (s1 != cend(nums1) || s2 != cend(nums2))\n      if (lexicographical_compare(s1, cend(nums1), s2, cend(nums2)))\n        ans.push_back(*s2++);\n      else\n        ans.push_back(*s1++);\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "322. Coin Change",
      "code": "class Solution {\n public:\n  int coinChange(vector<int>& coins, int amount) {\n    // dp[i] := fewest # of coins to make up i\n    vector<int> dp(amount + 1, amount + 1);\n    dp[0] = 0;\n\n    for (const int coin : coins)\n      for (int i = coin; i <= amount; ++i)\n        dp[i] = min(dp[i], dp[i - coin] + 1);\n\n    return dp[amount] == amount + 1 ? -1 : dp[amount];\n  }\n };\n"
    }
  ],
  [
    {
      "id": "323. Number of Connected Components in an Undirected Graph",
      "code": "class Solution {\n public:\n  int countComponents(int n, vector<vector<int>>& edges) {\n    int ans = 0;\n    vector<vector<int>> graph(n);\n    unordered_set<int> seen;\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      graph[u].push_back(v);\n      graph[v].push_back(u);\n    }\n\n    for (int i = 0; i < n; ++i)\n      if (!seen.count(i)) {\n        bfs(graph, i, seen);\n        ++ans;\n      }\n\n    return ans;\n  }\n\n private:\n  void bfs(const vector<vector<int>>& graph, int node,\n           unordered_set<int>& seen) {\n    queue<int> q{{node}};\n    seen.insert(node);\n\n    while (!q.empty()) {\n      const int u = q.front();\n      q.pop();\n      for (const int v : graph[u])\n        if (!seen.count(v)) {\n          q.push(v);\n          seen.insert(v);\n        }\n    }\n  }\n };\n"
    }
  ],
 null,
  [
    {
      "id": "325. Maximum Size Subarray Sum Equals k",
      "code": "class Solution {\n public:\n  int maxSubArrayLen(vector<int>& nums, int k) {\n    int ans = 0;\n    int prefix = 0;\n    unordered_map<int, int> prefixToIndex{{0, -1}};\n\n    for (int i = 0; i < nums.size(); ++i) {\n      prefix += nums[i];\n      const int target = prefix - k;\n      if (const auto it = prefixToIndex.find(target); it != cend(prefixToIndex))\n        ans = max(ans, i - it->second);\n      if (!prefixToIndex.count(prefix))\n        prefixToIndex[prefix] = i;\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "326. Power of Three",
      "code": "class Solution {\n public:\n  bool isPowerOfThree(int n) {\n    return n > 0 && static_cast<int>(pow(3, 19)) % n == 0;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "327. Count of Range Sum",
      "code": "class Solution {\n public:\n  int countRangeSum(vector<int>& nums, int lower, int upper) {\n    const int n = nums.size();\n    int ans = 0;\n    vector<long> prefix(n + 1);\n\n    for (int i = 0; i < n; ++i)\n      prefix[i + 1] = prefix[i] + nums[i];\n\n    mergeSort(prefix, 0, n, lower, upper, ans);\n    return ans;\n  }\n\n private:\n  void mergeSort(vector<long>& prefix, int l, int r, int lower, int upper,\n                 int& ans) {\n    if (l >= r)\n      return;\n\n    const int m = (l + r) / 2;\n    mergeSort(prefix, l, m, lower, upper, ans);\n    mergeSort(prefix, m + 1, r, lower, upper, ans);\n    merge(prefix, l, m, r, lower, upper, ans);\n  }\n\n  void merge(vector<long>& prefix, int l, int m, int r, int lower, int upper,\n             int& ans) {\n    int lo = m + 1;  // 1st index s.t. prefix[lo] - prefix[i] >= lower\n    int hi = m + 1;  // 1st index s.t. prefix[hi] - prefix[i] > upper\n\n    // For each index i in range [l, m], add hi - lo to ans\n    for (int i = l; i <= m; ++i) {\n      while (lo <= r && prefix[lo] - prefix[i] < lower)\n        ++lo;\n      while (hi <= r && prefix[hi] - prefix[i] <= upper)\n        ++hi;\n      ans += hi - lo;\n    }\n\n    vector<long> sorted(r - l + 1);\n    int k = 0;      // sorted's index\n    int i = l;      // left's index\n    int j = m + 1;  // right's index\n\n    while (i <= m && j <= r)\n      if (prefix[i] < prefix[j])\n        sorted[k++] = prefix[i++];\n      else\n        sorted[k++] = prefix[j++];\n\n    // Put possible remaining left part to the sorted array\n    while (i <= m)\n      sorted[k++] = prefix[i++];\n\n    // Put possible remaining right part to the sorted array\n    while (j <= r)\n      sorted[k++] = prefix[j++];\n\n    copy(begin(sorted), end(sorted), begin(prefix) + l);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "328. Odd Even Linked List",
      "code": "class Solution {\n public:\n  ListNode* oddEvenList(ListNode* head) {\n    ListNode oddHead(0);\n    ListNode evenHead(0);\n    ListNode* odd = &oddHead;\n    ListNode* even = &evenHead;\n\n    for (int isOdd = 0; head; head = head->next)\n      if (isOdd ^= 1) {\n        odd->next = head;\n        odd = odd->next;\n      } else {\n        even->next = head;\n        even = even->next;\n      }\n\n    odd->next = evenHead.next;\n    even->next = nullptr;\n    return oddHead.next;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "329. Longest Increasing Path in a Matrix",
      "code": "class Solution {\n public:\n  int longestIncreasingPath(vector<vector<int>>& matrix) {\n    const int m = matrix.size();\n    const int n = matrix[0].size();\n    int ans = 0;\n    vector<vector<int>> memo(m, vector<int>(n));\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        ans = max(ans, dfs(matrix, i, j, INT_MIN, memo));\n\n    return ans;\n  }\n\n private:\n  // memo[i][j] := the LIP starting from matrix[i][j]\n  int dfs(const vector<vector<int>>& matrix, int i, int j, int prev,\n          vector<vector<int>>& memo) {\n    if (i < 0 || i == matrix.size() || j < 0 || j == matrix[0].size())\n      return 0;\n    if (matrix[i][j] <= prev)\n      return 0;\n    int& ans = memo[i][j];\n    if (ans > 0)\n      return ans;\n\n    const int curr = matrix[i][j];\n    return ans = 1 + max({dfs(matrix, i + 1, j, curr, memo),\n                          dfs(matrix, i - 1, j, curr, memo),\n                          dfs(matrix, i, j + 1, curr, memo),\n                          dfs(matrix, i, j - 1, curr, memo)});\n  }\n };\n"
    }
  ],
  [
    {
      "id": "330. Patching Array",
      "code": "class Solution {\n public:\n  int minPatches(vector<int>& nums, int n) {\n    int ans = 0;\n    int i = 0;      // Point to nums\n    long miss = 1;  // Min sum in [1, n] we might miss\n\n    while (miss <= n)\n      if (i < nums.size() && nums[i] <= miss) {\n        miss += nums[i++];\n      } else {\n        // Greedily add miss itself to increase the range\n        // From [1, miss) to [1, 2 * miss)\n        miss += miss;\n        ++ans;\n      }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "331. Verify Preorder Serialization of a Binary Tree",
      "code": "class Solution {\n public:\n  bool isValidSerialization(string preorder) {\n    int degree = 1;  // OutDegree (children) - inDegree (parent)\n    istringstream iss(preorder);\n\n    for (string node; getline(iss, node, ',');) {\n      if (--degree < 0)\n        return false;\n      if (node != \"#\")\n        degree += 2;\n    }\n\n    return degree == 0;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "332. Reconstruct Itinerary",
      "code": "class Solution {\n public:\n  vector<string> findItinerary(vector<vector<string>>& tickets) {\n    vector<string> ans;\n    unordered_map<string, multiset<string>> graph;\n\n    for (const vector<string>& ticket : tickets)\n      graph[ticket[0]].insert(ticket[1]);\n\n    dfs(graph, \"JFK\", ans);\n    reverse(begin(ans), end(ans));\n    return ans;\n  }\n\n private:\n  void dfs(unordered_map<string, multiset<string>>& graph, const string& u,\n           vector<string>& ans) {\n    while (graph.count(u) && !graph[u].empty()) {\n      const string v = *begin(graph[u]);\n      graph[u].erase(begin(graph[u]));\n      dfs(graph, v, ans);\n    }\n    ans.push_back(u);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "333. Largest BST Subtree",
      "code": "struct T {\n  int min;   // Min value in the subtree\n  int max;   // Max value in the subtree\n  int size;  // Total size of the subtree\n};\n\n class Solution {\n public:\n  int largestBSTSubtree(TreeNode* root) {\n    return dfs(root).size;\n  }\n\n private:\n  T dfs(TreeNode* root) {\n    if (root == nullptr)\n      return {INT_MAX, INT_MIN, 0};\n\n    T l = dfs(root->left);\n    T r = dfs(root->right);\n\n    if (l.max < root->val && root->val < r.min)\n      return {min(l.min, root->val), max(r.max, root->val),\n              1 + l.size + r.size};\n\n    // Mark as invalid one, but still record the size of children\n    // Returns (-INF, INF) because any node won't > INT and < -INF\n    return {INT_MIN, INT_MAX, max(l.size, r.size)};\n  }\n };\n"
    }
  ],
  [
    {
      "id": "334. Increasing Triplet Subsequence",
      "code": "class Solution {\n public:\n  bool increasingTriplet(vector<int>& nums) {\n    int first = INT_MAX;\n    int second = INT_MAX;\n\n    for (const int num : nums)\n      if (num <= first)\n        first = num;\n      else if (num <= second)  // First < num <= second\n        second = num;\n      else\n        return true;  // First < second < num (third)\n\n    return false;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "335. Self Crossing",
      "code": "class Solution {\n public:\n  bool isSelfCrossing(vector<int>& x) {\n    if (x.size() <= 3)\n      return false;\n\n    for (int i = 3; i < x.size(); ++i) {\n      if (x[i - 2] <= x[i] && x[i - 1] <= x[i - 3])\n        return true;\n      if (i >= 4 && x[i - 1] == x[i - 3] && x[i - 2] <= x[i] + x[i - 4])\n        return true;\n      if (i >= 5 && x[i - 4] <= x[i - 2] && x[i - 2] <= x[i] + x[i - 4] &&\n          x[i - 1] <= x[i - 3] && x[i - 3] <= x[i - 1] + x[i - 5])\n        return true;\n    }\n\n    return false;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "336. Palindrome Pairs",
      "code": "class Solution {\n public:\n  vector<vector<int>> palindromePairs(vector<string>& words) {\n    vector<vector<int>> ans;\n    unordered_map<string, int> map;  // {reversed word: its index}\n\n    for (int i = 0; i < words.size(); ++i) {\n      string word = words[i];\n      reverse(begin(word), end(word));\n      map[word] = i;\n    }\n\n    for (int i = 0; i < words.size(); ++i) {\n      const string& word = words[i];\n      // Special case to prevent duplicate calculation\n      if (const auto it = map.find(\"\");\n          it != cend(map) && it->second != i && isPalindrome(word))\n        ans.push_back({i, it->second});\n      for (int j = 1; j <= word.length(); ++j) {\n        const string& l = word.substr(0, j);\n        const string& r = word.substr(j);\n        if (const auto it = map.find(l);\n            it != cend(map) && it->second != i && isPalindrome(r))\n          ans.push_back({i, it->second});\n        if (const auto it = map.find(r);\n            it != cend(map) && it->second != i && isPalindrome(l))\n          ans.push_back({it->second, i});\n      }\n    }\n\n    return ans;\n  }\n\n private:\n  bool isPalindrome(const string& word) {\n    int l = 0;\n    int r = word.length() - 1;\n    while (l < r)\n      if (word[l++] != word[r--])\n        return false;\n    return true;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "337. House Robber III",
      "code": "struct T {\n  int robRoot;\n  int notRobRoot;\n};\n\n class Solution {\n public:\n  int rob(TreeNode* root) {\n    const auto& [robRoot, notRobRoot] = robOrNotRob(root);\n    return max(robRoot, notRobRoot);\n  }\n\n private:\n  T robOrNotRob(TreeNode* root) {\n    if (root == nullptr)\n      return {0, 0};\n    const T l = robOrNotRob(root->left);\n    const T r = robOrNotRob(root->right);\n    return {root->val + l.notRobRoot + r.notRobRoot,\n            max(l.robRoot, l.notRobRoot) + max(r.robRoot, r.notRobRoot)};\n  }\n };\n"
    }
  ],
  [
    {
      "id": "338. Counting Bits",
      "code": "class Solution {\n public:\n  vector<int> countBits(int n) {\n    // Let f(i) := i's # of 1's in bitmask\n    // f(i) = f(i / 2) + i % 2\n    vector<int> ans(n + 1);\n\n    for (int i = 1; i <= n; ++i)\n      ans[i] = ans[i / 2] + (i & 1);\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "339. Nested List Weight Sum",
      "code": "class Solution {\n public:\n  int depthSum(vector<NestedInteger>& nestedList) {\n    int ans = 0;\n    int depth = 0;\n    queue<NestedInteger> q;\n\n    addIntegers(q, nestedList);\n\n    while (!q.empty()) {\n      ++depth;\n      for (int sz = q.size(); sz > 0; --sz) {\n        const NestedInteger ni = q.front();\n        q.pop();\n        if (ni.isInteger())\n          ans += ni.getInteger() * depth;\n        else\n          addIntegers(q, ni.getList());\n      }\n    }\n\n    return ans;\n  }\n\n private:\n  void addIntegers(queue<NestedInteger>& q,\n                   const vector<NestedInteger>& nestedList) {\n    for (const NestedInteger& ni : nestedList)\n      q.push(ni);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "340. Longest Substring with At Most K Distinct Characters",
      "code": "class Solution {\n public:\n  int lengthOfLongestSubstringKDistinct(string s, int k) {\n    int ans = 0;\n    int distinct = 0;\n    vector<int> count(128);\n\n    for (int l = 0, r = 0; r < s.length(); ++r) {\n      if (++count[s[r]] == 1)\n        ++distinct;\n      while (distinct == k + 1)\n        if (--count[s[l++]] == 0)\n          --distinct;\n      ans = max(ans, r - l + 1);\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "341. Flatten Nested List Iterator",
      "code": "class NestedIterator {\n public:\n  NestedIterator(vector<NestedInteger>& nestedList) {\n    addInteger(nestedList);\n  }\n\n  int next() {\n    const int num = q.front();\n    q.pop();\n    return num;\n  }\n\n  bool hasNext() {\n    return !q.empty();\n  }\n\n private:\n  queue<int> q;\n\n  void addInteger(const vector<NestedInteger>& nestedList) {\n    for (const NestedInteger& ni : nestedList)\n      if (ni.isInteger())\n        q.push(ni.getInteger());\n      else\n        addInteger(ni.getList());\n  }\n };\n"
    }
  ],
  [
    {
      "id": "342. Power of Four",
      "code": "class Solution {\n public:\n  bool isPowerOfFour(int n) {\n    // Why (4^n - 1) % 3 == 0?\n    // (4^n - 1) = (2^n - 1)(2^n + 1) and 2^n - 1, 2^n, 2^n + 1 are\n    // Three consecutive numbers; among one of them, there must be a multiple\n    // Of 3, and that can't be 2^n, so it must be either 2^n - 1 or 2^n + 1.\n    // Therefore, 4^n - 1 is a multiple of 3.\n    return n > 0 && __builtin_popcountll(n) == 1 && (n - 1) % 3 == 0;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "343. Integer Break",
      "code": "class Solution {\n public:\n  int integerBreak(int n) {\n    // If an optimal product contains a factor f >= 4, then we can replace it\n    // With 2 and f - 2 without losing optimality. As 2(f - 2) = 2f - 4 >= f,\n    // We never need a factor >= 4, meaning we only need factors 1, 2, and 3\n    // (and 1 is wasteful).\n    // Also, 3 * 3 is better than 2 * 2 * 2, so we never use 2 more than twice.\n    if (n == 2)  // 1 * 1\n      return 1;\n    if (n == 3)  // 1 * 2\n      return 2;\n\n    int ans = 1;\n\n    while (n > 4) {\n      n -= 3;\n      ans *= 3;\n    }\n    ans *= n;\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "344. Reverse String",
      "code": "class Solution {\n public:\n  void reverseString(vector<char>& s) {\n    int l = 0;\n    int r = s.size() - 1;\n\n    while (l < r)\n      swap(s[l++], s[r--]);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "345. Reverse Vowels of a String",
      "code": "class Solution {\n public:\n  string reverseVowels(string s) {\n    const unordered_set<char> vowels{'a', 'e', 'i', 'o', 'u',\n                                     'A', 'E', 'I', 'O', 'U'};\n    int l = 0;\n    int r = s.length() - 1;\n\n    while (l < r) {\n      while (l < r && !vowels.count(s[l]))\n        ++l;\n      while (l < r && !vowels.count(s[r]))\n        --r;\n      swap(s[l++], s[r--]);\n    }\n\n    return s;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "346. Moving Average from Data Stream",
      "code": "class MovingAverage {\n public:\n  MovingAverage(int size) : size(size) {}\n\n  double next(int val) {\n    if (q.size() == size)\n      sum -= q.front(), q.pop();\n    sum += val;\n    q.push(val);\n    return sum / q.size();\n  }\n\n private:\n  int size;\n  double sum = 0;\n  queue<int> q;\n};\n"
    }
  ],
  [
    {
      "id": "347. Top K Frequent Elements",
      "code": "struct T {\n  int num;\n  int freq;\n  T(int num, int freq) : num(num), freq(freq) {}\n };\n\n class Solution {\n public:\n  vector<int> topKFrequent(vector<int>& nums, int k) {\n    const int n = nums.size();\n    vector<int> ans;\n    unordered_map<int, int> count;\n    auto compare = [](const T& a, const T& b) { return a.freq > b.freq; };\n    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);\n\n    for (const int num : nums)\n      ++count[num];\n\n    for (const auto& [num, freq] : count) {\n      minHeap.emplace(num, freq);\n      if (minHeap.size() > k)\n        minHeap.pop();\n    }\n\n    while (!minHeap.empty())\n      ans.push_back(minHeap.top().num), minHeap.pop();\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "348. Design Tic-Tac-Toe",
      "code": "class TicTacToe {\n public:\n  TicTacToe(int n) : n(n), rows(n), cols(n) {}\n\n  /**\n   * Player {player} makes a move at ({row}, {col}).\n   *\n   * @param row    The row of the board.\n   * @param col    The column of the board.\n   * @param player The player, can be either 1 or 2.\n   * @return The current winning condition, can be either:\n   *         0: No one wins.\n   *         1: Player 1 wins.\n   *         2: Player 2 wins.\n   */\n  int move(int row, int col, int player) {\n    const int toAdd = player == 1 ? 1 : -1;\n    const int target = player == 1 ? n : -n;\n\n    if (row == col) {\n      diag += toAdd;\n      if (diag == target)\n        return player;\n    }\n\n    if (row + col == n - 1) {\n      antiDiag += toAdd;\n      if (antiDiag == target)\n        return player;\n    }\n\n    rows[row] += toAdd;\n    if (rows[row] == target)\n      return player;\n\n    cols[col] += toAdd;\n    if (cols[col] == target)\n      return player;\n\n    return 0;\n  }\n\n private:\n  const int n;\n  // Record count('X') - count('O')\n  vector<int> rows;\n  vector<int> cols;\n  int diag = 0;\n  int antiDiag = 0;\n};\n"
    }
  ],
  [
    {
      "id": "349. Intersection of Two Arrays",
      "code": "class Solution {\n public:\n  vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\n    vector<int> ans;\n    unordered_set<int> set{begin(nums1), end(nums1)};\n\n    for (const int num : nums2)\n      if (set.erase(num))\n        ans.push_back(num);\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "350. Intersection of Two Arrays II",
      "code": "class Solution {\n public:\n  vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\n    if (nums1.size() > nums2.size())\n      return intersect(nums2, nums1);\n\n    vector<int> ans;\n    unordered_map<int, int> count;\n\n    for (const int num : nums1)\n      ++count[num];\n\n    for (const int num : nums2)\n      if (const auto it = count.find(num);\n          it != cend(count) && it->second-- > 0)\n        ans.push_back(num);\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "351. Android Unlock Patterns",
      "code": "class Solution {\n public:\n  int numberOfPatterns(int m, int n) {\n    int ans = 0;\n    vector<vector<int>> across(10, vector<int>(10));\n    vector<bool> seen(10);\n\n    across[1][3] = across[3][1] = 2;\n    across[1][7] = across[7][1] = 4;\n    across[3][9] = across[9][3] = 6;\n    across[7][9] = across[9][7] = 8;\n    across[1][9] = across[9][1] = across[2][8] = across[8][2] = across[3][7] =\n        across[7][3] = across[4][6] = across[6][4] = 5;\n\n    ans += dfs(m, n, 1, 1, seen, across) * 4;  // 1, 3, 7, 9 are symmetric\n    ans += dfs(m, n, 2, 1, seen, across) * 4;  // 2, 4, 6, 8 are symmetric\n    ans += dfs(m, n, 5, 1, seen, across);      // 5\n    return ans;\n  }\n\n private:\n  int dfs(int m, int n, int u, int depth, vector<bool>& seen,\n          const vector<vector<int>>& across) {\n    if (depth > n)\n      return 0;\n\n    seen[u] = true;\n    int ans = depth >= m ? 1 : 0;\n\n    for (int v = 1; v <= 9; ++v) {\n      if (v == u || seen[v])\n        continue;\n      const int acrossed = across[u][v];\n      if (acrossed == 0 || seen[acrossed])\n        ans += dfs(m, n, v, depth + 1, seen, across);\n    }\n\n    seen[u] = false;\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "352. Data Stream as Disjoint Intervals",
      "code": "class SummaryRanges {\n public:\n  void addNum(int val) {\n    if (map.count(val))\n      return;\n\n    const int lo = lowerKey(val);\n    const int hi = higherKey(val);\n\n    // {lo, map[lo][1]} + val + {hi, map[hi][1]} = {lo, map[hi][1]}\n    if (lo >= 0 && hi >= 0 && map[lo][1] + 1 == val && val + 1 == hi) {\n      map[lo][1] = map[hi][1];\n      map.erase(hi);\n      // {lo, map[lo][1]} + val = {lo, val}\n      // (prevent adding duplicate entry by using '>=' instead of '==')\n    } else if (lo >= 0 && map[lo][1] + 1 >= val) {\n      map[lo][1] = max(map[lo][1], val);\n    } else if (hi >= 0 && val + 1 == hi) {\n      // Val + {hi, map[hi][1]} = {val, map[hi][1]}\n      map[val] = {val, map[hi][1]};\n      map.erase(hi);\n    } else {\n      map[val] = {val, val};\n    }\n  }\n\n  vector<vector<int>> getIntervals() {\n    vector<vector<int>> intervals;\n    for (const auto& [_, interval] : map)\n      intervals.push_back(interval);\n    return intervals;\n  }\n\n private:\n  map<int, vector<int>> map;  // {start: {start, end}}\n\n  // Maximum in map < key\n  int lowerKey(int key) {\n    auto it = map.lower_bound(key);  // Minimum in map >= key\n    if (it == begin(map))\n      return -1;\n    return (--it)->first;\n  }\n\n  // Minimum in map > key\n  int higherKey(int key) {\n    const auto it = map.upper_bound(key);  // Minimum in map > key\n    if (it == cend(map))\n      return -1;\n    return it->first;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "353. Design Snake Game",
      "code": "class SnakeGame {\n public:\n  /** Initialize your data structure here.\n     @param width - screen width\n     @param height - screen height\n     @param food - A list of food positions\n     E.g food = [[1,1], [1,0]] means the first food is positioned at [1,1], the\n     second is at [1,0]. */\n  SnakeGame(int width, int height, vector<vector<int>>& food)\n      : width(width), height(height), food(food) {\n    lookup.insert(getId(0, 0));\n    body.push_back(getId(0, 0));\n  }\n\n  /** Moves the snake.\n      @param direction - 'U' = Up, 'L' = Left, 'R' = Right, 'D' = Down\n      @return The game's score after the move. Return -1 if game over.\n      Game over when snake crosses the screen boundary or bites its body. */\n  int move(string direction) {\n    // Old head's position\n    int i = body.front() / width;\n    int j = body.front() % width;\n\n    // Update head's position and check if out of bound\n    if (direction == \"U\" && --i < 0)\n      return -1;\n    if (direction == \"L\" && --j < 0)\n      return -1;\n    if (direction == \"R\" && ++j == width)\n      return -1;\n    if (direction == \"D\" && ++i == height)\n      return -1;\n\n    const int newHead = getId(i, j);\n\n    // Case 1: eat food and increase size by 1\n    if (k < food.size() && i == food[k][0] && j == food[k][1]) {\n      lookup.insert(newHead);\n      body.push_front(newHead);\n      ++k;\n      return ++score;\n    }\n\n    // Case 2: new head != old tail and eat body!\n    if (newHead != body.back() && lookup.count(newHead))\n      return -1;\n\n    // Case 3: normal case\n    // Remove old tail first (important), then add new head\n    // Because new head may be in old tail's position\n    lookup.erase(body.back());\n    lookup.insert(newHead);\n    body.pop_back();\n    body.push_front(newHead);\n\n    return score;\n  }\n\n private:\n  int width;\n  int height;\n  int score = 0;\n  int k = 0;  // food's index\n  vector<vector<int>> food;\n  unordered_set<int> lookup;\n  deque<int> body;  // snake's body\n\n  int getId(int i, int j) {\n    return i * width + j;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "354. Russian Doll Envelopes",
      "code": "class Solution {\n public:\n  int maxEnvelopes(vector<vector<int>>& envelopes) {\n    sort(begin(envelopes), end(envelopes), [](const auto& a, const auto& b) {\n      return a[0] == b[0] ? a[1] > b[1] : a[0] < b[0];\n    });\n\n    // Same as 300. Longest Increasing Subsequence\n    int ans = 0;\n    vector<int> dp(envelopes.size());\n\n    for (const vector<int>& e : envelopes) {\n      int l = 0;\n      int r = ans;\n      while (l < r) {\n        const int m = (l + r) / 2;\n        if (dp[m] >= e[1])\n          r = m;\n        else\n          l = m + 1;\n      }\n      dp[l] = e[1];\n      if (l == ans)\n        ++ans;\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "355. Design Twitter",
      "code": "struct Tweet {\n  int id;\n  int time;\n  Tweet* next = nullptr;\n  Tweet(int id, int time) : id(id), time(time) {}\n };\n\nstruct User {\n  int id;\n  unordered_set<int> followeeIds;\n  Tweet* tweetHead = nullptr;\n\n  User() {}\n\n  User(int id) : id(id) {\n    follow(id);  // Follow himself\n  }\n\n  void follow(int followeeId) {\n    followeeIds.insert(followeeId);\n  }\n\n  void unfollow(int followeeId) {\n    followeeIds.erase(followeeId);\n  }\n\n  void post(int tweetId, int time) {\n    Tweet* oldTweetHead = tweetHead;\n    tweetHead = new Tweet(tweetId, time);\n    tweetHead->next = oldTweetHead;\n  }\n };\n\n class Twitter {\n public:\n  /** Compose a new tweet. */\n  void postTweet(int userId, int tweetId) {\n    if (!users.count(userId))\n      users[userId] = User(userId);\n    users[userId].post(tweetId, time++);\n  }\n\n  /**\n   * Retrieve the 10 most recent tweet ids in the user's news feed. Each item in\n   * the news feed must be posted by users who the user followed or by the user\n   * herself. Tweets must be ordered from most recent to least recent.\n   */\n  vector<int> getNewsFeed(int userId) {\n    if (!users.count(userId))\n      return {};\n\n    vector<int> newsFeed;\n\n    auto compare = [](const Tweet* a, const Tweet* b) {\n      return a->time < b->time;\n    };\n    priority_queue<Tweet*, vector<Tweet*>, decltype(compare)> maxHeap(compare);\n\n    for (const int followeeId : users[userId].followeeIds) {\n      Tweet* tweetHead = users[followeeId].tweetHead;\n      if (tweetHead != nullptr)\n        maxHeap.push(tweetHead);\n    }\n\n    int count = 0;\n    while (!maxHeap.empty() && count++ < 10) {\n      Tweet* tweet = maxHeap.top();\n      maxHeap.pop();\n      newsFeed.push_back(tweet->id);\n      if (tweet->next)\n        maxHeap.push(tweet->next);\n    }\n\n    return newsFeed;\n  }\n\n  /**\n   * Follower follows a followee.\n   * If the operation is invalid, it should be a no-op.\n   */\n  void follow(int followerId, int followeeId) {\n    if (followerId == followeeId)\n      return;\n    if (!users.count(followerId))\n      users[followerId] = User(followerId);\n    if (!users.count(followeeId))\n      users[followeeId] = User(followeeId);\n    users[followerId].follow(followeeId);\n  }\n\n  /**\n   * Follower unfollows a followee.\n   * If the operation is invalid, it should be a no-op.\n   */\n  void unfollow(int followerId, int followeeId) {\n    if (followerId == followeeId)\n      return;\n    if (const auto it = users.find(followerId);\n        it != cend(users) && users.count(followeeId))\n      it->second.unfollow(followeeId);\n  }\n\n private:\n  int time = 0;\n  unordered_map<int, User> users;  // {userId: User}\n };\n"
    }
  ],
  [
    {
      "id": "356. Line Reflection",
      "code": "class Solution {\n public:\n  bool isReflected(vector<vector<int>>& points) {\n    int minX = INT_MAX;\n    int maxX = INT_MIN;\n    unordered_set<pair<int, int>, pairHash> seen;\n\n    for (const vector<int>& p : points) {\n      const int x = p[0];\n      const int y = p[1];\n      minX = min(minX, x);\n      maxX = max(maxX, x);\n      seen.insert({x, y});\n    }\n\n    const int sum = minX + maxX;\n    // (leftX + rightX) / 2 = (minX + maxX) / 2\n    //  leftX = minX + maxX - rightX\n    // RightX = minX + maxX - leftX\n\n    for (const vector<int>& p : points)\n      if (!seen.count({sum - p[0], p[1]}))\n        return false;\n\n    return true;\n  }\n\n private:\n  struct pairHash {\n    size_t operator()(const pair<int, int>& p) const {\n      return p.first ^ p.second;\n    }\n  };\n};\n"
    }
  ],
  [
    {
      "id": "357. Count Numbers with Unique Digits",
      "code": "class Solution {\n public:\n  int countNumbersWithUniqueDigits(int n) {\n    if (n == 0)\n      return 1;\n\n    int ans = 10;\n    int uniqueDigits = 9;\n\n    for (int availableNum = 9; n > 1 && availableNum > 0; --n, --availableNum) {\n      uniqueDigits *= availableNum;\n      ans += uniqueDigits;\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "358. Rearrange String k Distance Apart",
      "code": "class Solution {\n public:\n  string rearrangeString(string s, int k) {\n    const int n = s.length();\n    string ans;\n    vector<int> count(128);\n    vector<int> valid(128);  // valid[i] := the leftmost index char i can appear\n\n    for (const char c : s)\n      ++count[c];\n\n    for (int i = 0; i < n; ++i) {\n      const char c = getBestLetter(count, valid, i);\n      if (c == '*')\n        return \"\";\n      ans += c;\n      --count[c];\n      valid[c] = i + k;\n    }\n\n    return ans;\n  }\n\n  // Returns the letter that has most count and also valid\n private:\n  char getBestLetter(const vector<int>& count, const vector<int>& valid,\n                     int index) {\n    int maxCount = -1;\n    char bestLetter = '*';\n\n    for (char c = 'a'; c <= 'z'; ++c)\n      if (count[c] > 0 && count[c] > maxCount && index >= valid[c]) {\n        bestLetter = c;\n        maxCount = count[c];\n      }\n\n    return bestLetter;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "359. Logger Rate Limiter",
      "code": "class Logger {\n public:\n  bool shouldPrintMessage(int timestamp, string message) {\n    // Remove messages that are 10 secs from the current timestamp\n    while (!messageQueue.empty()) {\n      const auto [headTimestamp, headMessage] = messageQueue.front();\n      if (timestamp < headTimestamp + 10)\n        break;\n      messageQueue.pop_front();\n      messageSet.erase(headMessage);\n    }\n\n    if (messageSet.count(message))\n      return false;\n\n    messageQueue.emplace_back(timestamp, message);\n    messageSet.insert(message);\n    return true;\n  }\n\n private:\n  // [(timestamp, message)]\n  deque<pair<int, string>> messageQueue;\n  unordered_set<string> messageSet;\n};\n"
    }
  ],
  [
    {
      "id": "360. Sort Transformed Array",
      "code": "class Solution {\n public:\n  vector<int> sortTransformedArray(vector<int>& nums, int a, int b, int c) {\n    const int n = nums.size();\n    const bool upward = a > 0;\n    vector<int> ans(n);\n    vector<int> quad;\n\n    for (const int num : nums)\n      quad.push_back(f(num, a, b, c));\n\n    int i = upward ? n - 1 : 0;\n    for (int l = 0, r = n - 1; l <= r;)\n      if (upward)  // Maximum in both ends\n        ans[i--] = quad[l] > quad[r] ? quad[l++] : quad[r--];\n      else  // Minimum in both ends\n        ans[i++] = quad[l] < quad[r] ? quad[l++] : quad[r--];\n\n    return ans;\n  }\n\n private:\n  // The concavity of f only depends on a's sign\n  int f(int x, int a, int b, int c) {\n    return (a * x + b) * x + c;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "361. Bomb Enemy",
      "code": "class Solution {\n public:\n  int maxKilledEnemies(vector<vector<char>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    int enemyCount = 0;\n    // dp[i][j] := max enemies grid[i][j] can kill\n    vector<vector<int>> dp(m, vector<int>(n));\n\n    auto update = [&](int i, int j) {\n      if (grid[i][j] == '0')\n        dp[i][j] += enemyCount;\n      else if (grid[i][j] == 'E')\n        ++enemyCount;\n      else  // grid[i][j] == 'W'\n        enemyCount = 0;\n    };\n\n    // Extend four directions, if meet 'W', need to start over from 0\n    for (int i = 0; i < m; ++i) {\n      enemyCount = 0;\n      for (int j = 0; j < n; ++j)\n        update(i, j);\n      enemyCount = 0;\n      for (int j = n - 1; j >= 0; --j)\n        update(i, j);\n    }\n\n    for (int j = 0; j < n; ++j) {\n      enemyCount = 0;\n      for (int i = 0; i < m; ++i)\n        update(i, j);\n      enemyCount = 0;\n      for (int i = m - 1; i >= 0; --i)\n        update(i, j);\n    }\n\n    return accumulate(begin(dp), end(dp), 0, [](int s, vector<int>& row) {\n      return max(s, *max_element(begin(row), end(row)));\n    });\n  }\n };\n"
    }
  ],
  [
    {
      "id": "362. Design Hit Counter",
      "code": "class HitCounter {\n public:\n  void hit(int timestamp) {\n    const int i = timestamp % 300;\n\n    if (timestamps[i] == timestamp) {\n      ++hits[i];\n    } else {\n      timestamps[i] = timestamp;\n      hits[i] = 1;  // Reset hit count to 1\n    }\n  }\n\n  int getHits(int timestamp) {\n    int countHits = 0;\n\n    for (int i = 0; i < 300; ++i)\n      if (timestamp - timestamps[i] < 300)\n        countHits += hits[i];\n\n    return countHits;\n  }\n\n private:\n  vector<int> timestamps = vector<int>(300);\n  vector<int> hits = vector<int>(300);\n};\n"
    }
  ],
  [
    {
      "id": "363. Max Sum of Rectangle No Larger Than K",
      "code": "class Solution {\n public:\n  int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\n    const int m = matrix.size();\n    const int n = matrix[0].size();\n    int ans = INT_MIN;\n\n    for (int baseCol = 0; baseCol < n; ++baseCol) {\n      // sums[i] := sum(matrix[i][baseCol..j])\n      vector<int> sums(m, 0);\n      for (int j = baseCol; j < n; ++j) {\n        for (int i = 0; i < m; ++i)\n          sums[i] += matrix[i][j];\n        // Find the max subarray no more than k\n        set<int> accumulate{0};\n        int prefix = 0;\n        for (const int sum : sums) {\n          prefix += sum;\n          if (const auto it = accumulate.lower_bound(prefix - k);\n              it != cend(accumulate))\n            ans = max(ans, prefix - *it);\n          accumulate.insert(prefix);\n        }\n      }\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "364. Nested List Weight Sum II",
      "code": "class Solution {\n public:\n  int depthSumInverse(vector<NestedInteger>& nestedList) {\n    int ans = 0;\n    int prevSum = 0;\n    queue<NestedInteger> q{{begin(nestedList), end(nestedList)}};\n\n    while (!q.empty()) {\n      for (int sz = q.size(); sz > 0; --sz) {\n        const NestedInteger ni = q.front();\n        q.pop();\n        if (ni.isInteger())\n          prevSum += ni.getInteger();\n        else {\n          for (const NestedInteger nextNi : ni.getList())\n            q.push(nextNi);\n        }\n      }\n      ans += prevSum;\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "365. Water and Jug Problem",
      "code": "class Solution {\n public:\n  bool canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity) {\n    return targetCapacity == 0 ||\n           jug1Capacity + jug2Capacity >= targetCapacity &&\n               targetCapacity % __gcd(jug1Capacity, jug2Capacity) == 0;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "366. Find Leaves of Binary Tree",
      "code": "class Solution {\n public:\n  vector<vector<int>> findLeaves(TreeNode* root) {\n    vector<vector<int>> ans;\n\n    depth(root, ans);\n    return ans;\n  }\n\n private:\n  // Depth of root (0-indexed)\n  int depth(TreeNode* root, vector<vector<int>>& ans) {\n    if (root == nullptr)\n      return -1;\n\n    const int l = depth(root->left, ans);\n    const int r = depth(root->right, ans);\n    const int h = 1 + max(l, r);\n    if (ans.size() == h)  // Meet leaf\n      ans.push_back({});\n\n    ans[h].push_back(root->val);\n    return h;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "367. Valid Perfect Square",
      "code": "class Solution {\n public:\n  bool isPerfectSquare(int num) {\n    long l = 1;\n    long r = num;\n\n    while (l < r) {\n      const long m = (l + r) / 2;\n      if (m >= num / m)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return l * l == num;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "368. Largest Divisible Subset",
      "code": "class Solution {\n public:\n  vector<int> largestDivisibleSubset(vector<int>& nums) {\n    const int n = nums.size();\n    vector<int> ans;\n    // sizeEndsAt[i] := largest size ends at nums[i]\n    vector<int> sizeEndsAt(n, 1);\n    // prevIndex[i] := the best index s.t.\n    // 1. nums[i] % nums[prevIndex[i]] == 0 and\n    // 2. can increase the size of the subset\n    vector<int> prevIndex(n, -1);\n    int maxSize = 0;  // Max size of the subset\n    int index = -1;   // Track the best ending index\n\n    sort(begin(nums), end(nums));\n\n    // Fix max ending num in the subset first\n    for (int i = 0; i < n; ++i) {\n      for (int j = i - 1; j >= 0; --j)\n        if (nums[i] % nums[j] == 0 && sizeEndsAt[i] < sizeEndsAt[j] + 1) {\n          sizeEndsAt[i] = sizeEndsAt[j] + 1;\n          prevIndex[i] = j;\n        }\n      // Find a new subset that has a bigger size\n      if (maxSize < sizeEndsAt[i]) {\n        maxSize = sizeEndsAt[i];\n        index = i;  // Update the best ending index\n      }\n    }\n\n    // Loop from back to front\n    while (index != -1) {\n      ans.push_back(nums[index]);\n      index = prevIndex[index];\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "369. Plus One Linked List",
      "code": "class Solution {\n public:\n  ListNode* plusOne(ListNode* head) {\n    if (head == nullptr)\n      return new ListNode(1);\n    if (addOne(head) == 1)\n      return new ListNode(1, head);\n    return head;\n  }\n\n private:\n  int addOne(ListNode* node) {\n    const int carry = node->next ? addOne(node->next) : 1;\n    const int sum = node->val + carry;\n    node->val = sum % 10;\n    return sum / 10;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "370. Range Addition",
      "code": "class Solution {\n public:\n  vector<int> getModifiedArray(int length, vector<vector<int>>& updates) {\n    vector<int> ans(length);\n    int prefix = 0;\n\n    for (const vector<int>& update : updates) {\n      const int startIndex = update[0];\n      const int endIndex = update[1];\n      const int inc = update[2];\n      ans[startIndex] += inc;\n      if (endIndex + 1 < length)\n        ans[endIndex + 1] -= inc;\n    }\n\n    for (int i = 0; i < length; ++i) {\n      prefix += ans[i];\n      ans[i] = prefix;\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "371. Sum of Two Integers",
      "code": "class Solution {\n public:\n  int getSum(unsigned a, unsigned b) {\n    while (b) {                      // Still have carry bits\n      const unsigned carry = a & b;  // Record carry bits\n      a ^= b;                        // ^ works like + w/o handling carry bits\n      b = carry << 1;\n    }\n    return a;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "372. Super Pow",
      "code": "class Solution {\n public:\n  int superPow(int a, vector<int>& b) {\n    constexpr int k = 1337;\n    int ans = 1;\n\n    auto powMod = [&](int x, int y) {  // X^y % k\n      int pow = 1;\n      while (y--)\n        pow = (pow * x) % k;\n      return pow;\n    };\n\n    a %= k;\n    for (const int i : b)\n      ans = powMod(ans, 10) * powMod(a, i) % k;\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "373. Find K Pairs with Smallest Sums",
      "code": "struct T {\n  int i;\n  int j;\n  int sum;  // nums1[i] + nums2[j];\n  T(int i, int j, int sum) : i(i), j(j), sum(sum) {}\n };\n\n class Solution {\n public:\n  vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2,\n                                     int k) {\n    vector<vector<int>> ans;\n    auto compare = [&](const T& a, const T& b) { return a.sum > b.sum; };\n    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);\n\n    for (int i = 0; i < k && i < nums1.size(); ++i)\n      minHeap.emplace(i, 0, nums1[i] + nums2[0]);\n\n    while (!minHeap.empty() && ans.size() < k) {\n      const auto [i, j, _] = minHeap.top();\n      minHeap.pop();\n      ans.push_back({nums1[i], nums2[j]});\n      if (j + 1 < nums2.size())\n        minHeap.emplace(i, j + 1, nums1[i] + nums2[j + 1]);\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  null,
  [
    {
      "id": "375. Guess Number Higher or Lower II",
      "code": "class Solution {\n public:\n  int getMoneyAmount(int n) {\n    // dp[i][j] := min money you need to guarantee a win of picking i..j\n    dp.resize(n + 1, vector<int>(n + 1, INT_MAX));\n    return getMoneyAmount(1, n);\n  }\n\n private:\n  vector<vector<int>> dp;\n\n  int getMoneyAmount(int i, int j) {\n    if (i >= j)\n      return 0;\n    if (dp[i][j] != INT_MAX)\n      return dp[i][j];\n\n    for (int k = i; k <= j; ++k)\n      dp[i][j] =\n          min(dp[i][j],\n              max(getMoneyAmount(i, k - 1), getMoneyAmount(k + 1, j)) + k);\n\n    return dp[i][j];\n  }\n };\n"
    }
  ],
  [
    {
      "id": "376. Wiggle Subsequence",
      "code": "class Solution {\n public:\n  int wiggleMaxLength(vector<int>& nums) {\n    int increasing = 1;\n    int decreasing = 1;\n\n    for (int i = 1; i < nums.size(); ++i)\n      if (nums[i] > nums[i - 1])\n        increasing = decreasing + 1;\n      else if (nums[i] < nums[i - 1])\n        decreasing = increasing + 1;\n\n    return max(increasing, decreasing);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "377. Combination Sum IV",
      "code": "class Solution {\n public:\n  int combinationSum4(vector<int>& nums, int target) {\n    vector<unsigned long long> dp(target + 1);\n    dp[0] = 1;\n\n    for (int i = 1; i <= target; ++i)\n      for (const int num : nums)\n        if (i >= num)\n          dp[i] += dp[i - num];\n\n    return dp[target];\n  }\n };\n"
    }
  ],
  [
    {
      "id": "378. Kth Smallest Element in a Sorted Matrix",
      "code": "struct T {\n  int i;\n  int j;\n  int num;  // matrix[i][j]\n  T(int i, int j, int num) : i(i), j(j), num(num) {}\n };\n\n class Solution {\n public:\n  int kthSmallest(vector<vector<int>>& matrix, int k) {\n    auto compare = [&](const T& a, const T& b) { return a.num > b.num; };\n    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);\n\n    for (int i = 0; i < k && i < matrix.size(); ++i)\n      minHeap.emplace(i, 0, matrix[i][0]);\n\n    while (k-- > 1) {\n      const auto [i, j, _] = minHeap.top();\n      minHeap.pop();\n      if (j + 1 < matrix[0].size())\n        minHeap.emplace(i, j + 1, matrix[i][j + 1]);\n    }\n\n    return minHeap.top().num;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "379. Design Phone Directory",
      "code": "class PhoneDirectory {\n public:\n  /** Initialize your data structure here\n      @param maxNumbers - The maximum numbers that can be stored in the phone\n     directory. */\n  PhoneDirectory(int maxNumbers) : next(maxNumbers) {\n    for (int i = 0; i < maxNumbers - 1; ++i)\n      next[i] = i + 1;\n    next.back() = 0;\n  }\n\n  /** Provide a number which is not assigned to anyone.\n      @return - Return an available number. Return -1 if none is available. */\n  int get() {\n    if (next[number] == -1)\n      return -1;\n\n    const int ans = number;\n    number = next[number];\n    next[ans] = -1;  // Mark as used\n    return ans;\n  }\n\n  /** Check if a number is available or not. */\n  bool check(int number) {\n    return next[number] != -1;\n  }\n\n  /** Recycle or release a number. */\n  void release(int number) {\n    if (next[number] != -1)\n      return;\n\n    next[number] = this->number;\n    this->number = number;\n  }\n\n private:\n  int number = 0;    // Current possible available number\n  vector<int> next;  // Next available number\n};\n"
    }
  ],
  [
    {
      "id": "380. Insert Delete GetRandom O(1)",
      "code": "class RandomizedSet {\n public:\n  /** Inserts a value to the set. Returns true if the set did not already\n   * contain the specified element. */\n  bool insert(int val) {\n    if (valToIndex.count(val))\n      return false;\n\n    valToIndex[val] = vals.size();\n    vals.push_back(val);\n    return true;\n  }\n\n  /** Removes a value from the set. Returns true if the set contained the\n   * specified element. */\n  bool remove(int val) {\n    if (!valToIndex.count(val))\n      return false;\n\n    const int index = valToIndex[val];\n    // Following two lines order are important when vals.size() == 1\n    valToIndex[vals.back()] = index;\n    valToIndex.erase(val);\n    vals[index] = vals.back();\n    vals.pop_back();\n    return true;\n  }\n\n  /** Get a random element from the set. */\n  int getRandom() {\n    const int index = rand() % vals.size();\n    return vals[index];\n  }\n\n private:\n  unordered_map<int, int> valToIndex;  // {val: index in vals}\n  vector<int> vals;\n};\n"
    }
  ],
  [
    {
      "id": "381. Insert Delete GetRandom O(1) - Duplicates allowed",
      "code": "struct Item {\n  int val;\n  int indexInMap;\n  Item(int val, int indexInMap) : val(val), indexInMap(indexInMap) {}\n };\n\n class RandomizedCollection {\n public:\n  /** Inserts a value to the collection. Returns true if the collection did not\n   * already contain the specified element. */\n  bool insert(int val) {\n    valToIndices[val].push_back(items.size());\n    items.emplace_back(val, valToIndices[val].size() - 1);\n    return valToIndices[val].size() == 1;\n  }\n\n  /** Removes a value from the collection. Returns true if the collection\n   * contained the specified element. */\n  bool remove(int val) {\n    if (!valToIndices.count(val))\n      return false;\n\n    const int index = valToIndices[val].back();\n    valToIndices[items.back().val][items.back().indexInMap] = index;\n    valToIndices[val].pop_back();\n    if (valToIndices[val].empty())\n      valToIndices.erase(val);\n    items[index] = items.back();\n    items.pop_back();\n    return true;\n  }\n\n  /** Get a random element from the collection. */\n  int getRandom() {\n    const int index = rand() % items.size();\n    return items[index].val;\n  }\n\n private:\n  unordered_map<int, vector<int>> valToIndices;\n  vector<Item> items;\n};\n"
    }
  ],
  [
    {
      "id": "382. Linked List Random Node",
      "code": "class Solution {\n public:\n  /** @param head The linked list's head.\n      Note that the head is guaranteed to be not null, so it contains at least\n     one node. */\n  Solution(ListNode* head) : head(head) {}\n\n  /** Returns a random node's value. */\n  int getRandom() {\n    int ans = -1;\n    int i = 1;\n\n    for (ListNode* curr = head; curr; curr = curr->next, ++i)\n      if (rand() % i == 0)\n        ans = curr->val;\n\n    return ans;\n  }\n\n private:\n  ListNode* head;\n};\n"
    }
  ],
  [
    {
      "id": "383. Ransom Note",
      "code": "class Solution {\n public:\n  bool canConstruct(string ransomNote, string magazine) {\n    vector<int> count(128);\n\n    for (const char c : magazine)\n      ++count[c];\n\n    for (const char c : ransomNote)\n      if (--count[c] < 0)\n        return false;\n\n    return true;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "384. Shuffle an Array",
      "code": "class Solution {\n public:\n  Solution(vector<int>& nums) : nums(move(nums)) {}\n\n  /** Resets the array to its original configuration and return it. */\n  vector<int> reset() {\n    return nums;\n  }\n\n  /** Returns a random shuffling of the array. */\n  vector<int> shuffle() {\n    vector<int> A(nums);\n    for (int i = A.size() - 1; i > 0; --i) {\n      const int j = rand() % (i + 1);\n      swap(A[i], A[j]);\n    }\n    return A;\n  }\n\n private:\n  vector<int> nums;\n};\n"
    }
  ],
  [
    {
      "id": "385. Mini Parser",
      "code": "class Solution {\n public:\n  NestedInteger deserialize(string s) {\n    if (s[0] != '[')\n      return NestedInteger(stoi(s));\n\n    stack<NestedInteger> stack;\n    int start;  // The start index of num\n\n    for (int i = 0; i < s.length(); ++i) {\n      switch (s[i]) {\n        case '[':\n          stack.push(NestedInteger());\n          start = i + 1;\n          break;\n        case ',':\n          if (i > start) {\n            const int num = stoi(s.substr(start, i));\n            stack.top().add(NestedInteger(num));\n          }\n          start = i + 1;\n          break;\n        case ']':\n          NestedInteger popped = stack.top();\n          stack.pop();\n          if (i > start) {\n            const int num = stoi(s.substr(start, i));\n            popped.add(NestedInteger(num));\n          }\n          if (stack.empty())\n            return popped;\n          else\n            stack.top().add(popped);\n          start = i + 1;\n          break;\n      }\n    }\n\n    throw;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "386. Lexicographical Numbers",
      "code": "class Solution {\n public:\n  vector<int> lexicalOrder(int n) {\n    vector<int> ans;\n    int curr = 1;\n\n    while (ans.size() < n) {\n      ans.push_back(curr);\n      if (curr * 10 <= n) {\n        curr *= 10;\n      } else {\n        while (curr % 10 == 9 || curr == n)\n          curr /= 10;\n        ++curr;\n      }\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "387. First Unique Character in a String",
      "code": "class Solution {\n public:\n  int firstUniqChar(string s) {\n    vector<int> count(128);\n\n    for (const char c : s)\n      ++count[c];\n\n    for (int i = 0; i < s.length(); ++i)\n      if (count[s[i]] == 1)\n        return i;\n\n    return -1;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "388. Longest Absolute File Path",
      "code": "struct T {\n  int depth;\n  size_t length;\n  T(int depth, size_t length) : depth(depth), length(length) {}\n };\n\n class Solution {\n public:\n  int lengthLongestPath(string input) {\n    size_t ans = 0;\n    stack<T> stack{{{-1, 0}}};  // Placeholder\n    istringstream iss(input);\n\n    for (string token; getline(iss, token, '\\n');) {\n      const int depth =\n          count_if(begin(token), end(token), [](char c) { return c == '\\t'; });\n      token.erase(remove(begin(token), end(token), '\\t'), end(token));\n      while (depth <= stack.top().depth)\n        stack.pop();\n      if (isFile(token))\n        ans = max(ans, stack.top().length + token.length());\n      else  // Directory + '/'\n        stack.emplace(depth, stack.top().length + token.length() + 1);\n    }\n\n    return ans;\n  }\n\n private:\n  bool isFile(const string& token) {\n    return token.find('.') != string::npos;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "389. Find the Difference",
      "code": "class Solution {\n public:\n  char findTheDifference(string s, string t) {\n    char ans = 0;\n\n    for (const char c : s)\n      ans ^= c;\n\n    for (const char c : t)\n      ans ^= c;\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "390. Elimination Game",
      "code": "class Solution {\n public:\n  int lastRemaining(int n) {\n    return n == 1 ? 1 : 2 * (1 + n / 2 - lastRemaining(n / 2));\n  }\n };\n"
    }
  ],
  [
    {
      "id": "391. Perfect Rectangle",
      "code": "class Solution {\n public:\n  bool isRectangleCover(vector<vector<int>>& rectangles) {\n    int area = 0;\n    int x1 = INT_MAX;\n    int y1 = INT_MAX;\n    int x2 = INT_MIN;\n    int y2 = INT_MIN;\n    unordered_set<string> corners;\n\n    for (const vector<int>& r : rectangles) {\n      area += (r[2] - r[0]) * (r[3] - r[1]);\n      x1 = min(x1, r[0]);\n      y1 = min(y1, r[1]);\n      x2 = max(x2, r[2]);\n      y2 = max(y2, r[3]);\n\n      // Four points of current rectangle\n      const vector<string> points{to_string(r[0]) + \" \" + to_string(r[1]),\n                                  to_string(r[0]) + \" \" + to_string(r[3]),\n                                  to_string(r[2]) + \" \" + to_string(r[1]),\n                                  to_string(r[2]) + \" \" + to_string(r[3])};\n      for (const string& point : points)\n        if (!corners.insert(point).second)\n          corners.erase(point);\n    }\n\n    if (corners.size() != 4)\n      return false;\n    if (!corners.count(to_string(x1) + \" \" + to_string(y1)) ||\n        !corners.count(to_string(x1) + \" \" + to_string(y2)) ||\n        !corners.count(to_string(x2) + \" \" + to_string(y1)) ||\n        !corners.count(to_string(x2) + \" \" + to_string(y2)))\n      return false;\n\n    return area == (x2 - x1) * (y2 - y1);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "392. Is Subsequence",
      "code": "class Solution {\n public:\n  bool isSubsequence(string s, string t) {\n    if (s.empty())\n      return true;\n\n    int i = 0;\n    for (const char c : t)\n      if (s[i] == c && ++i == s.length())\n        return true;\n\n    return false;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "393. UTF-8 Validation",
      "code": "class Solution {\n public:\n  bool validUtf8(vector<int>& data) {\n    int leftToCheck = 0;\n\n    for (const int d : data)\n      if (leftToCheck == 0) {\n        if ((d >> 3) == 0b11110)\n          leftToCheck = 3;\n        else if ((d >> 4) == 0b1110)\n          leftToCheck = 2;\n        else if ((d >> 5) == 0b110)\n          leftToCheck = 1;\n        else if ((d >> 7) == 0b0)\n          leftToCheck = 0;\n        else\n          return false;\n      } else {\n        if ((d >> 6) != 0b10)\n          return false;\n        --leftToCheck;\n      }\n\n    return leftToCheck == 0;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "394. Decode String",
      "code": "class Solution {\n public:\n  string decodeString(string s) {\n    stack<pair<string, int>> stack;  // (prevStr, repeatCount)\n    string currStr;\n    int currNum = 0;\n\n    for (const char c : s)\n      if (isdigit(c)) {\n        currNum = currNum * 10 + (c - '0');\n      } else {\n        if (c == '[') {\n          stack.emplace(currStr, currNum);\n          currStr = \"\";\n          currNum = 0;\n        } else if (c == ']') {\n          const auto [prevStr, n] = stack.top();\n          stack.pop();\n          currStr = prevStr + getRepeatedStr(currStr, n);\n        } else {\n          currStr += c;\n        }\n      }\n\n    return currStr;\n  }\n\n private:\n  // S * n times\n  string getRepeatedStr(const string& s, int n) {\n    string repeat;\n    while (n--)\n      repeat += s;\n    return repeat;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "395. Longest Substring with At Least K Repeating Characters",
      "code": "class Solution {\n public:\n  int longestSubstring(string s, int k) {\n    int ans = 0;\n\n    for (int n = 1; n <= 26; ++n)\n      ans = max(ans, longestSubstringWithNUniqueCharacters(s, k, n));\n\n    return ans;\n  }\n\n private:\n  int longestSubstringWithNUniqueCharacters(const string& s, int k, int n) {\n    int ans = 0;\n    int uniqueChars = 0;  // # of unique chars in window\n    int noLessThanK = 0;  // # of chars >= k in window\n    vector<int> count(128);\n\n    for (int l = 0, r = 0; r < s.length(); ++r) {\n      if (count[s[r]] == 0)\n        ++uniqueChars;\n      if (++count[s[r]] == k)\n        ++noLessThanK;\n      while (uniqueChars > n) {\n        if (count[s[l]] == k)\n          --noLessThanK;\n        if (--count[s[l]] == 0)\n          --uniqueChars;\n        ++l;\n      }\n      if (noLessThanK == n)  // Unique chars also == n\n        ans = max(ans, r - l + 1);\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "396. Rotate Function",
      "code": "class Solution {\n public:\n  int maxRotateFunction(vector<int>& nums) {\n    const int sum = accumulate(begin(nums), end(nums), 0);\n    int f = 0;\n\n    // Calculate F(0) first\n    for (int i = 0; i < nums.size(); ++i)\n      f += i * nums[i];\n\n    int ans = f;\n\n    for (int i = nums.size() - 1; i > 0; --i) {\n      f += sum - nums.size() * nums[i];\n      ans = max(ans, f);\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "397. Integer Replacement",
      "code": "class Solution {\n public:\n  int integerReplacement(long n) {\n    int ans = 0;\n\n    for (; n > 1; ++ans)\n      if ((n & 1) == 0)  // Ends w/ 0\n        n >>= 1;\n      else if (n == 3 || ((n >> 1) & 1) == 0)  // N = 3 or ends w/ 01\n        --n;\n      else  // Ends w/ 11\n        ++n;\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "398. Random Pick Index",
      "code": "class Solution {\n public:\n  Solution(vector<int>& nums) : nums(move(nums)) {}\n\n  int pick(int target) {\n    int ans = -1;\n    int range = 0;\n\n    for (int i = 0; i < nums.size(); ++i)\n      if (nums[i] == target && rand() % ++range == 0)\n        ans = i;\n\n    return ans;\n  }\n\n private:\n  vector<int> nums;\n};\n"
    }
  ],
  [
    {
      "id": "399. Evaluate Division",
      "code": "class Solution {\n public:\n  vector<double> calcEquation(vector<vector<string>>& equations,\n                              vector<double>& values,\n                              vector<vector<string>>& queries) {\n    vector<double> ans;\n    // graph[A][B] := A / B\n    unordered_map<string, unordered_map<string, double>> graph;\n\n    for (int i = 0; i < equations.size(); ++i) {\n      const string& A = equations[i][0];\n      const string& B = equations[i][1];\n      graph[A][B] = values[i];\n      graph[B][A] = 1 / values[i];\n    }\n\n    for (const vector<string>& query : queries) {\n      const string& A = query[0];\n      const string& C = query[1];\n      if (!graph.count(A) || !graph.count(C))\n        ans.push_back(-1);\n      else\n        ans.push_back(divide(graph, A, C, unordered_set<string>()));\n    }\n\n    return ans;\n  }\n\n private:\n  // Returns A / C\n  double divide(\n      const unordered_map<string, unordered_map<string, double>>& graph,\n      const string& A, const string& C, unordered_set<string>&& seen) {\n    if (A == C)\n      return 1.0;\n\n    seen.insert(A);\n\n    // Value := A / B\n    for (const auto& [B, value] : graph.at(A)) {\n      if (seen.count(B))\n        continue;\n      const double res = divide(graph, B, C, move(seen));  // B / C\n      if (res > 0)                                         // Valid result\n        return value * res;  // A / C = (A / B) * (B / C)\n    }\n\n    return -1;  // Invalid result\n  }\n };\n"
    }
  ],
  [
    {
      "id": "400. Nth Digit",
      "code": "class Solution {\n public:\n  int findNthDigit(int n) {\n    int digitSize = 1;\n    int startNum = 1;\n    long count = 9;\n\n    while (digitSize * count < n) {\n      n -= digitSize * count;\n      ++digitSize;\n      startNum *= 10;\n      count *= 10;\n    }\n\n    const int targetNum = startNum + (n - 1) / digitSize;\n    const int index = (n - 1) % digitSize;\n    return to_string(targetNum)[index] - '0';\n  }\n };\n"
    }
  ],
  [
    {
      "id": "401. Binary Watch",
      "code": "class Solution {\n public:\n  vector<string> readBinaryWatch(int num) {\n    vector<string> ans;\n    dfs(num, 0, 0, 0, ans);\n    return ans;\n  }\n\n private:\n  const vector<int> hours{1, 2, 4, 8};\n  const vector<int> minutes{1, 2, 4, 8, 16, 32};\n\n  void dfs(int n, int s, int h, int m, vector<string>& ans) {\n    if (n == 0) {\n      string time = to_string(h) + \":\" + (m < 10 ? \"0\" : \"\") + to_string(m);\n      ans.push_back(time);\n      return;\n    }\n\n    for (int i = s; i < hours.size() + minutes.size(); ++i)\n      if (i < 4 && h + hours[i] < 12)\n        dfs(n - 1, i + 1, h + hours[i], m, ans);\n      else if (i >= 4 && m + minutes[i - 4] < 60)\n        dfs(n - 1, i + 1, h, m + minutes[i - 4], ans);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "402. Remove K Digits",
      "code": "class Solution {\n public:\n  string removeKdigits(string num, int k) {\n    if (num.length() == k)\n      return \"0\";\n\n    string ans;\n    vector<char> stack;\n\n    for (int i = 0; i < num.length(); ++i) {\n      while (k > 0 && !stack.empty() && stack.back() > num[i]) {\n        stack.pop_back();\n        --k;\n      }\n      stack.push_back(num[i]);\n    }\n\n    while (k-- > 0)\n      stack.pop_back();\n\n    for (const char c : stack) {\n      if (c == '0' && ans.empty())\n        continue;\n      ans += c;\n    }\n\n    return ans.empty() ? \"0\" : ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "403. Frog Jump",
      "code": "class Solution {\n public:\n  bool canCross(vector<int>& stones) {\n    const int n = stones.size();\n    // dp[i][j] := true if a frog can make a size j jump to stones[i]\n    vector<vector<bool>> dp(n, vector<bool>(n + 1));\n    dp[0][0] = true;\n\n    for (int i = 1; i < n; ++i)\n      for (int j = 0; j < i; ++j) {\n        const int k = stones[i] - stones[j];\n        if (k > n)\n          continue;\n        for (const int x : {k - 1, k, k + 1})\n          if (0 <= x && x <= n)\n            dp[i][k] = dp[i][k] || dp[j][x];\n      }\n\n    return any_of(begin(dp.back()), end(dp.back()),\n                  [](bool val) { return val; });\n  }\n };\n"
    }
  ],
  [
    {
      "id": "404. Sum of Left Leaves",
      "code": "class Solution {\n public:\n  int sumOfLeftLeaves(TreeNode* root) {\n    if (root == nullptr)\n      return 0;\n\n    int ans = 0;\n\n    if (root->left) {\n      if (root->left->left == nullptr && root->left->right == nullptr)\n        ans += root->left->val;\n      else\n        ans += sumOfLeftLeaves(root->left);\n    }\n    ans += sumOfLeftLeaves(root->right);\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "405. Convert a Number to Hexadecimal",
      "code": "class Solution {\n public:\n  string toHex(unsigned num) {\n    const vector<char> hex{'0', '1', '2', '3', '4', '5', '6', '7',\n                           '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\n    string ans;\n\n    while (num) {\n      ans += hex[num & 0xf];\n      num >>= 4;\n    }\n\n    reverse(begin(ans), end(ans));\n    return ans.empty() ? \"0\" : ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "406. Queue Reconstruction by Height",
      "code": "class Solution {\n public:\n  vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {\n    vector<vector<int>> ans;\n\n    sort(begin(people), end(people), [](const auto& a, const auto& b) {\n      return a[0] == b[0] ? a[1] < b[1] : a[0] > b[0];\n    });\n\n    for (const vector<int>& p : people)\n      ans.insert(begin(ans) + p[1], p);\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "407. Trapping Rain Water II",
      "code": "struct T {\n  int i;\n  int j;\n  int h;  // heightMap[i][j] or the height after filling water\n  T(int i, int j, int h) : i(i), j(j), h(h) {}\n };\n\n class Solution {\n public:\n  int trapRainWater(vector<vector<int>>& heightMap) {\n    const int m = heightMap.size();\n    const int n = heightMap[0].size();\n    const vector<int> dirs{0, 1, 0, -1, 0};\n    int ans = 0;\n    auto compare = [](const T& a, const T& b) { return a.h > b.h; };\n    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);\n    vector<vector<bool>> seen(m, vector<bool>(n));\n\n    for (int i = 0; i < m; ++i) {\n      minHeap.emplace(i, 0, heightMap[i][0]);\n      minHeap.emplace(i, n - 1, heightMap[i][n - 1]);\n      seen[i][0] = true;\n      seen[i][n - 1] = true;\n    }\n\n    for (int j = 1; j < n - 1; ++j) {\n      minHeap.emplace(0, j, heightMap[0][j]);\n      minHeap.emplace(m - 1, j, heightMap[m - 1][j]);\n      seen[0][j] = true;\n      seen[m - 1][j] = true;\n    }\n\n    while (!minHeap.empty()) {\n      const auto [i, j, h] = minHeap.top();\n      minHeap.pop();\n      for (int k = 0; k < 4; ++k) {\n        const int x = i + dirs[k];\n        const int y = j + dirs[k + 1];\n        if (x < 0 || x == m || y < 0 || y == n)\n          continue;\n        if (seen[x][y])\n          continue;\n        if (heightMap[x][y] < h) {\n          ans += h - heightMap[x][y];\n          minHeap.emplace(x, y, h);  // Fill the water on grid[x][y]\n        } else {\n          minHeap.emplace(x, y, heightMap[x][y]);\n        }\n        seen[x][y] = true;\n      }\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "408. Valid Word Abbreviation",
      "code": "class Solution {\n public:\n  bool validWordAbbreviation(const string& word, const string& abbr) {\n    int i = 0;  // word's index\n    int j = 0;  // abbr's index\n\n    while (i < word.length() && j < abbr.length()) {\n      if (word[i] == abbr[j]) {\n        ++i;\n        ++j;\n        continue;\n      }\n      if (abbr[j] <= '0' || abbr[j] > '9')\n        return false;\n      int num = 0;\n      while (j < abbr.length() && isdigit(abbr[j])) {\n        num = num * 10 + abbr[j] - '0';\n        ++j;\n      }\n      i += num;\n    }\n\n    return i == word.length() && j == abbr.length();\n  }\n };\n"
    }
  ],
  [
    {
      "id": "409. Longest Palindrome",
      "code": "class Solution {\n public:\n  int longestPalindrome(string s) {\n    int ans = 0;\n    vector<int> count(128);\n\n    for (const char c : s)\n      ++count[c];\n\n    for (const int c : count)\n      ans += c % 2 == 0 ? c : c - 1;\n\n    const bool hasOddCount =\n        any_of(begin(count), end(count), [](int c) { return c & 1; });\n\n    return ans + hasOddCount;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "410. Split Array Largest Sum",
      "code": "class Solution {\n public:\n  int splitArray(vector<int>& nums, int m) {\n    const int n = nums.size();\n    // dp[i][k] := min of largest sum to split first i nums into k groups\n    dp.resize(n + 1, vector<int>(m + 1, INT_MAX));\n    prefix.resize(n + 1);\n\n    partial_sum(begin(nums), end(nums), begin(prefix) + 1);\n    return splitArray(nums, n, m);\n  }\n\n private:\n  vector<vector<int>> dp;\n  vector<int> prefix;\n\n  int splitArray(const vector<int>& nums, int i, int k) {\n    if (k == 1)\n      return prefix[i];\n    if (dp[i][k] < INT_MAX)\n      return dp[i][k];\n\n    // Try all possible partitions\n    for (int j = k - 1; j < i; ++j)\n      dp[i][k] =\n          min(dp[i][k], max(splitArray(nums, j, k - 1), prefix[i] - prefix[j]));\n\n    return dp[i][k];\n  }\n };\n"
    }
  ],
  [
    {
      "id": "411. Minimum Unique Word Abbreviation",
      "code": "class Solution {\n public:\n  string minAbbreviation(string target, vector<string>& dictionary) {\n    const int m = target.length();\n    vector<int> masks;\n\n    for (const string& word : dictionary) {\n      if (word.length() != m)\n        continue;\n      masks.push_back(getMask(target, word));\n    }\n\n    if (masks.empty())\n      return to_string(m);\n\n    vector<string> abbrs;\n\n    const int maxCand = pow(2, m);\n    // For all candidate representation of target\n    for (int cand = 0; cand < maxCand; ++cand)\n      // All masks have at lease one bit different from candidate\n      if (all_of(begin(masks), end(masks),\n                 [cand](int mask) { return cand & mask; }))\n        abbrs.push_back(getAbbr(target, cand));\n\n    string ans = target;\n\n    for (const string& abbr : abbrs)\n      if (getAbbrLen(abbr) < getAbbrLen(ans))\n        ans = abbr;\n\n    return ans;\n  }\n\n private:\n  int getMask(const string& target, const string& word) {\n    const int m = target.length();\n    // mask[i] = 0 := target[i] == word[i]\n    // mask[i] = 1 := target[i] != word[i]\n    // E.g. target = \"apple\"\n    //        word = \"blade\"\n    //        mask =  11110\n    int mask = 0;\n    for (int i = 0; i < m; ++i)\n      if (word[i] != target[i])\n        mask |= 1 << m - 1 - i;\n    return mask;\n  }\n\n  string getAbbr(const string& target, int cand) {\n    const int m = target.length();\n    string abbr;\n    int replacedCount = 0;\n    for (int i = 0; i < m; ++i)\n      if (cand >> m - 1 - i & 1) {\n        // cand[i] = 1, abbr should show the original character\n        if (replacedCount > 0)\n          abbr += to_string(replacedCount);\n        abbr += target[i];\n        replacedCount = 0;\n      } else {\n        // cand[i] = 0, abbr can be replaced\n        ++replacedCount;\n      }\n    if (replacedCount > 0)\n      abbr += to_string(replacedCount);\n    return abbr;\n  }\n\n  int getAbbrLen(const string& abbr) {\n    int abbrLen = 0;\n    int i = 0;\n    int j = 0;\n    while (i < abbr.length()) {\n      if (isalpha(abbr[j]))\n        ++j;\n      else\n        while (j < abbr.length() && isdigit(abbr[j]))\n          ++j;\n      ++abbrLen;\n      i = j;\n    }\n    return abbrLen;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "412. Fizz Buzz",
      "code": "class Solution {\n public:\n  vector<string> fizzBuzz(int n) {\n    vector<string> ans;\n\n    for (int i = 1; i <= n; ++i) {\n      string s;\n      if (i % 3 == 0)\n        s += \"Fizz\";\n      if (i % 5 == 0)\n        s += \"Buzz\";\n      ans.push_back(s.empty() ? to_string(i) : s);\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "413. Arithmetic Slices",
      "code": "class Solution {\n public:\n  int numberOfArithmeticSlices(vector<int>& nums) {\n    const int n = nums.size();\n    if (n < 3)\n      return 0;\n\n    vector<int> dp(n);  // # arithmetic slices ends at i\n\n    for (int i = 2; i < nums.size(); ++i)\n      if (nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2])\n        dp[i] = dp[i - 1] + 1;\n\n    return accumulate(begin(dp), end(dp), 0);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "414. Third Maximum Number",
      "code": "class Solution {\n public:\n  int thirdMax(vector<int>& nums) {\n    long max1 = LONG_MIN;  // The maximum\n    long max2 = LONG_MIN;  // 2nd maximum\n    long max3 = LONG_MIN;  // 3rd maximum\n\n    for (const int num : nums)\n      if (num > max1) {\n        max3 = max2;\n        max2 = max1;\n        max1 = num;\n      } else if (max1 > num && num > max2) {\n        max3 = max2;\n        max2 = num;\n      } else if (max2 > num && num > max3) {\n        max3 = num;\n      }\n\n    return max3 == LONG_MIN ? max1 : max3;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "415. Add Strings",
      "code": "class Solution {\n public:\n  string addStrings(string num1, string num2) {\n    string ans;\n    int carry = 0;\n    int i = num1.length() - 1;\n    int j = num2.length() - 1;\n\n    while (i >= 0 || j >= 0 || carry) {\n      if (i >= 0)\n        carry += num1[i--] - '0';\n      if (j >= 0)\n        carry += num2[j--] - '0';\n      ans += carry % 10 + '0';\n      carry /= 10;\n    }\n\n    reverse(begin(ans), end(ans));\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "416. Partition Equal Subset Sum",
      "code": "class Solution {\n public:\n  bool canPartition(vector<int>& nums) {\n    const int sum = accumulate(begin(nums), end(nums), 0);\n    if (sum & 1)\n      return false;\n    return knapsack(nums, sum / 2);\n  }\n\n private:\n  bool knapsack(const vector<int>& nums, int subsetSum) {\n    const int n = nums.size();\n    // dp[i][j] := true if j can be formed by nums[0..i)\n    vector<vector<bool>> dp(n + 1, vector<bool>(subsetSum + 1));\n    dp[0][0] = true;\n\n    for (int i = 1; i <= n; ++i) {\n      const int num = nums[i - 1];\n      for (int j = 0; j <= subsetSum; ++j)\n        if (j < num)\n          dp[i][j] = dp[i - 1][j];\n        else\n          dp[i][j] = dp[i - 1][j] || dp[i - 1][j - num];\n    }\n\n    return dp[n][subsetSum];\n  }\n };\n"
    }
  ],
  [
    {
      "id": "417. Pacific Atlantic Water Flow",
      "code": "class Solution {\n public:\n  vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\n    const int m = heights.size();\n    const int n = heights[0].size();\n    const vector<int> dirs{0, 1, 0, -1, 0};\n    vector<vector<int>> ans;\n    queue<pair<int, int>> qP;\n    queue<pair<int, int>> qA;\n    vector<vector<bool>> seenP(m, vector<bool>(n));\n    vector<vector<bool>> seenA(m, vector<bool>(n));\n\n    auto bfs = [&](queue<pair<int, int>>& q, vector<vector<bool>>& seen) {\n      while (!q.empty()) {\n        const auto [i, j] = q.front();\n        q.pop();\n        const int h = heights[i][j];\n        for (int k = 0; k < 4; ++k) {\n          const int x = i + dirs[k];\n          const int y = j + dirs[k + 1];\n          if (x < 0 || x == m || y < 0 || y == n)\n            continue;\n          if (seen[x][y] || heights[x][y] < h)\n            continue;\n          q.emplace(x, y);\n          seen[x][y] = true;\n        }\n      }\n    };\n\n    for (int i = 0; i < m; ++i) {\n      qP.emplace(i, 0);\n      qA.emplace(i, n - 1);\n      seenP[i][0] = true;\n      seenA[i][n - 1] = true;\n    }\n\n    for (int j = 0; j < n; ++j) {\n      qP.emplace(0, j);\n      qA.emplace(m - 1, j);\n      seenP[0][j] = true;\n      seenA[m - 1][j] = true;\n    }\n\n    bfs(qP, seenP);\n    bfs(qA, seenA);\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (seenP[i][j] && seenA[i][j])\n          ans.push_back({i, j});\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "418. Sentence Screen Fitting",
      "code": "class Solution {\n public:\n  int wordsTyping(vector<string>& sentence, int rows, int cols) {\n    const string& combined = getCombined(sentence);\n    const int n = combined.length();\n    int i = 0;  // (i % n) points to the index of combined in each row\n\n    while (rows--) {\n      i += cols;\n      if (combined[i % n] == ' ') {\n        ++i;\n      } else {\n        while (i > 0 && combined[(i - 1) % n] != ' ')\n          --i;\n      }\n    }\n\n    return i / n;\n  }\n\n private:\n  string getCombined(const vector<string>& sentence) {\n    string combined;\n    for (const string& word : sentence)\n      combined += (word + ' ');\n    return combined;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "419. Battleships in a Board",
      "code": "class Solution {\n public:\n  int countBattleships(vector<vector<char>>& board) {\n    int ans = 0;\n\n    for (int i = 0; i < board.size(); ++i)\n      for (int j = 0; j < board[0].size(); ++j) {\n        if (board[i][j] == '.')\n          continue;\n        if (i > 0 && board[i - 1][j] == 'X')\n          continue;\n        if (j > 0 && board[i][j - 1] == 'X')\n          continue;\n        ++ans;\n      }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "420. Strong Password Checker",
      "code": "class Solution {\n public:\n  int strongPasswordChecker(string s) {\n    const int n = s.length();\n    const int missing = getMissing(s);\n    // # of replacements to deal with 3 repeating characters\n    int replaces = 0;\n    // # of seqs that can be substituted with 1 deletions, (3k)-seqs\n    int oneSeq = 0;\n    // # of seqs that can be substituted with 2 deletions, (3k + 1)-seqs\n    int twoSeq = 0;\n\n    for (int i = 2; i < n;)\n      if (s[i] == s[i - 1] && s[i - 1] == s[i - 2]) {\n        int length = 2;  // Length of repeating s\n        while (i < n && s[i] == s[i - 1]) {\n          ++length;\n          ++i;\n        }\n        replaces += length / 3;  // 'aaaaaaa' -> 'aaxaaxa'\n        if (length % 3 == 0)\n          ++oneSeq;\n        if (length % 3 == 1)\n          ++twoSeq;\n      } else {\n        ++i;\n      }\n\n    if (n < 6)\n      return max(6 - n, missing);\n    if (n <= 20)\n      return max(replaces, missing);\n\n    const int deletes = n - 20;\n    // Each replacement in (3k)-seqs can be substituted with 1 deletions\n    replaces -= min(oneSeq, deletes);\n    // Each replacement in (3k + 1)-seqs can be substituted with 2 deletions\n    replaces -= min(max(deletes - oneSeq, 0), twoSeq * 2) / 2;\n    // Each replacement in other seqs can be substituted with 3 deletions\n    replaces -= max(deletes - oneSeq - twoSeq * 2, 0) / 3;\n    return deletes + max(replaces, missing);\n  }\n\n private:\n  int getMissing(const string& s) {\n    int missing = 3;\n    if (any_of(begin(s), end(s), [](char c) { return isupper(c); }))\n      --missing;\n    if (any_of(begin(s), end(s), [](char c) { return islower(c); }))\n      --missing;\n    if (any_of(begin(s), end(s), [](char c) { return isdigit(c); }))\n      --missing;\n    return missing;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "421. Maximum XOR of Two Numbers in an Array",
      "code": "class Solution {\n public:\n  int findMaximumXOR(vector<int>& nums) {\n    const int maxNum = *max_element(begin(nums), end(nums));\n    if (maxNum == 0)\n      return 0;\n    const int maxBit = static_cast<int>(log2(maxNum));\n    int ans = 0;\n    int mask = 0;\n\n    // If ans is 11100 when i = 2, it means that before we reach the last two\n    // bits, 11100 is the maximum XOR we have, and we're going to explore if we\n    // can get another two '1's and put them into ans.\n    for (int i = maxBit; i >= 0; --i) {\n      // Mask grows like: 100...000, 110...000, 111...000, ..., 111...111.\n      mask |= 1 << i;\n      unordered_set<int> prefixes;\n      // We only care about the left parts,\n      // If i = 2, nums = {1110, 1011, 0111}\n      //    -> prefixes = {1100, 1000, 0100}\n      for (const int num : nums)\n        prefixes.insert(num & mask);\n      // If i = 1 and before this iteration, the ans is 10100, it means that we\n      // want to grow the ans to 10100 | 1 << 1 = 10110 and we're looking for\n      // XOR of two prefixes = candidate.\n      const int candidate = ans | 1 << i;\n      for (const int prefix : prefixes)\n        if (prefixes.count(prefix ^ candidate)) {\n          ans = candidate;\n          break;\n        }\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "422. Valid Word Square",
      "code": "class Solution {\n public:\n  bool validWordSquare(vector<string>& words) {\n    for (int i = 0; i < words.size(); ++i)\n      for (int j = 0; j < words[i].size(); ++j) {\n        if (words.size() <= j || words[j].size() <= i)  // Out of bound\n          return false;\n        if (words[i][j] != words[j][i])\n          return false;\n      }\n\n    return true;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "423. Reconstruct Original Digits from English",
      "code": "class Solution {\n public:\n  string originalDigits(string s) {\n    string ans;\n    vector<int> count(10);\n\n    for (const char c : s) {\n      if (c == 'z')\n        ++count[0];\n      if (c == 'o')\n        ++count[1];\n      if (c == 'w')\n        ++count[2];\n      if (c == 'h')\n        ++count[3];\n      if (c == 'u')\n        ++count[4];\n      if (c == 'f')\n        ++count[5];\n      if (c == 'x')\n        ++count[6];\n      if (c == 's')\n        ++count[7];\n      if (c == 'g')\n        ++count[8];\n      if (c == 'i')\n        ++count[9];\n    }\n\n    count[1] -= count[0] + count[2] + count[4];\n    count[3] -= count[8];\n    count[5] -= count[4];\n    count[7] -= count[6];\n    count[9] -= count[5] + count[6] + count[8];\n\n    for (int i = 0; i < 10; ++i)\n      for (int j = 0; j < count[i]; ++j)\n        ans += i + '0';\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "424. Longest Repeating Character Replacement",
      "code": "class Solution {\n public:\n  int characterReplacement(string s, int k) {\n    int ans = 0;\n    int maxCount = 0;\n    vector<int> count(128);\n\n    for (int l = 0, r = 0; r < s.length(); ++r) {\n      maxCount = max(maxCount, ++count[s[r]]);\n      while (maxCount + k < r - l + 1)\n        --count[s[l++]];\n      ans = max(ans, r - l + 1);\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "425. Word Squares",
      "code": "struct TrieNode {\n  vector<shared_ptr<TrieNode>> children;\n  vector<const string*> startsWith;\n  TrieNode() : children(26) {}\n };\n\n class Trie {\n public:\n  Trie(const vector<string>& words) {\n    for (const string& word : words)\n      insert(word);\n  }\n\n  vector<const string*> findBy(const string& prefix) {\n    shared_ptr<TrieNode> node = root;\n    for (const char c : prefix) {\n      const int i = c - 'a';\n      if (node->children[i] == nullptr)\n        return {};\n      node = node->children[i];\n    }\n    return node->startsWith;\n  }\n\n private:\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n\n  void insert(const string& word) {\n    shared_ptr<TrieNode> node = root;\n    for (const char c : word) {\n      const int i = c - 'a';\n      if (node->children[i] == nullptr)\n        node->children[i] = make_shared<TrieNode>();\n      node = node->children[i];\n      node->startsWith.push_back(&word);\n    }\n  }\n };\n\n class Solution {\n public:\n  vector<vector<string>> wordSquares(vector<string>& words) {\n    if (words.empty())\n      return {};\n\n    const int n = words[0].length();\n    vector<vector<string>> ans;\n    vector<string> path;\n    Trie trie(words);\n\n    for (const string& word : words) {\n      path.push_back(word);\n      dfs(trie, n, path, ans);\n      path.pop_back();\n    }\n\n    return ans;\n  }\n\n private:\n  void dfs(Trie& trie, const int n, vector<string>& path,\n           vector<vector<string>>& ans) {\n    if (path.size() == n) {\n      ans.push_back(path);\n      return;\n    }\n\n    const string prefix = getPrefix(path);\n\n    for (const string* s : trie.findBy(prefix)) {\n      path.push_back(*s);\n      dfs(trie, n, path, ans);\n      path.pop_back();\n    }\n  }\n\n  // E.g. path = [\"wall\",\n  //              \"area\"]\n  //    prefix =  \"le..\"\n  string getPrefix(const vector<string>& path) {\n    string prefix;\n    const int index = path.size();\n    for (const string& s : path)\n      prefix += s[index];\n    return prefix;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "426. Convert Binary Search Tree to Sorted Doubly Linked List",
      "code": "class Solution {\n public:\n  Node* treeToDoublyList(Node* root) {\n    if (root == nullptr)\n      return nullptr;\n\n    Node* leftHead = treeToDoublyList(root->left);\n    Node* rightHead = treeToDoublyList(root->right);\n    root->left = root;\n    root->right = root;\n    return connect(connect(leftHead, root), rightHead);\n  }\n\n private:\n  Node* connect(Node* node1, Node* node2) {\n    if (node1 == nullptr)\n      return node2;\n    if (node2 == nullptr)\n      return node1;\n\n    Node* tail1 = node1->left;\n    Node* tail2 = node2->left;\n\n    // Connect node1's tail with node2\n    tail1->right = node2;\n    node2->left = tail1;\n\n    // Connect node2's tail with node1\n    tail2->right = node1;\n    node1->left = tail2;\n    return node1;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "427. Construct Quad Tree",
      "code": "class Solution {\n public:\n  Node* construct(vector<vector<int>>& grid) {\n    return helper(grid, 0, 0, grid.size());\n  }\n\n private:\n  Node* helper(const vector<vector<int>>& grid, int i, int j, int w) {\n    if (allSame(grid, i, j, w))\n      return new Node(grid[i][j], true);\n\n    Node* node = new Node(true, false);\n    node->topLeft = helper(grid, i, j, w / 2);\n    node->topRight = helper(grid, i, j + w / 2, w / 2);\n    node->bottomLeft = helper(grid, i + w / 2, j, w / 2);\n    node->bottomRight = helper(grid, i + w / 2, j + w / 2, w / 2);\n    return node;\n  }\n\n  bool allSame(const vector<vector<int>>& grid, int i, int j, int w) {\n    return all_of(begin(grid) + i, begin(grid) + i + w,\n                  [&](const vector<int>& row) {\n      return all_of(begin(row) + j, begin(row) + j + w,\n                    [&](int num) { return num == grid[i][j]; });\n    });\n  }\n };\n"
    }
  ],
  [
    {
      "id": "428. Serialize and Deserialize N-ary Tree",
      "code": "class Codec {\n public:\n  // Encodes a tree to a single string.\n  string serialize(Node* root) {\n    if (root == nullptr)\n      return \"\";\n\n    string s;\n    queue<Node*> q{{root}};\n    s += to_string(root->val) + \" \";\n\n    while (!q.empty())\n      for (int sz = q.size(); sz > 0; --sz) {\n        Node* node = q.front();\n        q.pop();\n        if (node->children.empty()) {\n          s += \"n\";\n        } else {\n          for (Node* child : node->children) {\n            q.push(child);\n            s += to_string(child->val) + \"#\";\n          }\n        }\n        s += \" \";\n      }\n\n    return s;\n  }\n\n  // Decodes your encoded data to tree.\n  Node* deserialize(string data) {\n    if (data.empty())\n      return nullptr;\n\n    istringstream iss(data);\n    string word;\n    iss >> word;\n    Node* root = new Node(stoi(word));\n    queue<Node*> q{{root}};\n\n    while (iss >> word) {\n      Node* parent = q.front();\n      q.pop();\n      vector<string> kids = getKids(word);\n      vector<Node*> children;\n      for (const string& kid : kids) {\n        if (kid == \"n\")\n          continue;\n        Node* child = new Node(stoi(kid));\n        children.push_back(child);\n        q.push(child);\n      }\n      parent->children = children;\n    }\n\n    return root;\n  }\n\n private:\n  vector<string> getKids(const string& word) {\n    vector<string> kids;\n    for (int i = 0, j = 0; j < word.length(); ++j)\n      if (word[j] == '#') {\n        kids.push_back(word.substr(i, j - i));\n        i = j + 1;\n      }\n    return kids;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "429. N-ary Tree Level Order Traversal",
      "code": "class Solution {\n public:\n  vector<vector<int>> levelOrder(Node* root) {\n    if (root == nullptr)\n      return {};\n\n    vector<vector<int>> ans;\n    queue<Node*> q{{root}};\n\n    while (!q.empty()) {\n      vector<int> currLevel;\n      for (int sz = q.size(); sz > 0; --sz) {\n        Node* node = q.front();\n        q.pop();\n        currLevel.push_back(node->val);\n        for (Node* child : node->children)\n          q.push(child);\n      }\n      ans.push_back(currLevel);\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "430. Flatten a Multilevel Doubly Linked List",
      "code": "class Solution {\n public:\n  Node* flatten(Node* head, Node* rest = nullptr) {\n    if (head == nullptr)\n      return rest;\n\n    head->next = flatten(head->child, flatten(head->next, rest));\n    if (head->next)\n      head->next->prev = head;\n    head->child = nullptr;\n    return head;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "431. Encode N-ary Tree to Binary Tree",
      "code": "class Codec {\n public:\n  // Encodes an n-ary tree to a binary tree.\n  TreeNode* encode(Node* root) {\n    if (root == nullptr)\n      return nullptr;\n\n    TreeNode* rootTreeNode = new TreeNode(root->val);\n    queue<pair<Node*, TreeNode*>> q{{{root, rootTreeNode}}};\n\n    while (!q.empty()) {\n      const auto [parentNode, parentTreeNode] = q.front();\n      q.pop();\n      TreeNode* prevTreeNode = nullptr;\n      TreeNode* headTreeNode = nullptr;\n      for (Node* child : parentNode->children) {\n        TreeNode* currTreeNode = new TreeNode(child->val);\n        if (prevTreeNode != nullptr)\n          prevTreeNode->right = currTreeNode;\n        else\n          headTreeNode = currTreeNode;\n        prevTreeNode = currTreeNode;\n        q.emplace(child, currTreeNode);\n      }\n      parentTreeNode->left = headTreeNode;\n    }\n\n    return rootTreeNode;\n  }\n\n  // Decodes your binary tree to an n-ary tree.\n  Node* decode(TreeNode* root) {\n    if (root == nullptr)\n      return nullptr;\n\n    Node* rootNode = new Node(root->val);\n    queue<pair<Node*, TreeNode*>> q{{{rootNode, root}}};\n\n    while (!q.empty()) {\n      const auto [parentNode, parentTreeNode] = q.front();\n      q.pop();\n      TreeNode* sibling = parentTreeNode->left;\n      while (sibling) {\n        Node* currNode = new Node(sibling->val);\n        parentNode->children.push_back(currNode);\n        q.emplace(currNode, sibling);\n        sibling = sibling->right;\n      }\n    }\n\n    return rootNode;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "432. All O`one Data Structure",
      "code": "class AllOne {\n public:\n  void inc(string key) {\n    const auto it = keyToIterator.find(key);\n\n    // doesn't find the key\n    if (it == cend(keyToIterator)) {\n      if (l.empty() || l.front().value > 1)\n        l.push_front({1, {key}});\n      else\n        l.front().keys.insert(key);\n      keyToIterator[key] = begin(l);\n      return;\n    }\n\n    const auto lit = it->second;  // List iterator\n    auto nit = next(lit);         // Next iterator\n\n    if (nit == end(l) || nit->value > lit->value + 1)\n      nit = l.insert(nit, {lit->value + 1, {key}});\n    else  // Nit->value == lit->value + 1\n      nit->keys.insert(key);\n    keyToIterator[key] = nit;  // Reset the mapping\n\n    // Remove the key in keys set\n    lit->keys.erase(key);\n    if (lit->keys.empty())\n      l.erase(lit);\n  }\n\n  void dec(string key) {\n    const auto it = keyToIterator.find(key);\n\n    // doens't find the key\n    if (it == cend(keyToIterator))\n      return;\n\n    const auto lit = it->second;  // List iterator\n\n    if (lit->value == 1) {  // No need to find prev iterator in this case\n      keyToIterator.erase(key);\n    } else {\n      auto pit = prev(lit);  // Prev iterator\n\n      if (lit == begin(l) || pit->value < lit->value - 1)\n        pit = l.insert(lit, {lit->value - 1, {key}});\n      else  // Pit->value == lit-value - 1\n        pit->keys.insert(key);\n      keyToIterator[key] = pit;  // Reset the mapping\n    }\n\n    // Remove the key in keys set\n    lit->keys.erase(key);\n    if (lit->keys.empty())\n      l.erase(lit);\n  }\n\n  string getMaxKey() {\n    return l.empty() ? \"\" : *cbegin(l.back().keys);\n  }\n\n  string getMinKey() {\n    return l.empty() ? \"\" : *cbegin(l.front().keys);\n  }\n\n private:\n  struct Node {\n    int value;\n    unordered_set<string> keys;\n  };\n\n  list<Node> l;\n  unordered_map<string, list<Node>::iterator> keyToIterator;\n};\n"
    }
  ],
  [
    {
      "id": "433. Minimum Genetic Mutation",
      "code": "class Solution {\n public:\n  int minMutation(string start, string end, vector<string>& bank) {\n    unordered_set<string> bankSet{bank.begin(), bank.end()};\n    if (!bankSet.count(end))\n      return -1;\n\n    int ans = 0;\n    queue<string> q{{start}};\n\n    while (!q.empty()) {\n      ++ans;\n      for (int sz = q.size(); sz > 0; --sz) {\n        string word = q.front();\n        q.pop();\n        for (int j = 0; j < word.length(); ++j) {\n          const char cache = word[j];\n          for (const char c : {'A', 'C', 'G', 'T'}) {\n            word[j] = c;\n            if (word == end)\n              return ans;\n            if (bankSet.count(word)) {\n              bankSet.erase(word);\n              q.push(word);\n            }\n          }\n          word[j] = cache;\n        }\n      }\n    }\n\n    return -1;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "434. Number of Segments in a String",
      "code": "class Solution {\n public:\n  int countSegments(string s) {\n    int ans = 0;\n\n    for (int i = 0; i < s.length(); ++i)\n      if (s[i] != ' ' && (i == 0 || s[i - 1] == ' '))\n        ++ans;\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "435. Non-overlapping Intervals",
      "code": "class Solution {\n public:\n  int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n    if (intervals.empty())\n      return 0;\n\n    sort(begin(intervals), end(intervals),\n         [](const auto& a, const auto& b) { return a[1] < b[1]; });\n\n    int ans = 0;\n    int currentEnd = intervals[0][1];\n\n    for (int i = 1; i < intervals.size(); ++i)\n      if (intervals[i][0] >= currentEnd)\n        currentEnd = intervals[i][1];\n      else\n        ++ans;\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "436. Find Right Interval",
      "code": "class Solution {\n public:\n  vector<int> findRightInterval(vector<vector<int>>& intervals) {\n    vector<int> ans;\n    map<int, int> startToIndex;\n\n    for (int i = 0; i < intervals.size(); ++i)\n      startToIndex[intervals[i][0]] = i;\n\n    for (const vector<int>& interval : intervals) {\n      const auto it = startToIndex.lower_bound(interval[1]);\n      if (it == cend(startToIndex))\n        ans.push_back(-1);\n      else\n        ans.push_back(it->second);\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "437. Path Sum III",
      "code": "class Solution {\n public:\n  int pathSum(TreeNode* root, int sum) {\n    if (root == nullptr)\n      return 0;\n    return dfs(root, sum) +\n           pathSum(root->left, sum) +\n           pathSum(root->right, sum);\n  }\n\n private:\n  int dfs(TreeNode* root, int sum) {\n    if (root == nullptr)\n      return 0;\n    return (sum == root->val) +\n           dfs(root->left, sum - root->val) +\n           dfs(root->right, sum - root->val);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "438. Find All Anagrams in a String",
      "code": "class Solution {\n public:\n  vector<int> findAnagrams(string s, string p) {\n    vector<int> ans;\n    vector<int> count(128);\n    int required = p.length();\n\n    for (const char c : p)\n      ++count[c];\n\n    for (int l = 0, r = 0; r < s.length(); ++r) {\n      if (--count[s[r]] >= 0)\n        --required;\n      while (required == 0) {\n        if (r - l + 1 == p.length())\n          ans.push_back(l);\n        if (++count[s[l++]] > 0)\n          ++required;\n      }\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "439. Ternary Expression Parser",
      "code": "class Solution {\n public:\n  string parseTernary(string expression) {\n    const char c = expression[i];\n\n    if (i + 1 == expression.length() || expression[i + 1] == ':') {\n      i += 2;  // Skip ':'\n      return string(1, c);\n    }\n\n    i += 2;  // Skip '?'\n    const string& first = parseTernary(expression);\n    const string& second = parseTernary(expression);\n    return c == 'T' ? first : second;\n  }\n\n private:\n  int i = 0;\n};\n"
    }
  ],
  [
    {
      "id": "440. K-th Smallest in Lexicographical Order",
      "code": "class Solution {\n public:\n  int findKthNumber(long n, int k) {\n    auto getGap = [&n](long a, long b) {\n      long gap = 0;\n      while (a <= n) {\n        gap += min(n + 1, b) - a;\n        a *= 10;\n        b *= 10;\n      }\n      return gap;\n    };\n\n    long currNum = 1;\n\n    for (int i = 1; i < k;) {\n      long gap = getGap(currNum, currNum + 1);\n      if (i + gap <= k) {\n        i += gap;\n        ++currNum;\n      } else {\n        ++i;\n        currNum *= 10;\n      }\n    }\n\n    return currNum;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "441. Arranging Coins",
      "code": "class Solution {\n public:\n  int arrangeCoins(long n) {\n    return (-1 + sqrt(8 * n + 1)) / 2;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "442. Find All Duplicates in an Array",
      "code": "class Solution {\n public:\n  vector<int> findDuplicates(vector<int>& nums) {\n    vector<int> ans;\n\n    for (const int num : nums) {\n      nums[abs(num) - 1] *= -1;\n      if (nums[abs(num) - 1] > 0)\n        ans.push_back(abs(num));\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "443. String Compression",
      "code": "class Solution {\n public:\n  int compress(vector<char>& chars) {\n    int ans = 0;\n\n    for (int i = 0; i < chars.size();) {\n      const char letter = chars[i];\n      int count = 0;\n      while (i < chars.size() && chars[i] == letter) {\n        ++count;\n        ++i;\n      }\n      chars[ans++] = letter;\n      if (count > 1)\n        for (const char c : to_string(count))\n          chars[ans++] = c;\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "444. Sequence Reconstruction",
      "code": "class Solution {\n public:\n  bool sequenceReconstruction(vector<int>& org, vector<vector<int>>& seqs) {\n    if (seqs.empty())\n      return false;\n\n    const int n = org.size();\n    vector<vector<int>> graph(n);\n    vector<int> inDegree(n);\n\n    // Build graph\n    for (const vector<int>& seq : seqs) {\n      if (seq.size() == 1 && seq[0] < 1 || seq[0] > n) {\n        return false;\n      } else {\n        for (int i = 0; i + 1 < seq.size(); ++i) {\n          const int u = seq[i];\n          const int v = seq[i + 1];\n          if (u < 1 || u > n || v < 1 || v > n)\n            return false;\n          graph[u - 1].push_back(v - 1);\n          ++inDegree[v - 1];\n        }\n      }\n    }\n\n    // Topology\n    queue<int> q;\n\n    for (int i = 0; i < n; ++i)\n      if (inDegree[i] == 0)\n        q.push(i);\n\n    int i = 0;  // org's index\n\n    while (!q.empty()) {\n      if (q.size() > 1)\n        return false;\n      const int u = q.front();\n      q.pop();\n      if (u != org[i] - 1)\n        return false;\n      ++i;\n      for (const int v : graph[u])\n        if (--inDegree[v] == 0)\n          q.push(v);\n    }\n\n    return i == n;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "445. Add Two Numbers II",
      "code": "class Solution {\n public:\n  ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n    stack<ListNode*> stack1;\n    stack<ListNode*> stack2;\n\n    while (l1) {\n      stack1.push(l1);\n      l1 = l1->next;\n    }\n\n    while (l2) {\n      stack2.push(l2);\n      l2 = l2->next;\n    }\n\n    ListNode* head = nullptr;\n    int carry = 0;\n\n    while (carry || !stack1.empty() || !stack2.empty()) {\n      if (!stack1.empty())\n        carry += stack1.top()->val, stack1.pop();\n      if (!stack2.empty())\n        carry += stack2.top()->val, stack2.pop();\n      ListNode* node = new ListNode(carry % 10);\n      node->next = head;\n      head = node;\n      carry /= 10;\n    }\n\n    return head;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "446. Arithmetic Slices II - Subsequence",
      "code": "class Solution {\n public:\n  int numberOfArithmeticSlices(vector<int>& nums) {\n    const int n = nums.size();\n    int ans = 0;\n    // dp[i][j] := # of subseqs end w/ nums[j] nums[i]\n    vector<vector<int>> dp(n, vector<int>(n));\n    unordered_map<long, vector<int>> numToIndices;\n\n    for (int i = 0; i < n; ++i)\n      numToIndices[nums[i]].push_back(i);\n\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < i; ++j) {\n        const long target = nums[j] * 2L - nums[i];\n        if (const auto it = numToIndices.find(target); it != cend(numToIndices))\n          for (const int k : it->second)\n            if (k < j)\n              dp[i][j] += (dp[j][k] + 1);\n        ans += dp[i][j];\n      }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "447. Number of Boomerangs",
      "code": "class Solution {\n public:\n  int numberOfBoomerangs(vector<vector<int>>& points) {\n    int ans = 0;\n\n    for (const vector<int>& p : points) {\n      unordered_map<int, int> distCount;\n      for (const vector<int>& q : points) {\n        const int dist = getDist(p, q);\n        ++distCount[dist];\n      }\n      for (const auto& [_, freq] : distCount)\n        ans += freq * (freq - 1);  // C(freq, 2)\n    }\n\n    return ans;\n  }\n\n private:\n  int getDist(const vector<int>& p, const vector<int>& q) {\n    return pow(p[0] - q[0], 2) + pow(p[1] - q[1], 2);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "448. Find All Numbers Disappeared in an Array",
      "code": "class Solution {\n public:\n  vector<int> findDisappearedNumbers(vector<int>& nums) {\n    vector<int> ans;\n\n    for (const int num : nums) {\n      const int index = abs(num) - 1;\n      nums[index] = -abs(nums[index]);\n    }\n\n    for (int i = 0; i < nums.size(); ++i)\n      if (nums[i] > 0)\n        ans.push_back(i + 1);\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "449. Serialize and Deserialize BST",
      "code": "class Codec {\n public:\n  string serialize(TreeNode* root) {\n    if (root == nullptr)\n      return \"\";\n\n    string s;\n\n    serialize(root, s);\n    return s;\n  }\n\n  TreeNode* deserialize(string data) {\n    if (data.empty())\n      return nullptr;\n\n    istringstream iss(data);\n    queue<int> q;\n\n    for (string s; iss >> s;)\n      q.push(stoi(s));\n\n    return deserialize(INT_MIN, INT_MAX, q);\n  }\n\n private:\n  void serialize(TreeNode* root, string& s) {\n    if (root == nullptr)\n      return;\n\n    s += to_string(root->val) + \" \";\n    serialize(root->left, s);\n    serialize(root->right, s);\n  }\n\n  TreeNode* deserialize(int min, int max, queue<int>& q) {\n    if (q.empty())\n      return nullptr;\n\n    const int val = q.front();\n    if (val < min || val > max)\n      return nullptr;\n\n    q.pop();\n    TreeNode* root = new TreeNode(val);\n    root->left = deserialize(min, val, q);\n    root->right = deserialize(val, max, q);\n    return root;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "450. Delete Node in a BST",
      "code": "class Solution {\n public:\n  TreeNode* deleteNode(TreeNode* root, int key) {\n    if (root == nullptr)\n      return nullptr;\n    if (root->val == key) {\n      if (root->left == nullptr)\n        return root->right;\n      if (root->right == nullptr)\n        return root->left;\n      TreeNode* minNode = getMin(root->right);\n      root->right = deleteNode(root->right, minNode->val);\n      minNode->left = root->left;\n      minNode->right = root->right;\n      root = minNode;\n    } else if (root->val < key) {\n      root->right = deleteNode(root->right, key);\n    } else {\n      root->val > key root->left = deleteNode(root->left, key);\n    }\n    return root;\n  }\n\n private:\n  TreeNode* getMin(TreeNode* node) {\n    while (node->left)\n      node = node->left;\n    return node;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "451. Sort Characters By Frequency",
      "code": "class Solution {\n public:\n  string frequencySort(string s) {\n    const int n = s.length();\n    string ans;\n    vector<int> count(128);\n    // bucket[i] := stores chars that appear i times in s\n    vector<vector<char>> bucket(n + 1);\n\n    for (const char c : s)\n      ++count[c];\n\n    for (int i = 0; i < 128; ++i) {\n      const int freq = count[i];\n      if (freq > 0)\n        bucket[freq].push_back((char)i);\n    }\n\n    for (int freq = n; freq > 0; --freq)\n      for (const char c : bucket[freq])\n        ans += string(freq, c);\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "452. Minimum Number of Arrows to Burst Balloons",
      "code": "class Solution {\n public:\n  int findMinArrowShots(vector<vector<int>>& points) {\n    sort(begin(points), end(points),\n         [](const auto& a, const auto& b) { return a[1] < b[1]; });\n\n    int ans = 1;\n    int arrowX = points[0][1];\n\n    for (int i = 1; i < points.size(); ++i)\n      if (points[i][0] > arrowX) {\n        arrowX = points[i][1];\n        ++ans;\n      }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "453. Minimum Moves to Equal Array Elements",
      "code": "class Solution {\n public:\n  int minMoves(vector<int>& nums) {\n    const int min = *min_element(begin(nums), end(nums));\n    return accumulate(begin(nums), end(nums), 0,\n                      [&](int a, int b) { return a + (b - min); });\n  }\n };\n"
    }
  ],
  [
    {
      "id": "454. 4Sum II",
      "code": "class Solution {\n public:\n  int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3,\n                   vector<int>& nums4) {\n    int ans = 0;\n    unordered_map<int, int> count;\n\n    for (const int a : nums1)\n      for (const int b : nums2)\n        ++count[a + b];\n\n    for (const int c : nums3)\n      for (const int d : nums4)\n        if (const auto it = count.find(-c - d); it != cend(count))\n          ans += it->second;\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "455. Assign Cookies",
      "code": "class Solution {\n public:\n  int findContentChildren(vector<int>& g, vector<int>& s) {\n    sort(begin(g), end(g));\n    sort(begin(s), end(s));\n\n    int i = 0;\n    for (int j = 0; j < s.size() && i < g.size(); ++j)\n      if (g[i] <= s[j])\n        ++i;\n\n    return i;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "456. 132 Pattern",
      "code": "class Solution {\n public:\n  bool find132pattern(vector<int>& nums) {\n    stack<int> stack;  // Max stack\n    int ak = INT_MIN;  // We want to find a seq ai < ak < aj\n\n    for (int i = nums.size() - 1; i >= 0; --i) {\n      // Ai < ak, we're done because ai must also smaller than aj\n      if (nums[i] < ak)\n        return true;\n      while (!stack.empty() && stack.top() < nums[i])\n        ak = stack.top(), stack.pop();\n      stack.push(nums[i]);  // nums[i] is a candidate of aj\n    }\n\n    return false;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "457. Circular Array Loop",
      "code": "class Solution {\n public:\n  bool circularArrayLoop(vector<int>& nums) {\n    const int n = nums.size();\n    if (n < 2)\n      return false;\n\n    auto advance = [&](int i) {\n      const int val = (i + nums[i]) % n;\n      return i + nums[i] >= 0 ? val : n + val;\n    };\n\n    for (int i = 0; i < n; ++i) {\n      if (nums[i] == 0)\n        continue;\n      int slow = i;\n      int fast = advance(slow);\n      while (nums[i] * nums[fast] > 0 && nums[i] * nums[advance(fast)] > 0) {\n        if (slow == fast) {\n          if (slow == advance(slow))\n            break;\n          return true;\n        }\n        slow = advance(slow);\n        fast = advance(advance(fast));\n      }\n\n      slow = i;\n      const int sign = nums[i];\n      while (sign * nums[slow] > 0) {\n        const int next = advance(slow);\n        nums[slow] = 0;\n        slow = next;\n      }\n    }\n\n    return false;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "458. Poor Pigs",
      "code": "class Solution {\n public:\n  int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\n    return ceil(log(buckets) / log(minutesToTest / minutesToDie + 1));\n  }\n };\n"
    }
  ],
  [
    {
      "id": "459. Repeated Substring Pattern",
      "code": "class Solution {\n public:\n  bool repeatedSubstringPattern(string s) {\n    const string ss = s + s;\n    return ss.substr(1, ss.length() - 2).find(s) != string::npos;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "460. LFU Cache",
      "code": "struct Node {\n  int key;\n  int value;\n  int freq;\n  list<int>::const_iterator it;\n};\n\n class LFUCache {\n public:\n  LFUCache(int capacity) : capacity(capacity), minFreq(0) {}\n\n  int get(int key) {\n    const auto it = keyToNode.find(key);\n    if (it == cend(keyToNode))\n      return -1;\n\n    Node& node = it->second;\n    touch(node);\n    return node.value;\n  }\n\n  void put(int key, int value) {\n    if (capacity == 0)\n      return;\n    if (const auto it = keyToNode.find(key); it != cend(keyToNode)) {\n      Node& node = it->second;\n      node.value = value;\n      touch(node);\n      return;\n    }\n\n    if (keyToNode.size() == capacity) {\n      // Evict LRU key from the minFreq list\n      const int keyToEvict = freqToList[minFreq].back();\n      freqToList[minFreq].pop_back();\n      keyToNode.erase(keyToEvict);\n    }\n\n    minFreq = 1;\n    freqToList[1].push_front(key);\n    keyToNode[key] = {key, value, 1, cbegin(freqToList[1])};\n  }\n\n private:\n  int capacity;\n  int minFreq;\n  unordered_map<int, Node> keyToNode;\n  unordered_map<int, list<int>> freqToList;\n\n  void touch(Node& node) {\n    // Update the node's frequency\n    const int prevFreq = node.freq;\n    const int newFreq = ++node.freq;\n\n    // Remove the iterator from prevFreq's list\n    freqToList[prevFreq].erase(node.it);\n    if (freqToList[prevFreq].empty()) {\n      freqToList.erase(prevFreq);\n      // Update minFreq if needed\n      if (prevFreq == minFreq)\n        ++minFreq;\n    }\n\n    // Insert the key to the front of newFreq's list\n    freqToList[newFreq].push_front(node.key);\n    node.it = cbegin(freqToList[newFreq]);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "461. Hamming Distance",
      "code": "class Solution {\n public:\n  int hammingDistance(int x, int y) {\n    int ans = 0;\n\n    while (x || y) {\n      ans += (x & 1) ^ (y & 1);\n      x >>= 1;\n      y >>= 1;\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "462. Minimum Moves to Equal Array Elements II",
      "code": "class Solution {\n public:\n  int minMoves2(vector<int>& nums) {\n    const int n = nums.size();\n    nth_element(begin(nums), begin(nums) + n / 2, end(nums));\n    const int median = nums[n / 2];\n    return accumulate(begin(nums), end(nums), 0,\n                      [&](int a, int b) { return a + abs(b - median); });\n  }\n };\n"
    }
  ],
  [
    {
      "id": "463. Island Perimeter",
      "code": "class Solution {\n public:\n  int islandPerimeter(vector<vector<int>>& grid) {\n    int islands = 0;\n    int neighbors = 0;\n\n    for (int i = 0; i < grid.size(); ++i)\n      for (int j = 0; j < grid[0].size(); ++j)\n        if (grid[i][j]) {\n          ++islands;\n          if (i - 1 >= 0 && grid[i - 1][j])\n            ++neighbors;\n          if (j - 1 >= 0 && grid[i][j - 1])\n            ++neighbors;\n        }\n\n    return islands * 4 - neighbors * 2;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "464. Can I Win",
      "code": "class Solution {\n public:\n  bool canIWin(int maxChoosableInteger, int desiredTotal) {\n    if (desiredTotal <= 0)\n      return true;\n\n    const int sum = maxChoosableInteger * (maxChoosableInteger + 1) / 2;\n    if (sum < desiredTotal)\n      return false;\n\n    return dp(desiredTotal, 0, maxChoosableInteger);\n  }\n\n private:\n  unordered_map<int, bool> memo;  // true: can win, false: can't win\n\n  // state: record integers that have been chosen\n  bool dp(int total, int state, int n) {\n    if (total <= 0)\n      return false;\n    if (const auto it = memo.find(state); it != cend(memo))\n      return it->second;\n\n    for (int i = 1; i <= n; ++i) {\n      if (state & 1 << i)  // Integer i is used\n        continue;\n      if (!dp(total - i, state | 1 << i, n))\n        return true;\n    }\n\n    return memo[state] = false;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "465. Optimal Account Balancing",
      "code": "class Solution {\n public:\n  int minTransfers(vector<vector<int>>& transactions) {\n    vector<int> balance(21);\n    vector<int> debt;\n\n    for (const vector<int>& t : transactions) {\n      const int from = t[0];\n      const int to = t[1];\n      const int amount = t[2];\n      balance[from] -= amount;\n      balance[to] += amount;\n    }\n\n    for (const int b : balance)\n      if (b > 0)\n        debt.push_back(b);\n\n    return dfs(debt, 0);\n  }\n\n private:\n  int dfs(vector<int>& debt, int s) {\n    while (s < debt.size() && !debt[s])\n      ++s;\n    if (s == debt.size())\n      return 0;\n\n    int ans = INT_MAX;\n\n    for (int i = s + 1; i < debt.size(); ++i)\n      if (debt[i] * debt[s] < 0) {\n        debt[i] += debt[s];  // debt[s] is settled\n        ans = min(ans, 1 + dfs(debt, s + 1));\n        debt[i] -= debt[s];  // Backtrack\n      }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "466. Count The Repetitions",
      "code": "struct Record {\n  int count;\n  int nextIndex;\n  Record(int count, int nextIndex) : count(count), nextIndex(nextIndex) {}\n };\n\n class Solution {\n public:\n  int getMaxRepetitions(string s1, int n1, string s2, int n2) {\n    vector<Record> records;  // [count(s1 matches s2[i:]), next index of s2[i:]]\n\n    for (int i = 0; i < s2.length(); ++i) {\n      int count = 0;\n      int nextIndex = i;\n      for (int j = 0; j < s1.length(); ++j)\n        if (s2[nextIndex] == s1[j])\n          if (++nextIndex == s2.length()) {  // Have a match\n            ++count;\n            nextIndex = 0;\n          }\n      records.emplace_back(count, nextIndex);\n    }\n\n    int matches = 0;  // S1 matches s2\n    int index = 0;\n\n    while (n1--) {\n      matches += records[index].count;\n      index = records[index].nextIndex;\n    }\n\n    return matches / n2;  // S1 matches S2\n  }\n };\n"
    }
  ],
  [
    {
      "id": "467. Unique Substrings in Wraparound String",
      "code": "class Solution {\n public:\n  int findSubstringInWraproundString(string p) {\n    int maxLength = 1;\n    vector<int> count(26);  // Substrings end at i\n\n    for (int i = 0; i < p.length(); ++i) {\n      if (i > 0 && (p[i] - p[i - 1] == 1 || p[i - 1] - p[i] == 25))\n        ++maxLength;\n      else\n        maxLength = 1;\n      const int index = p[i] - 'a';\n      count[index] = max(count[index], maxLength);\n    }\n\n    return accumulate(begin(count), end(count), 0);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "468. Validate IP Address",
      "code": "class Solution {\n public:\n  string validIPAddress(string IP) {\n    string digit;\n    istringstream iss(IP);\n\n    if (count(begin(IP), end(IP), '.') == 3) {\n      for (int i = 0; i < 4; ++i)  // Make sure we have 4 parts\n        if (!getline(iss, digit, '.') || !isIPv4(digit))\n          return \"Neither\";\n      return \"IPv4\";\n    }\n\n    if (count(begin(IP), end(IP), ':') == 7) {\n      for (int i = 0; i < 8; ++i)  // Make sure we have 8 parts\n        if (!getline(iss, digit, ':') || !isIPv6(digit))\n          return \"Neither\";\n      return \"IPv6\";\n    }\n\n    return \"Neither\";\n  }\n\n private:\n  static inline string validIPv6Chars = \"0123456789abcdefABCDEF\";\n\n  bool isIPv4(const string& digit) {\n    if (digit.empty() || digit.length() > 3)\n      return false;\n    if (digit.length() > 1 && digit[0] == '0')\n      return false;\n\n    for (const char c : digit)\n      if (c < '0' || c > '9')\n        return false;\n\n    const int num = stoi(digit);\n    return 0 <= num && num <= 255;\n  }\n\n  bool isIPv6(const string& digit) {\n    if (digit.empty() || digit.length() > 4)\n      return false;\n\n    for (const char c : digit)\n      if (validIPv6Chars.find(c) == string::npos)\n        return false;\n\n    return true;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "469. Convex Polygon",
      "code": "class Solution {\n public:\n  bool isConvex(vector<vector<int>>& points) {\n    auto getCross = [](const vector<int>& p, const vector<int>& q, const vector<int>& r) -> int {\n      return (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0]);\n    };\n\n    const int n = points.size();\n    long sign = 0;\n\n    for (int i = 0; i < points.size(); ++i) {\n      const int cross = getCross(points[i], points[(i + 1) % n], points[(i + 2) % n]);\n      if (cross == 0)  // P, q, r are collinear\n        continue;\n      if (sign == 0)  // Find first cross that's not 0\n        sign = cross;\n      else if (cross * sign < 0)\n        return false;\n    }\n\n    return true;\n  }\n };\n"
    }
  ],
  null,
  [
    {
      "id": "471. Encode String with Shortest Length",
      "code": "class Solution {\n public:\n  string encode(string s) {\n    const int n = s.length();\n    // dp[i][j] := shortest encoded string of s[i..j]\n    dp.resize(n, vector<string>(n));\n    return encode(s, 0, n - 1);\n  }\n\n private:\n  vector<vector<string>> dp;\n\n  string encode(const string& s, int i, int j) {\n    if (!dp[i][j].empty())\n      return dp[i][j];\n\n    const string& curr = s.substr(i, j - i + 1);\n    dp[i][j] = curr;\n\n    if (dp[i][j].length() < 5)\n      return dp[i][j];\n\n    // Try all possible partitions\n    for (int k = i; k < j; ++k) {\n      const string& l = encode(s, i, k);\n      const string& r = encode(s, k + 1, j);\n      if (l.length() + r.length() < dp[i][j].length())\n        dp[i][j] = l + r;\n    }\n\n    // Try to compress the string\n    // E.g. s = aabaabaab -> 3[aab]\n    for (int k = i; k <= j; ++k) {\n      const string& pattern = s.substr(i, k - i + 1);\n      if (curr.length() % pattern.length() == 0 &&\n          regex_replace(curr, regex(pattern), \"\").empty()) {\n        const string& candidate = to_string(curr.length() / pattern.length()) +\n                                  '[' + encode(s, i, k) + ']';\n        if (candidate.length() < dp[i][j].length())\n          dp[i][j] = candidate;\n      }\n    }\n\n    return dp[i][j];\n  }\n };\n"
    }
  ],
  [
    {
      "id": "472. Concatenated Words",
      "code": "class Solution {\n public:\n  vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\n    vector<string> ans;\n    unordered_set<string> wordSet{begin(words), end(words)};\n    unordered_map<string, bool> memo;\n\n    for (const string& word : words)\n      if (isConcat(word, wordSet, memo))\n        ans.push_back(word);\n\n    return ans;\n  }\n\n private:\n  bool isConcat(const string& s, const unordered_set<string>& wordSet,\n                unordered_map<string, bool>& memo) {\n    if (const auto it = memo.find(s); it != cend(memo))\n      return it->second;\n\n    for (int i = 1; i < s.length(); ++i) {\n      const string prefix = s.substr(0, i);\n      const string suffix = s.substr(i);\n      if (wordSet.count(prefix) &&\n          (wordSet.count(suffix) || isConcat(suffix, wordSet, memo)))\n        return memo[s] = true;\n    }\n\n    return memo[s] = false;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "473. Matchsticks to Square",
      "code": "class Solution {\n public:\n  bool makesquare(vector<int>& matchsticks) {\n    if (matchsticks.size() < 4)\n      return false;\n\n    const int perimeter = accumulate(begin(matchsticks), end(matchsticks), 0);\n    if (perimeter % 4 != 0)\n      return false;\n\n    sort(begin(matchsticks), end(matchsticks), greater<int>());\n    return dfs(matchsticks, 0, vector<int>(4, perimeter / 4));\n  }\n\n private:\n  bool dfs(const vector<int>& matchsticks, int selected, vector<int>&& edges) {\n    if (selected == matchsticks.size())\n      return all_of(begin(edges), end(edges),\n                    [](int edge) { return edge == 0; });\n\n    for (int i = 0; i < 4; ++i) {\n      if (matchsticks[selected] > edges[i])\n        continue;\n      edges[i] -= matchsticks[selected];\n      if (dfs(matchsticks, selected + 1, move(edges)))\n        return true;\n      edges[i] += matchsticks[selected];\n    }\n\n    return false;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "474. Ones and Zeroes",
      "code": "class Solution {\n public:\n  int findMaxForm(vector<string>& strs, int m, int n) {\n    // dp[i][j] := max size of the subset given i 0's and j 1's are available\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1));\n\n    for (const string& s : strs) {\n      const int count0 = count(begin(s), end(s), '0');\n      const int count1 = s.length() - count0;\n      for (int i = m; i >= count0; --i)\n        for (int j = n; j >= count1; --j)\n          dp[i][j] = max(dp[i][j], dp[i - count0][j - count1] + 1);\n    }\n\n    return dp[m][n];\n  }\n };\n"
    }
  ],
  [
    {
      "id": "475. Heaters",
      "code": "class Solution {\n public:\n  int findRadius(vector<int>& houses, vector<int>& heaters) {\n    sort(begin(houses), end(houses));\n    sort(begin(heaters), end(heaters));\n\n    int ans = 0;\n    int i = 0;  // Point to the heater that currently used\n\n    for (const int house : houses) {\n      while (i + 1 < heaters.size() &&\n             house - heaters[i] > heaters[i + 1] - house)\n        ++i;  // Next heater is better\n      ans = max(ans, abs(heaters[i] - house));\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "476. Number Complement",
      "code": "class Solution {\n public:\n  int findComplement(long num) {\n    for (long i = 1; i <= num; i <<= 1)\n      num ^= i;\n    return num;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "477. Total Hamming Distance",
      "code": "class Solution {\n public:\n  int totalHammingDistance(vector<int>& nums) {\n    int ans = 0;\n    int mask = 1;\n\n    for (int i = 0; i < 30; ++i) {\n      const int onesCount = count_if(begin(nums), end(nums),\n                                     [&mask](int num) { return num & mask; });\n      const int zerosCount = nums.size() - onesCount;\n      ans += onesCount * zerosCount;\n      mask <<= 1;\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "478. Generate Random Point in a Circle",
      "code": "class Solution {\n public:\n  Solution(double radius, double x_center, double y_center)\n      : radius(radius), x_center(x_center), y_center(y_center) {}\n\n  vector<double> randPoint() {\n    const double length = sqrt(distribution(generator)) * radius;\n    const double degree = distribution(generator) * 2 * M_PI;\n    const double x = x_center + length * cos(degree);\n    const double y = y_center + length * sin(degree);\n    return {x, y};\n  }\n\n private:\n  const double radius;\n  const double x_center;\n  const double y_center;\n  default_random_engine generator;\n  uniform_real_distribution<double> distribution =\n      uniform_real_distribution<double>(0.0, 1.0);\n};\n"
    }
  ],
  [
    {
      "id": "479. Largest Palindrome Product",
      "code": "class Solution {\n public:\n  int largestPalindrome(int n) {\n    if (n == 1)\n      return 9;\n\n    constexpr int kMod = 1337;\n    const int upper = pow(10, n) - 1;\n    const int lower = pow(10, n - 1) - 1;\n\n    for (int i = upper; i > lower; --i) {\n      const long cand = getPalindromeCandidate(i);\n      for (long j = upper; j * j >= cand; --j)\n        if (cand % j == 0)\n          return cand % kMod;\n    }\n\n    throw;\n  }\n\n private:\n  long getPalindromeCandidate(int i) {\n    string reversed = to_string(i);\n    reverse(begin(reversed), end(reversed));\n    return stol(to_string(i) + reversed);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "480. Sliding Window Median",
      "code": "class Solution {\n public:\n  vector<double> medianSlidingWindow(vector<int>& nums, int k) {\n    vector<double> ans;\n    multiset<double> window(begin(nums), begin(nums) + k);\n    auto it = next(begin(window), (k - 1) / 2);\n\n    for (int i = k;; ++i) {\n      const double median = k & 1 ? *it : (*it + *next(it)) / 2.0;\n      ans.push_back(median);\n      if (i == nums.size())\n        break;\n      window.insert(nums[i]);\n      if (nums[i] < *it)\n        --it;\n      if (nums[i - k] <= *it)\n        ++it;\n      window.erase(window.lower_bound(nums[i - k]));\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "481. Magical String",
      "code": "class Solution {\n public:\n  int magicalString(int n) {\n    string s = \" 122\";\n\n    for (int i = 3; i <= n; ++i)\n      if (i & 1)\n        s.append(s[i] - '0', '1');\n      else\n        s.append(s[i] - '0', '2');\n\n    return count(begin(s), begin(s) + n + 1, '1');\n  }\n };\n"
    }
  ],
  [
    {
      "id": "482. License Key Formatting",
      "code": "class Solution {\n public:\n  string licenseKeyFormatting(string s, int k) {\n    string ans;\n    int length = 0;\n\n    for (int i = s.length() - 1; i >= 0; --i) {\n      if (s[i] == '-')\n        continue;\n      if (length > 0 && length % k == 0)\n        ans += \"-\";\n      ans += toupper(s[i]);\n      ++length;\n    }\n\n    return {rbegin(ans), rend(ans)};\n  }\n };\n"
    }
  ],
  [
    {
      "id": "483. Smallest Good Base",
      "code": "class Solution {\n public:\n  string smallestGoodBase(string n) {\n    const long num = stol(n);\n\n    for (int m = log2(num); m >= 2; --m) {\n      const int k = pow(num, 1.0 / m);\n      long sum = 1;\n      long prod = 1;\n      for (int i = 0; i < m; ++i) {\n        prod *= k;\n        sum += prod;\n      }\n      if (sum == num)\n        return to_string(k);\n    }\n\n    return to_string(num - 1);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "484. Find Permutation",
      "code": "class Solution {\n public:\n  vector<int> findPermutation(string s) {\n    vector<int> ans;\n    stack<int> stack;\n\n    for (int i = 0; i < s.length(); ++i) {\n      stack.push(i + 1);\n      if (s[i] == 'I')\n        while (!stack.empty())\n          ans.push_back(stack.top()), stack.pop();\n    }\n    stack.push(s.length() + 1);\n\n    while (!stack.empty())\n      ans.push_back(stack.top()), stack.pop();\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "485. Max Consecutive Ones",
      "code": "class Solution {\n public:\n  int findMaxConsecutiveOnes(vector<int>& nums) {\n    int ans = 0;\n    int sum = 0;\n\n    for (const int num : nums)\n      if (num == 1)\n        ans = max(ans, ++sum);\n      else\n        sum = 0;\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "486. Predict the Winner",
      "code": "class Solution {\n public:\n  bool PredictTheWinner(vector<int>& nums) {\n    const int n = nums.size();\n    // dp[i][j] := max number you can get more than your opponent in nums[i..j]\n    vector<vector<int>> dp(n, vector<int>(n));\n\n    for (int i = 0; i < n; ++i)\n      dp[i][i] = nums[i];\n\n    for (int d = 1; d < n; ++d)\n      for (int i = 0; i + d < n; ++i) {\n        const int j = i + d;\n        dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);\n      }\n\n    return dp[0][n - 1] >= 0;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "487. Max Consecutive Ones II",
      "code": "class Solution {\n public:\n  int findMaxConsecutiveOnes(vector<int>& nums) {\n    int ans = 0;\n    int zeros = 0;\n\n    for (int l = 0, r = 0; r < nums.size(); ++r) {\n      if (nums[r] == 0)\n        ++zeros;\n      while (zeros == 2)\n        if (nums[l++] == 0)\n          --zeros;\n      ans = max(ans, r - l + 1);\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "488. Zuma Game",
      "code": "class Solution {\n public:\n  int findMinStep(string board, string hand) {\n    const int ans = dfs(board + \"#\", hand, {});\n    return ans == INT_MAX ? -1 : ans;\n  }\n\n private:\n  int dfs(string&& board, const string& hand,\n          unordered_map<string, int>&& memo) {\n    const string& hashKey = board + '#' + hand;\n    if (const auto it = memo.find(hashKey); it != cend(memo))\n      return it->second;\n    board = deDup(board);\n    if (board == \"#\")\n      return 0;\n\n    unordered_set<char> boardSet = unordered_set(begin(board), end(board));\n\n    string hs;  // Hand that in board\n    for (const char h : hand)\n      if (boardSet.count(h))\n        hs += h;\n    if (hs.empty())  // Infeasible\n      return INT_MAX;\n\n    int ans = INT_MAX;\n\n    for (int i = 0; i < board.size(); ++i)\n      for (int j = 0; j < hs.size(); ++j) {\n        // Place hs[j] in board[i]\n        const string& newHand = hs.substr(0, j) + hs.substr(j + 1);\n        string newBoard = board.substr(0, i) + hs[j] + board.substr(i);\n        const int res = dfs(move(newBoard), newHand, move(memo));\n        if (res < INT_MAX)\n          ans = min(ans, 1 + res);\n      }\n\n    return memo[hashKey] = ans;\n  }\n\n  string deDup(string board) {\n    int start = 0;  // Start index of a color sequenece\n    for (int i = 0; i < board.size(); ++i)\n      if (board[i] != board[start]) {\n        if (i - start >= 3)\n          return deDup(board.substr(0, start) + board.substr(i));\n        start = i;  // Meet a new sequence\n      }\n    return board;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "489. Robot Room Cleaner",
      "code": "/**\n * // This is the robot's control interface.\n * // You should not implement it, or speculate about its implementation\n * class Robot {\n *  public:\n *   // Returns true if the cell in front is open and robot moves into the cell.\n *   // Returns false if the cell in front is blocked and robot stays in the\n *   // Current cell. bool move();\n *\n *   // Robot will stay in the same cell after calling turnLeft/turnRight.\n *   // Each turn will be 90 degrees.\n *   void turnLeft();\n *   void turnRight();\n *\n *   // Clean the current cell.\n *   void clean();\n * };\n */\n\n class Solution {\n public:\n  void cleanRoom(Robot& robot) {\n    dfs(robot, 0, 0, 0, unordered_set<pair<int, int>, pairHash>());\n  }\n\n private:\n  const vector<int> dirs{0, 1, 0, -1, 0};\n\n  struct pairHash {\n    size_t operator()(const pair<int, int>& p) const {\n      return p.first ^ p.second;\n    }\n  };\n\n  void dfs(Robot& robot, int i, int j, int d,\n           unordered_set<pair<int, int>, pairHash>&& seen) {\n    seen.insert({i, j});\n    robot.clean();\n\n    // Explore clockwise: 0: ^, 1: >, 2: v, 3: <\n    // The order is important since the idea is always turn right\n    for (int k = 0; k < 4; ++k) {\n      const int newD = (d + k) % 4;\n      const int x = i + dirs[newD];\n      const int y = j + dirs[newD + 1];\n      if (!seen.count({x, y}) && robot.move()) {\n        dfs(robot, x, y, newD, move(seen));\n        // Go back to the previous cell\n        robot.turnRight();\n        robot.turnRight();\n        robot.move();\n        // Go back to the original direction\n        robot.turnRight();\n        robot.turnRight();\n      }\n      robot.turnRight();  // Always turn the robot clockwise\n    }\n  }\n };\n"
    }
  ],
  [
    {
      "id": "490. The Maze",
      "code": "class Solution {\n public:\n  bool hasPath(vector<vector<int>>& maze, vector<int>& start,\n               vector<int>& destination) {\n    const int m = maze.size();\n    const int n = maze[0].size();\n    const vector<int> dirs{0, 1, 0, -1, 0};\n    queue<pair<int, int>> q{{{start[0], start[1]}}};\n    vector<vector<bool>> seen(m, vector<bool>(n));\n    seen[start[0]][start[1]] = true;\n\n    while (!q.empty()) {\n      const auto [i, j] = q.front();\n      q.pop();\n      for (int k = 0; k < 4; ++k) {\n        int x = i;\n        int y = j;\n        while (isValid(maze, x + dirs[k], y + dirs[k + 1])) {\n          x += dirs[k];\n          y += dirs[k + 1];\n        }\n        if (x == destination[0] && y == destination[1])\n          return true;\n        if (seen[x][y])\n          continue;\n        q.emplace(x, y);\n        seen[x][y] = true;\n      }\n    }\n\n    return false;\n  }\n\n private:\n  bool isValid(const vector<vector<int>>& maze, int x, int y) {\n    return 0 <= x && x < maze.size() && 0 <= y && y < maze[0].size() &&\n           maze[x][y] == 0;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "491. Non-decreasing Subsequences",
      "code": "class Solution {\n public:\n  vector<vector<int>> findSubsequences(vector<int>& nums) {\n    vector<vector<int>> ans;\n    dfs(nums, 0, {}, ans);\n    return ans;\n  }\n\n private:\n  void dfs(const vector<int>& nums, int s, vector<int>&& path,\n           vector<vector<int>>& ans) {\n    if (path.size() > 1)\n      ans.push_back(path);\n\n    unordered_set<int> used;\n\n    for (int i = s; i < nums.size(); ++i) {\n      if (used.count(nums[i]))\n        continue;\n      if (path.empty() || nums[i] >= path.back()) {\n        used.insert(nums[i]);\n        path.push_back(nums[i]);\n        dfs(nums, i + 1, move(path), ans);\n        path.pop_back();\n      }\n    }\n  }\n };\n"
    }
  ],
  [
    {
      "id": "492. Construct the Rectangle",
      "code": "class Solution {\n public:\n  vector<int> constructRectangle(int area) {\n    int width = sqrt(area);\n\n    while (area % width)\n      --width;\n\n    return {area / width, width};\n  }\n };\n"
    }
  ],
  [
    {
      "id": "493. Reverse Pairs",
      "code": "class FenwickTree {\n public:\n  FenwickTree(int n) : sums(n + 1) {}\n\n  void update(int i, int delta) {\n    while (i < sums.size()) {\n      sums[i] += delta;\n      i += lowbit(i);\n    }\n  }\n\n  int get(int i) const {\n    int sum = 0;\n    while (i > 0) {\n      sum += sums[i];\n      i -= lowbit(i);\n    }\n    return sum;\n  }\n\n private:\n  vector<int> sums;\n\n  static inline int lowbit(int i) {\n    return i & -i;\n  }\n };\n\n class Solution {\n public:\n  int reversePairs(vector<int>& nums) {\n    int ans = 0;\n    unordered_map<long, int> ranks;\n    getRanks(nums, ranks);\n    FenwickTree tree(ranks.size());\n\n    for (int i = nums.size() - 1; i >= 0; --i) {\n      const long num = nums[i];\n      ans += tree.get(ranks[num] - 1);\n      tree.update(ranks[num * 2], 1);\n    }\n\n    return ans;\n  }\n\n private:\n  void getRanks(const vector<int>& nums, unordered_map<long, int>& ranks) {\n    set<long> sorted(begin(nums), end(nums));\n    for (const long num : nums)\n      sorted.insert(num * 2);\n    int rank = 0;\n    for (const long num : sorted)\n      ranks[num] = ++rank;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "494. Target Sum",
      "code": "class Solution {\n public:\n  int findTargetSumWays(vector<int>& nums, int target) {\n    const int sum = accumulate(begin(nums), end(nums), 0);\n    if (sum < abs(target) || (sum + target) & 1)\n      return 0;\n    return knapsack(nums, (sum + target) / 2);\n  }\n\n private:\n  int knapsack(const vector<int>& nums, int target) {\n    const int n = nums.size();\n    // dp[i][j] := # of ways to sum to j by nums[0..i)\n    vector<vector<int>> dp(n + 1, vector<int>(target + 1));\n    dp[0][0] = 1;\n\n    for (int i = 1; i <= n; ++i) {\n      const int num = nums[i - 1];\n      for (int j = 0; j <= target; ++j)\n        if (j < num)\n          dp[i][j] = dp[i - 1][j];\n        else\n          dp[i][j] = dp[i - 1][j] + dp[i - 1][j - num];\n    }\n\n    return dp[n][target];\n  }\n };\n"
    }
  ],
  [
    {
      "id": "495. Teemo Attacking",
      "code": "class Solution {\n public:\n  int findPoisonedDuration(vector<int>& timeSeries, int duration) {\n    if (duration == 0)\n      return 0;\n\n    int ans = 0;\n\n    for (int i = 0; i + 1 < timeSeries.size(); ++i)\n      ans += min(timeSeries[i + 1] - timeSeries[i], duration);\n\n    return ans + duration;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "496. Next Greater Element I",
      "code": "class Solution {\n public:\n  vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {\n    vector<int> ans;\n    unordered_map<int, int> numToNextGreater;\n    stack<int> stack;  // Decreasing stack\n\n    for (const int num : nums2) {\n      while (!stack.empty() && stack.top() < num)\n        numToNextGreater[stack.top()] = num, stack.pop();\n      stack.push(num);\n    }\n\n    for (const int num : nums1)\n      if (const auto it = numToNextGreater.find(num);\n          it != cend(numToNextGreater))\n        ans.push_back(it->second);\n      else\n        ans.push_back(-1);\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "497. Random Point in Non-overlapping Rectangles",
      "code": "class Solution {\n public:\n  Solution(vector<vector<int>>& rects) : rects(move(rects)) {\n    for (const vector<int>& r : this->rects)\n      areas.push_back(getArea(r));\n    partial_sum(begin(areas), end(areas), begin(areas));\n  }\n\n  vector<int> pick() {\n    const int target = rand() % areas.back();\n    const int index =\n        upper_bound(begin(areas), end(areas), target) - begin(areas);\n    const vector<int>& r = rects[index];\n    return {rand() % (r[2] - r[0] + 1) + r[0],\n            rand() % (r[3] - r[1] + 1) + r[1]};\n  }\n\n private:\n  const vector<vector<int>> rects;\n  vector<int> areas;\n\n  int getArea(const vector<int>& r) {\n    return (r[2] - r[0] + 1) * (r[3] - r[1] + 1);\n  }\n };\n"
    }
  ],
  [
    {
      "id": "498. Diagonal Traverse",
      "code": "class Solution {\n public:\n  vector<int> findDiagonalOrder(vector<vector<int>>& matrix) {\n    const int m = matrix.size();\n    const int n = matrix[0].size();\n    vector<int> ans(m * n);\n    int d = 1;  // Left-bottom -> right-top\n    int row = 0;\n    int col = 0;\n\n    for (int i = 0; i < m * n; ++i) {\n      ans[i] = matrix[row][col];\n      row -= d;\n      col += d;\n      // Out of bound\n      if (row == m)\n        row = m - 1, col += 2, d = -d;\n      if (col == n)\n        col = n - 1, row += 2, d = -d;\n      if (row < 0)\n        row = 0, d = -d;\n      if (col < 0)\n        col = 0, d = -d;\n    }\n\n    return ans;\n  }\n };\n"
    }
  ],
  [
    {
      "id": "499. The Maze III",
      "code": "class Solution {\n public:\n  string findShortestWay(vector<vector<int>>& maze, vector<int>& ball,\n                         vector<int>& hole) {\n    string ans = \"impossible\";\n    dfs(maze, ball[0], ball[1], hole, 0, 0, 0, INT_MAX, \"\", ans);\n    return ans;\n  }\n\n private:\n  void dfs(vector<vector<int>>& maze, int i, int j, const vector<int>& hole,\n           int dx, int dy, int steps, int&& minSteps, string&& path,\n           string& ans) {\n    if (steps >= minSteps)\n      return;\n\n    if (dx != 0 || dy != 0) {  // Both are zero for the initial ball position\n      while (i + dx >= 0 && i + dx < maze.size() && j + dy >= 0 &&\n             j + dy < maze[0].size() && maze[i + dx][j + dy] != 1) {\n        i += dx;\n        j += dy;\n        ++steps;\n        if (i == hole[0] && j == hole[1] && steps < minSteps) {\n          minSteps = steps;\n          ans = path;\n        }\n      }\n    }\n\n    if (maze[i][j] == 0 || steps + 2 < maze[i][j]) {\n      maze[i][j] = steps + 2;  // +2 to because of maze[i][j] == 0 || 1\n      if (dx == 0)\n        dfs(maze, i, j, hole, 1, 0, steps, move(minSteps), path + \"d\", ans);\n      if (dy == 0)\n        dfs(maze, i, j, hole, 0, -1, steps, move(minSteps), path + \"l\", ans);\n      if (dy == 0)\n        dfs(maze, i, j, hole, 0, 1, steps, move(minSteps), path + \"r\", ans);\n      if (dx == 0)\n        dfs(maze, i, j, hole, -1, 0, steps, move(minSteps), path + \"u\", ans);\n    }\n  }\n };\n"
    }
  ]
]
