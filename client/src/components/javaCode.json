[
  [
    {
      "id": "1. Two Sum",
      "code": "class Solution {\n  public int[] twoSum(int[] nums, int target) {\n    Map<Integer, Integer> numToIndex = new HashMap<>();\n\n    for (int i = 0; i < nums.length; ++i) {\n      if (numToIndex.containsKey(target - nums[i]))\n        return new int[] {numToIndex.get(target - nums[i]), i};\n      numToIndex.put(nums[i], i);\n    } \n\n    throw new IllegalArgumentException();\n  }\n }\n"
    }
  ],
  [
    {
      "id": "2. Add Two Numbers",
      "code": "class Solution {\n  public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n    ListNode dummy = new ListNode(0);\n    ListNode curr = dummy;\n    int carry = 0;\n\n    while (l1 != null || l2 != null || carry > 0) {\n      if (l1 != null) {\n        carry += l1.val;\n        l1 = l1.next;\n      }\n      if (l2 != null) {\n        carry += l2.val;\n        l2 = l2.next;\n      }\n      curr.next = new ListNode(carry % 10);\n      carry /= 10;\n      curr = curr.next;\n    } \n\n    return dummy.next;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "3. Longest Substring Without Repeating Characters",
      "code": "class Solution {\n  public int lengthOfLongestSubstring(String s) {\n    int ans = 0;\n    int[] count = new int[128];\n\n    for (int l = 0, r = 0; r < s.length(); ++r) {\n      ++count[s.charAt(r)];\n      while (count[s.charAt(r)] > 1)\n        --count[s.charAt(l++)];\n      ans = Math.max(ans, r - l + 1);\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "4. Median of Two Sorted Arrays",
      "code": "class Solution {\n  public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n    final int n1 = nums1.length;\n    final int n2 = nums2.length;\n    if (n1 > n2)\n      return findMedianSortedArrays(nums2, nums1);\n\n    int l = 0;\n    int r = n1;\n\n    while (l <= r) {\n      final int partition1 = (l + r) / 2;\n      final int partition2 = (n1 + n2 + 1) / 2 - partition1;\n      final int maxLeft1 = partition1 == 0 ? Integer.MIN_VALUE : nums1[partition1 - 1];\n      final int maxLeft2 = partition2 == 0 ? Integer.MIN_VALUE : nums2[partition2 - 1];\n      final int minRight1 = partition1 == n1 ? Integer.MAX_VALUE : nums1[partition1];\n      final int minRight2 = partition2 == n2 ? Integer.MAX_VALUE : nums2[partition2];\n      if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1)\n        return (n1 + n2) % 2 == 0\n            ? (Math.max(maxLeft1, maxLeft2) + Math.min(minRight1, minRight2)) * 0.5\n            : Math.max(maxLeft1, maxLeft2);\n      else if (maxLeft1 > minRight2)\n        r = partition1 - 1;\n      else\n        l = partition1 + 1;\n    } \n\n    throw new IllegalArgumentException();\n  }\n }\n"
    }
  ],
  [
    {
      "id": "5. Longest Palindromic Substring",
      "code": "class Solution {\n  public String longestPalindrome(String s) {\n    if (s.isEmpty())\n      return \"\";\n\n    // [start, end] indices of the longest palindrome in s\n    int[] indices = {0, 0};\n\n    for (int i = 0; i < s.length(); ++i) {\n      int[] indices1 = extend(s, i, i);\n      if (indices1[1] - indices1[0] > indices[1] - indices[0])\n        indices = indices1;\n      if (i + 1 < s.length() && s.charAt(i) == s.charAt(i + 1)) {\n        int[] indices2 = extend(s, i, i + 1);\n        if (indices2[1] - indices2[0] > indices[1] - indices[0])\n          indices = indices2;\n      }\n    } \n\n    return s.substring(indices[0], indices[1] + 1);\n  } \n\n  // Returns [start, end] indices of the longest palindrome extended from s[i..j]\n  private int[] extend(final String s, int i, int j) {\n    for (; i >= 0 && j < s.length(); --i, ++j)\n      if (s.charAt(i) != s.charAt(j))\n        break;\n    return new int[] {i + 1, j - 1};\n  }\n }\n"
    }
  ],
  [
    {
      "id": "6. Zigzag Conversion",
      "code": "class Solution {\n  public String convert(String s, int numRows) {\n    StringBuilder sb = new StringBuilder();\n    List<Character>[] rows = new List[numRows];\n    int k = 0;\n    int direction = numRows == 1 ? 0 : -1;\n\n    for (int i = 0; i < numRows; ++i)\n      rows[i] = new ArrayList<>();\n\n    for (final char c : s.toCharArray()) {\n      rows[k].add(c);\n      if (k == 0 || k == numRows - 1)\n        direction *= -1;\n      k += direction;\n    } \n\n    for (List<Character> row : rows)\n      for (final char c : row)\n        sb.append(c);\n\n    return sb.toString();\n  }\n }\n"
    }
  ],
  [
    {
      "id": "7. Reverse Integer",
      "code": "class Solution {\n  public int reverse(int x) {\n    long ans = 0;\n\n    while (x != 0) {\n      ans = ans * 10 + x % 10;\n      x /= 10;\n    } \n\n    return (ans < Integer.MIN_VALUE || ans > Integer.MAX_VALUE) ? 0 : (int) ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "8. String to Integer (atoi)",
      "code": "class Solution {\n  public int myAtoi(String s) {\n    s = s.strip();\n    if (s.isEmpty())\n      return 0;\n\n    final int sign = s.charAt(0) == '-' ? -1 : 1;\n    if (s.charAt(0) == '+' || s.charAt(0) == '-')\n      s = s.substring(1);\n\n    long num = 0;\n\n    for (final char c : s.toCharArray()) {\n      if (!Character.isDigit(c))\n        break;\n      num = num * 10 + (c - '0');\n      if (sign * num <= Integer.MIN_VALUE)\n        return Integer.MIN_VALUE;\n      if (sign * num >= Integer.MAX_VALUE)\n        return Integer.MAX_VALUE;\n    } \n\n    return sign * (int) num;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "9. Palindrome Number",
      "code": "class Solution {\n  public boolean isPalindrome(int x) {\n    if (x < 0)\n      return false;\n\n    long reversed = 0;\n    int y = x;\n\n    while (y > 0) {\n      reversed = reversed * 10 + y % 10;\n      y /= 10;\n    } \n\n    return reversed == x;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "10. Regular Expression Matching",
      "code": "class Solution {\n  public boolean isMatch(String s, String p) {\n    final int m = s.length();\n    final int n = p.length();\n    // dp[i][j] := true if s[0..i) matches p[0..j)\n    boolean[][] dp = new boolean[m + 1][n + 1];\n    dp[0][0] = true;\n\n    for (int j = 0; j < p.length(); ++j)\n      if (p.charAt(j) == '*' && dp[0][j - 1])\n        dp[0][j + 1] = true;\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (p.charAt(j) == '*') {\n          final boolean noRepeat = dp[i + 1][j - 1]; // Min index of '*' is 1\n          final boolean doRepeat = isMatch(s, i, p, j - 1) && dp[i][j + 1];\n          dp[i + 1][j + 1] = noRepeat || doRepeat;\n        } else if (isMatch(s, i, p, j)) {\n          dp[i + 1][j + 1] = dp[i][j];\n        } \n\n    return dp[m][n];\n  } \n\n  private boolean isMatch(final String s, int i, final String p, int j) {\n    return j >= 0 && p.charAt(j) == '.' || s.charAt(i) == p.charAt(j);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "11. Container With Most Water",
      "code": "class Solution {\n  public int maxArea(int[] height) {\n    int ans = 0;\n    int l = 0;\n    int r = height.length - 1;\n\n    while (l < r) {\n      final int minHeight = Math.min(height[l], height[r]);\n      ans = Math.max(ans, minHeight * (r - l));\n      if (height[l] < height[r])\n        ++l;\n      else\n        --r;\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "12. Integer to Roman",
      "code": "class Solution {\n  public String intToRoman(int num) {\n    final int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    final String[] symbols = {\"M\",  \"CM\", \"D\",  \"CD\", \"C\",  \"XC\", \"L\",\n                              \"XL\", \"X\",  \"IX\", \"V\",  \"IV\", \"I\"};\n    StringBuilder sb = new StringBuilder();\n\n    for (int i = 0; i < values.length; ++i) {\n      if (num == 0)\n        break;\n      while (num >= values[i]) {\n        num -= values[i];\n        sb.append(symbols[i]);\n      }\n    } \n\n    return sb.toString();\n  }\n }\n"
    }
  ],
  [
    {
      "id": "13. Roman to Integer",
      "code": "class Solution {\n  public int romanToInt(String s) {\n    int ans = 0;\n    int[] roman = new int[128];\n\n    roman['I'] = 1;\n    roman['V'] = 5;\n    roman['X'] = 10;\n    roman['L'] = 50;\n    roman['C'] = 100;\n    roman['D'] = 500;\n    roman['M'] = 1000;\n\n    for (int i = 0; i + 1 < s.length(); ++i)\n      if (roman[s.charAt(i)] < roman[s.charAt(i + 1)])\n        ans -= roman[s.charAt(i)];\n      else\n        ans += roman[s.charAt(i)];\n\n    return ans + roman[s.charAt(s.length() - 1)];\n  }\n }\n"
    }
  ],
  [
    {
      "id": "14. Longest Common Prefix",
      "code": "class Solution {\n  public String longestCommonPrefix(String[] strs) {\n    if (strs.length == 0)\n      return \"\";\n\n    for (int i = 0; i < strs[0].length(); ++i)\n      for (int j = 1; j < strs.length; ++j)\n        if (i == strs[j].length() || strs[j].charAt(i) != strs[0].charAt(i))\n          return strs[0].substring(0, i);\n\n    return strs[0];\n  }\n }\n"
    }
  ],
  [
    {
      "id": "15. 3Sum",
      "code": "class Solution {\n  public List<List<Integer>> threeSum(int[] nums) {\n    iF (nums.length < 3)\n      return new ArrayList<>();\n\n    List<List<Integer>> ans = new ArrayList<>();\n\n    Arrays.sort(nums);\n\n    for (int i = 0; i + 2 < nums.length; ++i) {\n      if (i > 0 && nums[i] == nums[i - 1])\n        continue;\n      // Choose nums[i] as the first num in the triplet,\n      // and search the remaining nums in [i + 1, n - 1]\n      int l = i + 1;\n      int r = nums.length - 1;\n      while (l < r) {\n        final int sum = nums[i] + nums[l] + nums[r];\n        if (sum == 0) {\n          ans.add(Arrays.asList(nums[i], nums[l++], nums[r--]));\n          while (l < r && nums[l] == nums[l - 1])\n            ++l;\n          while (l < r && nums[r] == nums[r + 1])\n            --r;\n        } else if (sum < 0) {\n          ++l;\n        } else {\n          --r;\n        }\n      }\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "16. 3Sum Closest",
      "code": "class Solution {\n  public int threeSumClosest(int[] nums, int target) {\n    int ans = nums[0] + nums[1] + nums[2];\n\n    Arrays.sort(nums);\n\n    for (int i = 0; i + 2 < nums.length; ++i) {\n      if (i > 0 && nums[i] == nums[i - 1])\n        continue;\n      // Choose nums[i] as the first num in the triplet,\n      // and search the remaining nums in [i + 1, n - 1]\n      int l = i + 1;\n      int r = nums.length - 1;\n      while (l < r) {\n        final int sum = nums[i] + nums[l] + nums[r];\n        if (sum == target)\n          return sum;\n        if (Math.abs(sum - target) < Math.abs(ans - target))\n          ans = sum;\n        if (sum < target)\n          ++l;\n        else\n          --r;\n      }\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "17. Letter Combinations of a Phone Number",
      "code": "class Solution {\n  public List<String> letterCombinations(String digits) {\n    if (digits.isEmpty())\n      return new ArrayList<>();\n\n    List<String> ans = new ArrayList<>();\n\n    dfs(digits, 0, new StringBuilder(), ans);\n    return ans;\n  } \n\n  private static final String[] digitToLetters = {\"\",    \"\",    \"abc\",  \"def\", \"ghi\",\n                                                  \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n\n  private void dfs(String digits, int i, StringBuilder sb, List<String> ans) {\n    if (i == digits.length()) {\n      ans.add(sb.toString());\n      return;\n    } \n\n    for (final char c : digitToLetters[digits.charAt(i) - '0'].toCharArray()) {\n      sb.append(c);\n      dfs(digits, i + 1, sb, ans);\n      sb.deleteCharAt(sb.length() - 1);\n    }\n  }\n }\n"
    }
  ],
  [
    {
      "id": "18. 4Sum",
      "code": "class Solution {\n  public List<List<Integer>> fourSum(int[] nums, int target) {\n    List<List<Integer>> ans = new ArrayList<>();\n    Arrays.sort(nums);\n    nSum(nums, 4, target, 0, nums.length - 1, new ArrayList<>(), ans);\n    return ans;\n  } \n\n  // In [l, r], find n numbers add up to the target\n  private void nSum(int[] nums, long n, long target, int l, int r, List<Integer> path,\n                    List<List<Integer>> ans) {\n    if (r - l + 1 < n || target < nums[l] * n || target > nums[r] * n)\n      return;\n    if (n == 2) {\n      // Very simliar to the sub procedure in 15. 3Sum\n      while (l < r) {\n        final int sum = nums[l] + nums[r];\n        if (sum == target) {\n          path.add(nums[l]);\n          path.add(nums[r]);\n          ans.add(new ArrayList<>(path));\n          path.remove(path.size() - 1);\n          path.remove(path.size() - 1);\n          ++l;\n          --r;\n          while (l < r && nums[l] == nums[l - 1])\n            ++l;\n          while (l < r && nums[r] == nums[r + 1])\n            --r;\n        } else if (sum < target) {\n          ++l;\n        } else {\n          --r;\n        }\n      }\n      return;\n    } \n\n    for (int i = l; i <= r; ++i) {\n      if (i > l && nums[i] == nums[i - 1])\n        continue;\n      path.add(nums[i]);\n      nSum(nums, n - 1, target - nums[i], i + 1, r, path, ans);\n      path.remove(path.size() - 1);\n    }\n  }\n }\n"
    }
  ],
  [
    {
      "id": "19. Remove Nth Node From End of List",
      "code": "class Solution {\n  public ListNode removeNthFromEnd(ListNode head, int n) {\n    ListNode slow = head;\n    ListNode fast = head;\n\n    while (n-- > 0)\n      fast = fast.next;\n    if (fast == null)\n      return head.next;\n\n    while (fast.next != null) {\n      slow = slow.next;\n      fast = fast.next;\n    }\n    slow.next = slow.next.next;\n\n    return head;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "20. Valid Parentheses",
      "code": "class Solution {\n  public boolean isValid(String s) {\n    Deque<Character> stack = new ArrayDeque<>();\n\n    for (final char c : s.toCharArray())\n      if (c == '(')\n        stack.push(')');\n      else if (c == '{')\n        stack.push('}');\n      else if (c == '[')\n        stack.push(']');\n      else if (stack.isEmpty() || stack.pop() != c)\n        return false;\n\n    return stack.isEmpty();\n  }\n }\n"
    }
  ],
  [
    {
      "id": "21. Merge Two Sorted Lists",
      "code": "class Solution {\n  public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n    if (list1 == null || list2 == null)\n      return list1 == null ? list2 : list1;\n    if (list1.val > list2.val) {\n      ListNode temp = list1;\n      list1 = list2;\n      list2 = temp;\n    }\n    list1.next = mergeTwoLists(list1.next, list2);\n    return list1;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "22. Generate Parentheses",
      "code": "class Solution {\n  public List<String> generateParenthesis(int n) {\n    List<String> ans = new ArrayList<>();\n    dfs(n, n, new StringBuilder(), ans);\n    return ans;\n  } \n\n  private void dfs(int l, int r, final StringBuilder sb, List<String> ans) {\n    if (l == 0 && r == 0) {\n      ans.add(sb.toString());\n      return;\n    } \n\n    if (l > 0) {\n      sb.append(\"(\");\n      dfs(l - 1, r, sb, ans);\n      sb.deleteCharAt(sb.length() - 1);\n    }\n    if (l < r) {\n      sb.append(\")\");\n      dfs(l, r - 1, sb, ans);\n      sb.deleteCharAt(sb.length() - 1);\n    }\n  }\n }\n"
    }
  ],
  [
    {
      "id": "23. Merge k Sorted Lists",
      "code": "class Solution {\n  public ListNode mergeKLists(ListNode[] lists) {\n    ListNode dummy = new ListNode(0);\n    ListNode curr = dummy;\n    Queue<ListNode> minHeap = new PriorityQueue<>((a, b) -> a.val - b.val);\n\n    for (final ListNode list : lists)\n      if (list != null)\n        minHeap.offer(list);\n\n    while (!minHeap.isEmpty()) {\n      ListNode minNode = minHeap.poll();\n      if (minNode.next != null)\n        minHeap.offer(minNode.next);\n      curr.next = minNode;\n      curr = curr.next;\n    } \n\n    return dummy.next;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "24. Swap Nodes in Pairs",
      "code": "class Solution {\n  public ListNode swapPairs(ListNode head) {\n    final int length = getLength(head);\n    ListNode dummy = new ListNode(0, head);\n    ListNode prev = dummy;\n    ListNode curr = head;\n\n    for (int i = 0; i < length / 2; ++i) {\n      ListNode next = curr.next;\n      curr.next = next.next;\n      next.next = curr;\n      prev.next = next;\n      prev = curr;\n      curr = curr.next;\n    } \n\n    return dummy.next;\n  } \n\n  private int getLength(ListNode head) {\n    int length = 0;\n    for (ListNode curr = head; curr != null; curr = curr.next)\n      ++length;\n    return length;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "25. Reverse Nodes in k-Group",
      "code": "class Solution {\n  public ListNode reverseKGroup(ListNode head, int k) {\n    if (head == null)\n      return null;\n\n    ListNode tail = head;\n\n    for (int i = 0; i < k; ++i) {\n      if (tail == null) // Less than k nodes, do nothing\n        return head;\n      tail = tail.next;\n    } \n\n    ListNode newHead = reverse(head, tail);\n    head.next = reverseKGroup(tail, k);\n    return newHead;\n  } \n\n  // Reverses [head, tail)\n  private ListNode reverse(ListNode head, ListNode tail) {\n    ListNode prev = null;\n    ListNode curr = head;\n\n    while (curr != tail) {\n      ListNode next = curr.next;\n      curr.next = prev;\n      prev = curr;\n      curr = next;\n    } \n\n    return prev;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "26. Remove Duplicates from Sorted Array",
      "code": "class Solution {\n  public int removeDuplicates(int[] nums) {\n    int i = 0;\n\n    for (final int num : nums)\n      if (i < 1 || num > nums[i - 1])\n        nums[i++] = num;\n\n    return i;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "27. Remove Element",
      "code": "class Solution {\n  public int removeElement(int[] nums, int val) {\n    int i = 0;\n\n    for (final int num : nums)\n      if (num != val)\n        nums[i++] = num;\n\n    return i;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "28. Find the Index of the First Occurrence in a String",
      "code": "class Solution {\n  public int strStr(String haystack, String needle) {\n    final int m = haystack.length();\n    final int n = needle.length();\n\n    for (int i = 0; i < m - n + 1; ++i)\n      if (haystack.substring(i, i + n).equals(needle))\n        return i;\n\n    return -1;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "29. Divide Two Integers",
      "code": "class Solution {\n  public int divide(long dividend, long divisor) {\n    // -2^{31} / -1 = 2^31 -> overflow so return 2^31 - 1\n    if (dividend == Integer.MIN_VALUE && divisor == -1)\n      return Integer.MAX_VALUE;\n\n    final int sign = dividend > 0 ^ divisor > 0 ? -1 : 1;\n    long ans = 0;\n    long dvd = Math.abs(dividend);\n    long dvs = Math.abs(divisor);\n\n    while (dvd >= dvs) {\n      long k = 1;\n      while (k * 2 * dvs <= dvd)\n        k *= 2;\n      dvd -= k * dvs;\n      ans += k;\n    } \n\n    return sign * (int) ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "30. Substring with Concatenation of All Words",
      "code": "class Solution {\n  public List<Integer> findSubstring(String s, String[] words) {\n    if (s.isEmpty() || words.length == 0)\n      return new ArrayList<>();\n\n    final int k = words.length;\n    final int n = words[0].length();\n    List<Integer> ans = new ArrayList<>();\n    Map<String, Integer> count = new HashMap<>();\n\n    for (final String word : words)\n      count.put(word, count.getOrDefault(word, 0) + 1);\n\n    for (int i = 0; i <= s.length() - k * n; ++i) {\n      Map<String, Integer> seen = new HashMap<>();\n      int j = 0;\n      for (; j < k; ++j) {\n        final String word = s.substring(i + j * n, i + j * n + n);\n        seen.put(word, seen.getOrDefault(word, 0) + 1);\n        if (seen.get(word) > count.getOrDefault(word, 0))\n          break;\n      }\n      if (j == k)\n        ans.add(i);\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "31. Next Permutation",
      "code": "class Solution {\n  public void nextPermutation(int[] nums) {\n    final int n = nums.length;\n\n    // From back to front, find the first num < nums[i + 1]\n    int i;\n    for (i = n - 2; i >= 0; --i)\n      if (nums[i] < nums[i + 1])\n        break;\n\n    // From back to front, find the first num > nums[i], swap it with nums[i]\n    if (i >= 0)\n      for (int j = n - 1; j > i; --j)\n        if (nums[j] > nums[i]) {\n          swap(nums, i, j);\n          break;\n        } \n\n    // Reverse nums[i + 1..n - 1]\n    reverse(nums, i + 1, n - 1);\n  } \n\n  private void reverse(int[] nums, int l, int r) {\n    while (l < r)\n      swap(nums, l++, r--);\n  } \n\n  private void swap(int[] nums, int i, int j) {\n    final int temp = nums[i];\n    nums[i] = nums[j];\n    nums[j] = temp;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "32. Longest Valid Parentheses",
      "code": "class Solution {\n  public int longestValidParentheses(String s) {\n    final String s2 = \")\" + s;\n    // dp[i] := Length of longest valid parentheses substring of s2[1..i]\n    int dp[] = new int[s2.length()];\n\n    for (int i = 1; i < s2.length(); ++i)\n      if (s2.charAt(i) == ')' && s2.charAt(i - dp[i - 1] - 1) == '(')\n        dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2;\n\n    return Arrays.stream(dp).max().getAsInt();\n  }\n }\n"
    }
  ],
  [
    {
      "id": "33. Search in Rotated Sorted Array",
      "code": "class Solution {\n  public int search(int[] nums, int target) {\n    int l = 0;\n    int r = nums.length - 1;\n\n    while (l <= r) {\n      final int m = (l + r) / 2;\n      if (nums[m] == target)\n        return m;\n      if (nums[l] <= nums[m]) { // nums[l..m] are sorted\n        if (nums[l] <= target && target < nums[m])\n          r = m - 1;\n        else\n          l = m + 1;\n      } else { // nums[m..n - 1] are sorted\n        if (nums[m] < target && target <= nums[r])\n          l = m + 1;\n        else\n          r = m - 1;\n      }\n    } \n\n    return -1;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "34. Find First and Last Position of Element in Sorted Array",
      "code": "class Solution {\n  public int[] searchRange(int[] nums, int target) {\n    final int l = firstGreaterEqual(nums, target);\n    if (l == nums.length || nums[l] != target)\n      return new int[] {-1, -1};\n    final int r = firstGreaterEqual(nums, target + 1) - 1;\n    return new int[] {l, r};\n  } \n\n  // Finds the first index l s.t A[l] >= target\n  // Returns A.length if can't find\n  private int firstGreaterEqual(int[] A, int target) {\n    int l = 0;\n    int r = A.length;\n    while (l < r) {\n      final int m = (l + r) / 2;\n      if (A[m] >= target)\n        r = m;\n      else\n        l = m + 1;\n    }\n    return l;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "35. Search Insert Position",
      "code": "class Solution {\n  public int searchInsert(int[] nums, int target) {\n    int l = 0;\n    int r = nums.length;\n\n    while (l < r) {\n      final int m = (l + r) / 2;\n      if (nums[m] == target)\n        return m;\n      if (nums[m] < target)\n        l = m + 1;\n      else\n        r = m;\n    } \n\n    return l;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "36. Valid Sudoku",
      "code": "class Solution {\n  public boolean isValidSudoku(char[][] board) {\n    Set<String> seen = new HashSet<>();\n\n    for (int i = 0; i < 9; ++i)\n      for (int j = 0; j < 9; ++j) {\n        if (board[i][j] == '.')\n          continue;\n        final char c = board[i][j];\n        if (!seen.add(c + \"@row\" + i) ||\n            !seen.add(c + \"@col\" + j) ||\n            !seen.add(c + \"@box\" + i / 3 + j / 3))\n          return false;\n      } \n\n    return true;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "37. Sudoku Solver",
      "code": "class Solution {\n  public void solveSudoku(char[][] board) {\n    dfs(board, 0);\n  } \n\n  private boolean dfs(char[][] board, int s) {\n    if (s == 81)\n      return true;\n\n    final int i = s / 9;\n    final int j = s % 9;\n\n    if (board[i][j] != '.')\n      return dfs(board, s + 1);\n\n    for (char c = '1'; c <= '9'; ++c)\n      if (isValid(board, i, j, c)) {\n        board[i][j] = c;\n        if (dfs(board, s + 1))\n          return true;\n        board[i][j] = '.';\n      } \n\n    return false;\n  } \n\n  private boolean isValid(char[][] board, int row, int col, char c) {\n    for (int i = 0; i < 9; ++i)\n      if (board[i][col] == c || board[row][i] == c ||\n          board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\n        return false;\n    return true;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "38. Count and Say",
      "code": "class Solution {\n  public String countAndSay(int n) {\n    StringBuilder sb = new StringBuilder(\"1\");\n\n    while (--n > 0) {\n      StringBuilder next = new StringBuilder();\n      for (int i = 0; i < sb.length(); ++i) {\n        int count = 1;\n        while (i + 1 < sb.length() && sb.charAt(i) == sb.charAt(i + 1)) {\n          ++count;\n          ++i;\n        }\n        next.append(count).append(sb.charAt(i));\n      }\n      sb = next;\n    } \n\n    return sb.toString();\n  }\n }\n"
    }
  ],
  [
    {
      "id": "39. Combination Sum",
      "code": "class Solution {\n  public List<List<Integer>> combinationSum(int[] candidates, int target) {\n    List<List<Integer>> ans = new ArrayList<>();\n    Arrays.sort(candidates);\n    dfs(0, candidates, target, new ArrayList<>(), ans);\n    return ans;\n  } \n\n  private void dfs(int s, int[] candidates, int target, List<Integer> path,\n                   List<List<Integer>> ans) {\n    if (target < 0)\n      return;\n    if (target == 0) {\n      ans.add(new ArrayList<>(path));\n      return;\n    } \n\n    for (int i = s; i < candidates.length; ++i) {\n      path.add(candidates[i]);\n      dfs(i, candidates, target - candidates[i], path, ans);\n      path.remove(path.size() - 1);\n    }\n  }\n }\n"
    }
  ],
  [
    {
      "id": "40. Combination Sum II",
      "code": "class Solution {\n  public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n    List<List<Integer>> ans = new ArrayList<>();\n    Arrays.sort(candidates);\n    dfs(0, candidates, target, new ArrayList<>(), ans);\n    return ans;\n  } \n\n  private void dfs(int s, int[] candidates, int target, List<Integer> path,\n                   List<List<Integer>> ans) {\n    if (target < 0)\n      return;\n    if (target == 0) {\n      ans.add(new ArrayList<>(path));\n      return;\n    } \n\n    for (int i = s; i < candidates.length; ++i) {\n      if (i > s && candidates[i] == candidates[i - 1])\n        continue;\n      path.add(candidates[i]);\n      dfs(i + 1, candidates, target - candidates[i], path, ans);\n      path.remove(path.size() - 1);\n    }\n  }\n }\n"
    }
  ],
  [
    {
      "id": "41. First Missing Positive",
      "code": "class Solution {\n  public int firstMissingPositive(int[] nums) {\n    final int n = nums.length;\n\n    // Correct slot:\n    // nums[i] = i + 1\n    // nums[i] - 1 = i\n    // nums[nums[i] - 1] = nums[i]\n    for (int i = 0; i < n; ++i)\n      while (nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i] - 1])\n        swap(nums, i, nums[i] - 1);\n\n    for (int i = 0; i < n; ++i)\n      if (nums[i] != i + 1)\n        return i + 1;\n\n    return n + 1;\n  } \n\n  private void swap(int[] nums, int i, int j) {\n    final int temp = nums[i];\n    nums[i] = nums[j];\n    nums[j] = temp;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "42. Trapping Rain Water",
      "code": "class Solution {\n  public int trap(int[] height) {\n    final int n = height.length;\n    int ans = 0;\n    int[] l = new int[n]; // l[i] := max(height[0..i])\n    int[] r = new int[n]; // r[i] := max(height[i..n))\n\n    for (int i = 0; i < n; ++i)\n      l[i] = i == 0 ? height[i] : Math.max(height[i], l[i - 1]);\n\n    for (int i = n - 1; i >= 0; --i)\n      r[i] = i == n - 1 ? height[i] : Math.max(height[i], r[i + 1]);\n\n    for (int i = 0; i < n; ++i)\n      ans += Math.min(l[i], r[i]) - height[i];\n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "43. Multiply Strings",
      "code": "class Solution {\n  public String multiply(String num1, String num2) {\n    final int m = num1.length();\n    final int n = num2.length();\n\n    StringBuilder sb = new StringBuilder();\n    int[] pos = new int[m + n];\n\n    for (int i = m - 1; i >= 0; --i)\n      for (int j = n - 1; j >= 0; --j) {\n        final int multiply = (num1.charAt(i) - '0') * (num2.charAt(j) - '0');\n        final int sum = multiply + pos[i + j + 1];\n        pos[i + j] += sum / 10;\n        pos[i + j + 1] = sum % 10;\n      } \n\n    for (final int p : pos)\n      if (p > 0 || sb.length() > 0)\n        sb.append(p);\n\n    return sb.length() == 0 ? \"0\" : sb.toString();\n  }\n }\n"
    }
  ],
  [
    {
      "id": "44. Wildcard Matching",
      "code": "class Solution {\n  public boolean isMatch(String s, String p) {\n    final int m = s.length();\n    final int n = p.length();\n    // dp[i][j] := true if s[0..i) matches p[0..j)\n    boolean[][] dp = new boolean[m + 1][n + 1];\n    dp[0][0] = true;\n\n    for (int j = 0; j < p.length(); ++j)\n      if (p.charAt(j) == '*')\n        dp[0][j + 1] = dp[0][j];\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (p.charAt(j) == '*') {\n          final boolean matchEmpty = dp[i + 1][j];\n          final boolean matchSome = dp[i][j + 1];\n          dp[i + 1][j + 1] = matchEmpty || matchSome;\n        } else if (isMatch(s, i, p, j)) {\n          dp[i + 1][j + 1] = dp[i][j];\n        } \n\n    return dp[m][n];\n  } \n\n  private boolean isMatch(final String s, int i, final String p, int j) {\n    return j >= 0 && p.charAt(j) == '?' || s.charAt(i) == p.charAt(j);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "45. Jump Game II",
      "code": "class Solution {\n  public int jump(int[] nums) {\n    int ans = 0;\n    int end = 0;\n    int farthest = 0;\n\n    // Implicit BFS\n    for (int i = 0; i < nums.length - 1; ++i) {\n      farthest = Math.max(farthest, i + nums[i]);\n      if (farthest >= nums.length - 1) {\n        ++ans;\n        break;\n      }\n      if (i == end) {   // Visited all the items on the current level\n        ++ans;          // Increment the level\n        end = farthest; // Make the queue size for the next level\n      }\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "46. Permutations",
      "code": "class Solution {\n  public List<List<Integer>> permute(int[] nums) {\n    List<List<Integer>> ans = new ArrayList<>();\n\n    dfs(nums, new boolean[nums.length], new ArrayList<>(), ans);\n    return ans;\n  } \n\n  private void dfs(int[] nums, boolean[] used, List<Integer> path, List<List<Integer>> ans) {\n    if (path.size() == nums.length) {\n      ans.add(new ArrayList<>(path));\n      return;\n    } \n\n    for (int i = 0; i < nums.length; ++i) {\n      if (used[i])\n        continue;\n      used[i] = true;\n      path.add(nums[i]);\n      dfs(nums, used, path, ans);\n      path.remove(path.size() - 1);\n      used[i] = false;\n    }\n  }\n }\n"
    }
  ],
  [
    {
      "id": "47. Permutations II",
      "code": "class Solution {\n  public List<List<Integer>> permuteUnique(int[] nums) {\n    List<List<Integer>> ans = new ArrayList<>();\n    Arrays.sort(nums);\n    dfs(nums, new boolean[nums.length], new ArrayList<>(), ans);\n    return ans;\n  } \n\n  private void dfs(int[] nums, boolean[] used, List<Integer> path, List<List<Integer>> ans) {\n    if (path.size() == nums.length) {\n      ans.add(new ArrayList<>(path));\n      return;\n    } \n\n    for (int i = 0; i < nums.length; ++i) {\n      if (used[i])\n        continue;\n      if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1])\n        continue;\n      used[i] = true;\n      path.add(nums[i]);\n      dfs(nums, used, path, ans);\n      path.remove(path.size() - 1);\n      used[i] = false;\n    }\n  }\n }\n"
    }
  ],
  [
    {
      "id": "48. Rotate Image",
      "code": "class Solution {\n  public void rotate(int[][] matrix) {\n    for (int i = 0, j = matrix.length - 1; i < j; ++i, --j) {\n      int[] temp = matrix[i];\n      matrix[i] = matrix[j];\n      matrix[j] = temp;\n    } \n\n    for (int i = 0; i < matrix.length; ++i)\n      for (int j = i + 1; j < matrix.length; ++j) {\n        final int temp = matrix[i][j];\n        matrix[i][j] = matrix[j][i];\n        matrix[j][i] = temp;\n      }\n  }\n }\n"
    }
  ],
  [
    {
      "id": "49. Group Anagrams",
      "code": "class Solution {\n  public List<List<String>> groupAnagrams(String[] strs) {\n    Map<String, List<String>> keyToAnagrams = new HashMap<>();\n\n    for (final String str : strs) {\n      char[] chars = str.toCharArray();\n      Arrays.sort(chars);\n      String key = String.valueOf(chars);\n      keyToAnagrams.computeIfAbsent(key, k -> new ArrayList<>()).add(str);\n    } \n\n    return new ArrayList<>(keyToAnagrams.values());\n  }\n }\n"
    }
  ],
  [
    {
      "id": "50. Pow(x, n)",
      "code": "class Solution {\n  public double myPow(double x, long n) {\n    if (n == 0)\n      return 1;\n    if (n < 0)\n      return 1 / myPow(x, -n);\n    if (n % 2 == 1)\n      return x * myPow(x, n - 1);\n    return myPow(x * x, n / 2);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "51. N-Queens",
      "code": "class Solution {\n  public List<List<String>> solveNQueens(int n) {\n    List<List<String>> ans = new ArrayList<>();\n    char[][] board = new char[n][n];\n\n    for (int i = 0; i < n; ++i)\n      Arrays.fill(board[i], '.');\n\n    dfs(n, 0, new boolean[n], new boolean[2 * n - 1], new boolean[2 * n - 1], board, ans);\n    return ans;\n  } \n\n  private void dfs(int n, int i, boolean[] cols, boolean[] diag1, boolean[] diag2, char[][] board,\n                   List<List<String>> ans) {\n    if (i == n) {\n      ans.add(construct(board));\n      return;\n    } \n\n    for (int j = 0; j < cols.length; ++j) {\n      if (cols[j] || diag1[i + j] || diag2[j - i + n - 1])\n        continue;\n      board[i][j] = 'Q';\n      cols[j] = diag1[i + j] = diag2[j - i + n - 1] = true;\n      dfs(n, i + 1, cols, diag1, diag2, board, ans);\n      cols[j] = diag1[i + j] = diag2[j - i + n - 1] = false;\n      board[i][j] = '.';\n    }\n  } \n\n  private List<String> construct(char[][] board) {\n    List<String> listBoard = new ArrayList<>();\n    for (int i = 0; i < board.length; ++i)\n      listBoard.add(String.valueOf(board[i]));\n    return listBoard;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "52. N-Queens II",
      "code": "class Solution {\n  public int totalNQueens(int n) {\n    dfs(n, 0, new boolean[n], new boolean[2 * n - 1], new boolean[2 * n - 1]);\n    return ans;\n  } \n\n  private int ans = 0;\n\n  private void dfs(int n, int i, boolean[] cols, boolean[] diag1, boolean[] diag2) {\n    if (i == n) {\n      ++ans;\n      return;\n    } \n\n    for (int j = 0; j < cols.length; ++j) {\n      if (cols[j] || diag1[i + j] || diag2[j - i + n - 1])\n        continue;\n      cols[j] = diag1[i + j] = diag2[j - i + n - 1] = true;\n      dfs(n, i + 1, cols, diag1, diag2);\n      cols[j] = diag1[i + j] = diag2[j - i + n - 1] = false;\n    }\n  }\n }\n"
    }
  ],
  [
    {
      "id": "53. Maximum Subarray",
      "code": "class Solution {\n  public int maxSubArray(int[] nums) {\n    // dp[i] := max sum subarray ending w/ i.\n    int[] dp = new int[nums.length];\n\n    dp[0] = nums[0];\n    for (int i = 1; i < nums.length; ++i)\n      dp[i] = Math.max(nums[i], dp[i - 1] + nums[i]);\n\n    return Arrays.stream(dp).max().getAsInt();\n  }\n }\n"
    }
  ],
  [
    {
      "id": "54. Spiral Matrix",
      "code": "class Solution {\n  public List<Integer> spiralOrder(int[][] matrix) {\n    if (matrix.length == 0)\n      return new ArrayList<>();\n\n    final int m = matrix.length;\n    final int n = matrix[0].length;\n    List<Integer> ans = new ArrayList<>();\n    int r1 = 0;\n    int c1 = 0;\n    int r2 = m - 1;\n    int c2 = n - 1;\n\n    // Repeatedly add matrix[r1..r2][c1..c2] to ans\n    while (ans.size() < m * n) {\n      for (int j = c1; j <= c2 && ans.size() < m * n; ++j)\n        ans.add(matrix[r1][j]);\n      for (int i = r1 + 1; i <= r2 - 1 && ans.size() < m * n; ++i)\n        ans.add(matrix[i][c2]);\n      for (int j = c2; j >= c1 && ans.size() < m * n; --j)\n        ans.add(matrix[r2][j]);\n      for (int i = r2 - 1; i >= r1 + 1 && ans.size() < m * n; --i)\n        ans.add(matrix[i][c1]);\n      ++r1;\n      ++c1;\n      --r2;\n      --c2;\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "55. Jump Game",
      "code": "class Solution {\n  public boolean canJump(int[] nums) {\n    int i = 0;\n\n    for (int reach = 0; i < nums.length && i <= reach; ++i)\n      reach = Math.max(reach, i + nums[i]);\n\n    return i == nums.length;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "56. Merge Intervals",
      "code": "class Solution {\n  public int[][] merge(int[][] intervals) {\n    List<int[]> ans = new ArrayList<>();\n\n    Arrays.sort(intervals, (a, b) -> (a[0] - b[0]));\n\n    for (int[] interval : intervals)\n      if (ans.isEmpty() || ans.get(ans.size() - 1)[1] < interval[0])\n        ans.add(interval);\n      else\n        ans.get(ans.size() - 1)[1] = Math.max(ans.get(ans.size() - 1)[1], interval[1]);\n\n    return ans.stream().toArray(int[][] ::new);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "57. Insert Interval",
      "code": "class Solution {\n  public int[][] insert(int[][] intervals, int[] newInterval) {\n    final int n = intervals.length;\n    List<int[]> ans = new ArrayList<>();\n    int i = 0;\n\n    while (i < n && intervals[i][1] < newInterval[0])\n      ans.add(intervals[i++]);\n\n    while (i < n && intervals[i][0] <= newInterval[1]) {\n      newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\n      newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\n      ++i;\n    } \n\n    ans.add(newInterval);\n\n    while (i < n)\n      ans.add(intervals[i++]);\n\n    return ans.stream().toArray(int[][] ::new);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "58. Length of Last Word",
      "code": "class Solution {\n  public int lengthOfLastWord(String s) {\n    int i = s.length() - 1;\n\n    while (i >= 0 && s.charAt(i) == ' ')\n      --i;\n    final int lastIndex = i;\n    while (i >= 0 && s.charAt(i) != ' ')\n      --i;\n\n    return lastIndex - i;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "59. Spiral Matrix II",
      "code": "class Solution {\n  public int[][] generateMatrix(int n) {\n    int[][] ans = new int[n][n];\n    int count = 1;\n\n    for (int min = 0; min < n / 2; ++min) {\n      final int max = n - min - 1;\n      for (int i = min; i < max; ++i)\n        ans[min][i] = count++;\n      for (int i = min; i < max; ++i)\n        ans[i][max] = count++;\n      for (int i = max; i > min; --i)\n        ans[max][i] = count++;\n      for (int i = max; i > min; --i)\n        ans[i][min] = count++;\n    } \n\n    if (n % 2 == 1)\n      ans[n / 2][n / 2] = count;\n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "60. Permutation Sequence",
      "code": "class Solution {\n  public String getPermutation(int n, int k) {\n    StringBuilder sb = new StringBuilder();\n    List<Integer> nums = new ArrayList<>();\n    int[] fact = new int[n + 1]; // fact[i] := i!\n\n    for (int i = 1; i <= n; ++i)\n      nums.add(i);\n\n    Arrays.fill(fact, 1);\n    for (int i = 2; i <= n; ++i)\n      fact[i] = fact[i - 1] * i;\n\n    --k; // 0-indexed\n\n    for (int i = n - 1; i >= 0; --i) {\n      final int j = k / fact[i];\n      k %= fact[i];\n      sb.append(nums.get(j));\n      nums.remove(j);\n    } \n\n    return sb.toString();\n  }\n }\n"
    }
  ],
  [
    {
      "id": "61. Rotate List",
      "code": "class Solution {\n  public ListNode rotateRight(ListNode head, int k) {\n    if (head == null || head.next == null || k == 0)\n      return head;\n\n    int length = 1;\n    ListNode tail = head;\n    for (; tail.next != null; tail = tail.next)\n      ++length;\n    tail.next = head; // Circle the list\n\n    final int t = length - k % length;\n    for (int i = 0; i < t; ++i)\n      tail = tail.next;\n    ListNode newHead = tail.next;\n    tail.next = null;\n\n    return newHead;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "62. Unique Paths",
      "code": "class Solution {\n  public int uniquePaths(int m, int n) {\n    // dp[i][j] := unique paths from (0, 0) to (i, j)\n    int[][] dp = new int[m][n];\n    Arrays.stream(dp).forEach(A -> Arrays.fill(A, 1));\n\n    for (int i = 1; i < m; ++i)\n      for (int j = 1; j < n; ++j)\n        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n\n    return dp[m - 1][n - 1];\n  }\n }\n"
    }
  ],
  [
    {
      "id": "63. Unique Paths II",
      "code": "class Solution {\n  public int uniquePathsWithObstacles(int[][] obstacleGrid) {\n    final int m = obstacleGrid.length;\n    final int n = obstacleGrid[0].length;\n    // dp[i][j] := unique paths from (0, 0) to (i - 1, j - 1)\n    long[][] dp = new long[m + 1][n + 1];\n    dp[0][1] = 1; // Can also set dp[1][0] = 1\n\n    for (int i = 1; i <= m; ++i)\n      for (int j = 1; j <= n; ++j)\n        if (obstacleGrid[i - 1][j - 1] == 0)\n          dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n\n    return (int) dp[m][n];\n  }\n }\n"
    }
  ],
  [
    {
      "id": "64. Minimum Path Sum",
      "code": "class Solution {\n  public int minPathSum(int[][] grid) {\n    final int m = grid.length;\n    final int n = grid[0].length;\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (i > 0 && j > 0)\n          grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);\n        else if (i > 0)\n          grid[i][0] += grid[i - 1][0];\n        else if (j > 0)\n          grid[0][j] += grid[0][j - 1];\n\n    return grid[m - 1][n - 1];\n  }\n }\n"
    }
  ],
  [
    {
      "id": "65. Valid Number",
      "code": "class Solution {\n  public boolean isNumber(String s) {\n    s = s.trim();\n    if (s.isEmpty())\n      return false;\n\n    boolean seenNum = false;\n    boolean seenDot = false;\n    boolean seenE = false;\n\n    for (int i = 0; i < s.length(); ++i) {\n      switch (s.charAt(i)) {\n        case '.':\n          if (seenDot || seenE)\n            return false;\n          seenDot = true;\n          break;\n        case 'e':\n        case 'E':\n          if (seenE || !seenNum)\n            return false;\n          seenE = true;\n          seenNum = false;\n          break;\n        case '+':\n        case '-':\n          if (i > 0 && s.charAt(i - 1) != 'e')\n            return false;\n          seenNum = false;\n          break;\n        default:\n          if (!Character.isDigit(s.charAt(i)))\n            return false;\n          seenNum = true;\n      }\n    } \n\n    return seenNum;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "66. Plus One",
      "code": "class Solution {\n  public int[] plusOne(int[] digits) {\n    for (int i = digits.length - 1; i >= 0; i--) {\n      if (digits[i] < 9) {\n        ++digits[i];\n        return digits;\n      }\n      digits[i] = 0;\n    } \n\n    int[] ans = new int[digits.length + 1];\n    ans[0] = 1;\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "67. Add Binary",
      "code": "class Solution {\n  public String addBinary(String a, String b) {\n    StringBuilder sb = new StringBuilder();\n    int carry = 0;\n    int i = a.length() - 1;\n    int j = b.length() - 1;\n\n    while (i >= 0 || j >= 0 || carry == 1) {\n      if (i >= 0)\n        carry += a.charAt(i--) - '0';\n      if (j >= 0)\n        carry += b.charAt(j--) - '0';\n      sb.append(carry % 2);\n      carry /= 2;\n    } \n\n    return sb.reverse().toString();\n  }\n }\n"
    }
  ],
  [
    {
      "id": "68. Text Justification",
      "code": "class Solution {\n  public List<String> fullJustify(String[] words, int maxWidth) {\n    List<String> ans = new ArrayList<>();\n    List<StringBuilder> row = new ArrayList<>();\n    int rowLetters = 0;\n\n    for (final String word : words) {\n      if (rowLetters + row.size() + word.length() > maxWidth) {\n        final int spaces = maxWidth - rowLetters;\n        if (row.size() == 1) {\n          for (int i = 0; i < spaces; ++i)\n            row.get(0).append(\" \");\n        } else {\n          for (int i = 0; i < spaces; ++i)\n            row.get(i % (row.size() - 1)).append(\" \");\n        }\n        final String joinedRow =\n            row.stream().map(StringBuilder::toString).collect(Collectors.joining(\"\"));\n        ans.add(joinedRow);\n        row.clear();\n        rowLetters = 0;\n      }\n      row.add(new StringBuilder(word));\n      rowLetters += word.length();\n    } \n\n    final String lastRow =\n        row.stream().map(StringBuilder::toString).collect(Collectors.joining(\" \"));\n    StringBuilder sb = new StringBuilder(lastRow);\n    final int spacesToBeAdded = maxWidth - sb.length();\n    for (int i = 0; i < spacesToBeAdded; ++i)\n      sb.append(\" \");\n\n    ans.add(sb.toString());\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "69. Sqrt(x)",
      "code": "class Solution {\n  public int mySqrt(long x) {\n    long l = 1;\n    long r = x + 1;\n\n    while (l < r) {\n      final long m = (l + r) / 2;\n      if (m > x / m)\n        r = m;\n      else\n        l = m + 1;\n    } \n\n    // L: smallest number s.t. l * l > x\n    return (int) l - 1;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "70. Climbing Stairs",
      "code": "class Solution {\n  public int climbStairs(int n) {\n    // dp[i] := # of distinct ways to climb to i-th stair\n    int[] dp = new int[n + 1];\n    dp[0] = 1;\n    dp[1] = 1;\n\n    for (int i = 2; i <= n; ++i)\n      dp[i] = dp[i - 1] + dp[i - 2];\n\n    return dp[n];\n  }\n }\n"
    }
  ],
  [
    {
      "id": "71. Simplify Path",
      "code": "class Solution {\n  public String simplifyPath(String path) {\n    final String[] dirs = path.split(\"/\");\n    Stack<String> stack = new Stack<>();\n\n    for (final String dir : dirs) {\n      if (dir.isEmpty() || dir.equals(\".\"))\n        continue;\n      if (dir.equals(\"..\")) {\n        if (!stack.isEmpty())\n          stack.pop();\n      } else {\n        stack.push(dir);\n      }\n    } \n\n    return \"/\" + String.join(\"/\", stack);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "72. Edit Distance",
      "code": "class Solution {\n  public int minDistance(String word1, String word2) {\n    final int m = word1.length();\n    final int n = word2.length();\n    // dp[i][j] := min # of operations to convert word1[0..i) to word2[0..j)\n    int[][] dp = new int[m + 1][n + 1];\n\n    for (int i = 1; i <= m; ++i)\n      dp[i][0] = i;\n\n    for (int j = 1; j <= n; ++j)\n      dp[0][j] = j;\n\n    for (int i = 1; i <= m; ++i)\n      for (int j = 1; j <= n; ++j)\n        if (word1.charAt(i - 1) == word2.charAt(j - 1))\n          dp[i][j] = dp[i - 1][j - 1];\n        else\n          dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;\n\n    return dp[m][n];\n  }\n }\n"
    }
  ],
  [
    {
      "id": "73. Set Matrix Zeroes",
      "code": "class Solution {\n  public void setZeroes(int[][] matrix) {\n    final int m = matrix.length;\n    final int n = matrix[0].length;\n    boolean shouldFillFirstRow = false;\n    boolean shouldFillFirstCol = false;\n\n    for (int j = 0; j < n; ++j)\n      if (matrix[0][j] == 0) {\n        shouldFillFirstRow = true;\n        break;\n      } \n\n    for (int i = 0; i < m; ++i)\n      if (matrix[i][0] == 0) {\n        shouldFillFirstCol = true;\n        break;\n      } \n\n    // Store the information in the 1st row/col\n    for (int i = 1; i < m; ++i)\n      for (int j = 1; j < n; ++j)\n        if (matrix[i][j] == 0) {\n          matrix[i][0] = 0;\n          matrix[0][j] = 0;\n        } \n\n    // Fill 0s for the matrix except the 1st row/col\n    for (int i = 1; i < m; ++i)\n      for (int j = 1; j < n; ++j)\n        if (matrix[i][0] == 0 || matrix[0][j] == 0)\n          matrix[i][j] = 0;\n\n    // Fill 0s for the 1st row if needed\n    if (shouldFillFirstRow)\n      for (int j = 0; j < n; ++j)\n        matrix[0][j] = 0;\n\n    // Fill 0s for the 1st col if needed\n    if (shouldFillFirstCol)\n      for (int i = 0; i < m; ++i)\n        matrix[i][0] = 0;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "74. Search a 2D Matrix",
      "code": "class Solution {\n  public boolean searchMatrix(int[][] matrix, int target) {\n    if (matrix.length == 0)\n      return false;\n\n    final int m = matrix.length;\n    final int n = matrix[0].length;\n    int l = 0;\n    int r = m * n;\n\n    while (l < r) {\n      final int mid = (l + r) / 2;\n      final int i = mid / n;\n      final int j = mid % n;\n      if (matrix[i][j] == target)\n        return true;\n      if (matrix[i][j] < target)\n        l = mid + 1;\n      else\n        r = mid;\n    } \n\n    return false;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "75. Sort Colors",
      "code": "class Solution {\n  public void sortColors(int[] nums) {\n    int zero = -1;\n    int one = -1;\n    int two = -1;\n\n    for (final int num : nums)\n      if (num == 0) {\n        nums[++two] = 2;\n        nums[++one] = 1;\n        nums[++zero] = 0;\n      } else if (num == 1) {\n        nums[++two] = 2;\n        nums[++one] = 1;\n      } else {\n        nums[++two] = 2;\n      }\n  }\n }\n"
    }
  ],
  [
    {
      "id": "76. Minimum Window Substring",
      "code": "class Solution {\n  public String minWindow(String s, String t) {\n    int[] count = new int[128];\n    int required = t.length();\n    int bestLeft = -1;\n    int minLength = s.length() + 1;\n\n    for (final char c : t.toCharArray())\n      ++count[c];\n\n    for (int l = 0, r = 0; r < s.length(); ++r) {\n      if (--count[s.charAt(r)] >= 0)\n        --required;\n      while (required == 0) {\n        if (r - l + 1 < minLength) {\n          bestLeft = l;\n          minLength = r - l + 1;\n        }\n        if (++count[s.charAt(l++)] > 0)\n          ++required;\n      }\n    } \n\n    return bestLeft == -1 ? \"\" : s.substring(bestLeft, bestLeft + minLength);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "77. Combinations",
      "code": "class Solution {\n  public List<List<Integer>> combine(int n, int k) {\n    List<List<Integer>> ans = new ArrayList<>();\n    dfs(n, k, 1, new ArrayList<>(), ans);\n    return ans;\n  } \n\n  private void dfs(int n, int k, int s, List<Integer> path, List<List<Integer>> ans) {\n    if (path.size() == k) {\n      ans.add(new ArrayList<>(path));\n      return;\n    } \n\n    for (int i = s; i <= n; ++i) {\n      path.add(i);\n      dfs(n, k, i + 1, path, ans);\n      path.remove(path.size() - 1);\n    }\n  }\n }\n"
    }
  ],
  [
    {
      "id": "78. Subsets",
      "code": "class Solution {\n  public List<List<Integer>> subsets(int[] nums) {\n    List<List<Integer>> ans = new ArrayList<>();\n    dfs(nums, 0, new ArrayList<>(), ans);\n    return ans;\n  } \n\n  private void dfs(int[] nums, int s, List<Integer> path, List<List<Integer>> ans) {\n    ans.add(new ArrayList<>(path));\n\n    for (int i = s; i < nums.length; ++i) {\n      path.add(nums[i]);\n      dfs(nums, i + 1, path, ans);\n      path.remove(path.size() - 1);\n    }\n  }\n }\n"
    }
  ],
  [
    {
      "id": "79. Word Search",
      "code": "class Solution {\n  public boolean exist(char[][] board, String word) {\n    for (int i = 0; i < board.length; ++i)\n      for (int j = 0; j < board[0].length; ++j)\n        if (dfs(board, word, i, j, 0))\n          return true;\n    return false;\n  } \n\n  private boolean dfs(char[][] board, String word, int i, int j, int s) {\n    if (i < 0 || i == board.length || j < 0 || j == board[0].length)\n      return false;\n    if (board[i][j] != word.charAt(s) || board[i][j] == '*')\n      return false;\n    if (s == word.length() - 1)\n      return true;\n\n    final char cache = board[i][j];\n    board[i][j] = '*';\n    final boolean isExist = dfs(board, word, i + 1, j, s + 1) ||\n                            dfs(board, word, i - 1, j, s + 1) ||\n                            dfs(board, word, i, j + 1, s + 1) ||\n                            dfs(board, word, i, j - 1, s + 1);\n    board[i][j] = cache;\n\n    return isExist;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "80. Remove Duplicates from Sorted Array II",
      "code": "class Solution {\n  public int removeDuplicates(int[] nums) {\n    int i = 0;\n\n    for (final int num : nums)\n      if (i < 2 || num > nums[i - 2])\n        nums[i++] = num;\n\n    return i;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "81. Search in Rotated Sorted Array II",
      "code": "class Solution {\n  public boolean search(int[] nums, int target) {\n    int l = 0;\n    int r = nums.length - 1;\n\n    while (l <= r) {\n      final int m = (l + r) / 2;\n      if (nums[m] == target)\n        return true;\n      if (nums[l] == nums[m] && nums[m] == nums[r]) {\n        ++l;\n        --r;\n      } else if (nums[l] <= nums[m]) { // nums[l..m] are sorted\n        if (nums[l] <= target && target < nums[m])\n          r = m - 1;\n        else\n          l = m + 1;\n      } else { // nums[m..n - 1] are sorted\n        if (nums[m] < target && target <= nums[r])\n          l = m + 1;\n        else\n          r = m - 1;\n      }\n    } \n\n    return false;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "82. Remove Duplicates from Sorted List II",
      "code": "class Solution {\n  public ListNode deleteDuplicates(ListNode head) {\n    ListNode dummy = new ListNode(0, head);\n    ListNode prev = dummy;\n\n    while (head != null) {\n      while (head.next != null && head.val == head.next.val)\n        head = head.next;\n      if (prev.next == head)\n        prev = prev.next;\n      else\n        prev.next = head.next;\n      head = head.next;\n    } \n\n    return dummy.next;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "83. Remove Duplicates from Sorted List",
      "code": "class Solution {\n  public ListNode deleteDuplicates(ListNode head) {\n    ListNode curr = head;\n\n    while (curr != null) {\n      while (curr.next != null && curr.val == curr.next.val)\n        curr.next = curr.next.next;\n      curr = curr.next;\n    } \n\n    return head;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "84. Largest Rectangle in Histogram",
      "code": "class Solution {\n  public int largestRectangleArea(int[] heights) {\n    int ans = 0;\n    Deque<Integer> stack = new ArrayDeque<>();\n\n    for (int i = 0; i <= heights.length; ++i) {\n      while (!stack.isEmpty() && (i == heights.length || heights[stack.peek()] > heights[i])) {\n        final int h = heights[stack.pop()];\n        final int w = stack.isEmpty() ? i : i - stack.peek() - 1;\n        ans = Math.max(ans, h * w);\n      }\n      stack.push(i);\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "85. Maximal Rectangle",
      "code": "class Solution {\n  public int maximalRectangle(char[][] matrix) {\n    if (matrix.length == 0)\n      return 0;\n\n    int ans = 0;\n    int[] hist = new int[matrix[0].length];\n\n    for (char[] row : matrix) {\n      for (int i = 0; i < row.length; ++i)\n        hist[i] = row[i] == '0' ? 0 : hist[i] + 1;\n      ans = Math.max(ans, largestRectangleArea(hist));\n    } \n\n    return ans;\n  } \n\n  private int largestRectangleArea(int[] heights) {\n    int ans = 0;\n    Deque<Integer> stack = new ArrayDeque<>();\n\n    for (int i = 0; i <= heights.length; ++i) {\n      while (!stack.isEmpty() && (i == heights.length || heights[stack.peek()] > heights[i])) {\n        final int h = heights[stack.pop()];\n        final int w = stack.isEmpty() ? i : i - stack.peek() - 1;\n        ans = Math.max(ans, h * w);\n      }\n      stack.push(i);\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "86. Partition List",
      "code": "class Solution {\n  public ListNode partition(ListNode head, int x) {\n    ListNode beforeHead = new ListNode(0);\n    ListNode afterHead = new ListNode(0);\n    ListNode before = beforeHead;\n    ListNode after = afterHead;\n\n    for (; head != null; head = head.next)\n      if (head.val < x) {\n        before.next = head;\n        before = head;\n      } else {\n        after.next = head;\n        after = head;\n      } \n\n    after.next = null;\n    before.next = afterHead.next;\n\n    return beforeHead.next;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "87. Scramble String",
      "code": "class Solution {\n  public boolean isScramble(String s1, String s2) {\n    if (s1.equals(s2))\n      return true;\n    if (s1.length() != s2.length())\n      return false;\n    final String hashedKey = s1 + \"+\" + s2;\n    if (memo.containsKey(hashedKey))\n      return memo.get(hashedKey);\n\n    int[] count = new int[128];\n\n    for (int i = 0; i < s1.length(); ++i) {\n      ++count[s1.charAt(i)];\n      --count[s2.charAt(i)];\n    } \n\n    for (final int c : count)\n      if (c != 0) {\n        memo.put(hashedKey, false);\n        return false;\n      } \n\n    for (int i = 1; i < s1.length(); ++i) {\n      if (isScramble(s1.substring(0, i), s2.substring(0, i)) &&\n          isScramble(s1.substring(i), s2.substring(i))) {\n        memo.put(hashedKey, true);\n        return true;\n      }\n      if (isScramble(s1.substring(0, i), s2.substring(s2.length() - i)) &&\n          isScramble(s1.substring(i), s2.substring(0, s2.length() - i))) {\n        memo.put(hashedKey, true);\n        return true;\n      }\n    } \n\n    memo.put(hashedKey, false);\n    return false;\n  } \n\n  private Map<String, Boolean> memo = new HashMap<>();\n}\n"
    }
  ],
  [
    {
      "id": "88. Merge Sorted Array",
      "code": "class Solution {\n  public void merge(int[] nums1, int m, int[] nums2, int n) {\n    int i = m - 1;     // nums1's index (actual nums)\n    int j = n - 1;     // nums2's index\n    int k = m + n - 1; // nums1's index (next filled position)\n\n    while (j >= 0)\n      if (i >= 0 && nums1[i] > nums2[j])\n        nums1[k--] = nums1[i--];\n      else\n        nums1[k--] = nums2[j--];\n  }\n }\n"
    }
  ],
  [
    {
      "id": "89. Gray Code",
      "code": "class Solution {\n  public List<Integer> grayCode(int n) {\n    List<Integer> ans = new ArrayList<>();\n    ans.add(0);\n\n    for (int i = 0; i < n; ++i)\n      for (int j = ans.size() - 1; j >= 0; --j)\n        ans.add(ans.get(j) | 1 << i);\n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "90. Subsets II",
      "code": "class Solution {\n  public List<List<Integer>> subsetsWithDup(int[] nums) {\n    List<List<Integer>> ans = new ArrayList<>();\n    Arrays.sort(nums);\n    dfs(nums, 0, new ArrayList<>(), ans);\n    return ans;\n  } \n\n  private void dfs(int[] nums, int s, List<Integer> path, List<List<Integer>> ans) {\n    ans.add(new ArrayList<>(path));\n\n    for (int i = s; i < nums.length; ++i) {\n      if (i > s && nums[i] == nums[i - 1])\n        continue;\n      path.add(nums[i]);\n      dfs(nums, i + 1, path, ans);\n      path.remove(path.size() - 1);\n    }\n  }\n }\n"
    }
  ],
  [
    {
      "id": "91. Decode Ways",
      "code": "class Solution {\n  public int numDecodings(String s) {\n    final int n = s.length();\n    // dp[i] := # of ways to decode s[i..n)\n    int[] dp = new int[n + 1];\n    dp[n] = 1; // \"\"\n    dp[n - 1] = isValid(s.charAt(n - 1)) ? 1 : 0;\n\n    for (int i = n - 2; i >= 0; --i) {\n      if (isValid(s.charAt(i)))\n        dp[i] += dp[i + 1];\n      if (isValid(s.charAt(i), s.charAt(i + 1)))\n        dp[i] += dp[i + 2];\n    } \n\n    return dp[0];\n  } \n\n  private boolean isValid(char c) {\n    return c != '0';\n  } \n\n  private boolean isValid(char c1, char c2) {\n    return c1 == '1' || c1 == '2' && c2 < '7';\n  }\n }\n"
    }
  ],
  [
    {
      "id": "92. Reverse Linked List II",
      "code": "class Solution {\n  public ListNode reverseBetween(ListNode head, int left, int right) {\n    if (left == 1)\n      return reverseN(head, right);\n\n    head.next = reverseBetween(head.next, left - 1, right - 1);\n\n    return head;\n  } \n\n  private ListNode reverseN(ListNode head, int n) {\n    if (n == 1)\n      return head;\n\n    ListNode newHead = reverseN(head.next, n - 1);\n    ListNode headNext = head.next;\n    head.next = headNext.next;\n    headNext.next = head;\n\n    return newHead;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "93. Restore IP Addresses",
      "code": "class Solution {\n  public List<String> restoreIpAddresses(final String s) {\n    List<String> ans = new ArrayList<>();\n    dfs(s, 0, new ArrayList<>(), ans);\n    return ans;\n  } \n\n  private void dfs(final String s, int start, List<String> path, List<String> ans) {\n    if (path.size() == 4 && start == s.length()) {\n      ans.add(String.join(\".\", path));\n      return;\n    }\n    if (path.size() == 4 || start == s.length())\n      return;\n\n    for (int length = 1; length <= 3; ++length) {\n      if (start + length > s.length()) // Out of bound\n        return;\n      if (length > 1 && s.charAt(start) == '0') // Leading '0'\n        return;\n      final String num = s.substring(start, start + length);\n      if (Integer.parseInt(num) > 255)\n        return;\n      path.add(num);\n      dfs(s, start + length, path, ans);\n      path.remove(path.size() - 1);\n    }\n  }\n }\n"
    }
  ],
  [
    {
      "id": "94. Binary Tree Inorder Traversal",
      "code": "class Solution {\n  public List<Integer> inorderTraversal(TreeNode root) {\n    List<Integer> ans = new ArrayList<>();\n    Deque<TreeNode> stack = new ArrayDeque<>();\n\n    while (root != null || !stack.isEmpty()) {\n      while (root != null) {\n        stack.push(root);\n        root = root.left;\n      }\n      root = stack.pop();\n      ans.add(root.val);\n      root = root.right;\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "95. Unique Binary Search Trees II",
      "code": "class Solution {\n  public List<TreeNode> generateTrees(int n) {\n    if (n == 0)\n      return new ArrayList<>();\n    return generateTrees(1, n);\n  } \n\n  private List<TreeNode> generateTrees(int min, int max) {\n    if (min > max)\n      return Arrays.asList((TreeNode) null);\n\n    List<TreeNode> ans = new ArrayList<>();\n\n    for (int i = min; i <= max; ++i)\n      for (TreeNode left : generateTrees(min, i - 1))\n        for (TreeNode right : generateTrees(i + 1, max)) {\n          ans.add(new TreeNode(i));\n          ans.get(ans.size() - 1).left = left;\n          ans.get(ans.size() - 1).right = right;\n        } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "96. Unique Binary Search Trees",
      "code": "class Solution {\n  public int numTrees(int n) {\n    // G[i] := # of unique BST's that store values 1..i\n    int[] G = new int[n + 1];\n    G[0] = 1;\n    G[1] = 1;\n\n    for (int i = 2; i <= n; ++i)\n      for (int j = 0; j < i; ++j)\n        G[i] += G[j] * G[i - j - 1];\n\n    return G[n];\n  }\n }\n"
    }
  ],
  [
    {
      "id": "97. Interleaving String",
      "code": "class Solution {\n  public boolean isInterleave(String s1, String s2, String s3) {\n    final int m = s1.length();\n    final int n = s2.length();\n    if (m + n != s3.length())\n      return false;\n\n    // dp[i][j] := true if s3[0..i + j) is formed by the interleaving of\n    //             s1[0..i) and s2[0..j)\n    boolean[][] dp = new boolean[m + 1][n + 1];\n    dp[0][0] = true;\n\n    for (int i = 1; i <= m; ++i)\n      dp[i][0] = dp[i - 1][0] && s1.charAt(i - 1) == s3.charAt(i - 1);\n\n    for (int j = 1; j <= n; ++j)\n      dp[0][j] = dp[0][j - 1] && s2.charAt(j - 1) == s3.charAt(j - 1);\n\n    for (int i = 1; i <= m; ++i)\n      for (int j = 1; j <= n; ++j)\n        dp[i][j] = dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1) ||\n                   dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1);\n\n    return dp[m][n];\n  }\n }\n"
    }
  ],
  [
    {
      "id": "98. Validate Binary Search Tree",
      "code": "class Solution {\n  public boolean isValidBST(TreeNode root) {\n    return isValidBST(root, null, null);\n  } \n\n  private boolean isValidBST(TreeNode root, TreeNode minNode, TreeNode maxNode) {\n    if (root == null)\n      return true;\n    if (minNode != null && root.val <= minNode.val)\n      return false;\n    if (maxNode != null && root.val >= maxNode.val)\n      return false;\n\n    return isValidBST(root.left, minNode, root) &&\n           isValidBST(root.right, root, maxNode);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "99. Recover Binary Search Tree",
      "code": "class Solution {\n  public void recoverTree(TreeNode root) {\n    inorder(root);\n    swap(x, y);\n  } \n\n  private TreeNode pred = null;\n  private TreeNode x = null;\n  private TreeNode y = null;\n\n  private void inorder(TreeNode root) {\n    if (root == null)\n      return;\n\n    inorder(root.left);\n\n    if (pred != null && root.val < pred.val) {\n      y = root;\n      if (x == null)\n        x = pred;\n      else\n        return;\n    }\n    pred = root;\n\n    inorder(root.right);\n  } \n\n  private void swap(TreeNode x, TreeNode y) {\n    final int temp = x.val;\n    x.val = y.val;\n    y.val = temp;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "100. Same Tree",
      "code": "class Solution {\n  public boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null || q == null)\n      return p == q;\n    return p.val == q.val &&\n           isSameTree(p.left, q.left) &&\n           isSameTree(p.right, q.right);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "101. Symmetric Tree",
      "code": "class Solution {\n  public boolean isSymmetric(TreeNode root) {\n    return isSymmetric(root, root);\n  } \n\n  private boolean isSymmetric(TreeNode p, TreeNode q) {\n    if (p == null || q == null)\n      return p == q;\n\n    return p.val == q.val && isSymmetric(p.left, q.right) && isSymmetric(p.right, q.left);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "102. Binary Tree Level Order Traversal",
      "code": "class Solution {\n  public List<List<Integer>> levelOrder(TreeNode root) {\n    if (root == null)\n      return new ArrayList<>();\n\n    List<List<Integer>> ans = new ArrayList<>();\n    Queue<TreeNode> q = new ArrayDeque<>(Arrays.asList(root));\n\n    while (!q.isEmpty()) {\n      List<Integer> currLevel = new ArrayList<>();\n      for (int sz = q.size(); sz > 0; --sz) {\n        TreeNode node = q.poll();\n        currLevel.add(node.val);\n        if (node.left != null)\n          q.offer(node.left);\n        if (node.right != null)\n          q.offer(node.right);\n      }\n      ans.add(currLevel);\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "103. Binary Tree Zigzag Level Order Traversal",
      "code": "class Solution {\n  public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n    if (root == null)\n      return new ArrayList<>();\n\n    List<List<Integer>> ans = new ArrayList<>();\n    Deque<TreeNode> q = new ArrayDeque<>(Arrays.asList(root));\n    boolean isLeftToRight = true;\n\n    while (!q.isEmpty()) {\n      List<Integer> currLevel = new ArrayList<>();\n      for (int sz = q.size(); sz > 0; --sz)\n        if (isLeftToRight) {\n          TreeNode node = q.pollFirst();\n          currLevel.add(node.val);\n          if (node.left != null)\n            q.addLast(node.left);\n          if (node.right != null)\n            q.addLast(node.right);\n        } else {\n          TreeNode node = q.pollLast();\n          currLevel.add(node.val);\n          if (node.right != null)\n            q.addFirst(node.right);\n          if (node.left != null)\n            q.addFirst(node.left);\n        }\n      ans.add(currLevel);\n      isLeftToRight = !isLeftToRight;\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "104. Maximum Depth of Binary Tree",
      "code": "class Solution {\n  public int maxDepth(TreeNode root) {\n    if (root == null)\n      return 0;\n    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n  }\n }\n"
    }
  ],
  [
    {
      "id": "105. Construct Binary Tree from Preorder and Inorder Traversal",
      "code": "class Solution {\n  public TreeNode buildTree(int[] preorder, int[] inorder) {\n    Map<Integer, Integer> inToIndex = new HashMap<>();\n\n    for (int i = 0; i < inorder.length; ++i)\n      inToIndex.put(inorder[i], i);\n\n    return build(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1, inToIndex);\n  } \n\n  private TreeNode build(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart,\n                         int inEnd, Map<Integer, Integer> inToIndex) {\n    if (preStart > preEnd)\n      return null;\n\n    final int rootVal = preorder[preStart];\n    final int rootInIndex = inToIndex.get(rootVal);\n    final int leftSize = rootInIndex - inStart;\n\n    TreeNode root = new TreeNode(rootVal);\n    root.left = build(preorder, preStart + 1, preStart + leftSize, inorder, inStart,\n                      rootInIndex - 1, inToIndex);\n    root.right = build(preorder, preStart + leftSize + 1, preEnd, inorder, rootInIndex + 1, inEnd,\n                       inToIndex);\n\n    return root;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "106. Construct Binary Tree from Inorder and Postorder Traversal",
      "code": "class Solution {\n  public TreeNode buildTree(int[] inorder, int[] postorder) {\n    Map<Integer, Integer> inToIndex = new HashMap<>();\n\n    for (int i = 0; i < inorder.length; ++i)\n      inToIndex.put(inorder[i], i);\n\n    return build(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1, inToIndex);\n  } \n\n  TreeNode build(int[] inorder, int inStart, int inEnd, int[] postorder, int postStart, int postEnd,\n                 Map<Integer, Integer> inToIndex) {\n    if (inStart > inEnd)\n      return null;\n\n    final int rootVal = postorder[postEnd];\n    final int rootInIndex = inToIndex.get(rootVal);\n    final int leftSize = rootInIndex - inStart;\n\n    TreeNode root = new TreeNode(rootVal);\n    root.left = build(inorder, inStart, rootInIndex - 1, postorder, postStart,\n                      postStart + leftSize - 1, inToIndex);\n    root.right = build(inorder, rootInIndex + 1, inEnd, postorder, postStart + leftSize,\n                       postEnd - 1, inToIndex);\n    return root;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "107. Binary Tree Level Order Traversal II",
      "code": "class Solution {\n  public List<List<Integer>> levelOrderBottom(TreeNode root) {\n    if (root == null)\n      return new ArrayList<>();\n\n    List<List<Integer>> ans = new ArrayList<>();\n    Queue<TreeNode> q = new ArrayDeque<>(Arrays.asList(root));\n\n    while (!q.isEmpty()) {\n      List<Integer> currLevel = new ArrayList<>();\n      for (int sz = q.size(); sz > 0; --sz) {\n        TreeNode node = q.poll();\n        currLevel.add(node.val);\n        if (node.left != null)\n          q.offer(node.left);\n        if (node.right != null)\n          q.offer(node.right);\n      }\n      ans.add(currLevel);\n    } \n\n    Collections.reverse(ans);\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "108. Convert Sorted Array to Binary Search Tree",
      "code": "class Solution {\n  public TreeNode sortedArrayToBST(int[] nums) {\n    return build(nums, 0, nums.length - 1);\n  } \n\n  private TreeNode build(int[] nums, int l, int r) {\n    if (l > r)\n      return null;\n\n    final int m = (l + r) / 2;\n    return new TreeNode(nums[m],\n                        build(nums, l, m - 1),\n                        build(nums, m + 1, r));\n  }\n }\n"
    }
  ],
  [
    {
      "id": "109. Convert Sorted List to Binary Search Tree",
      "code": "class Solution {\n  public TreeNode sortedListToBST(ListNode head) {\n    if (head == null)\n      return null;\n    if (head.next == null)\n      return new TreeNode(head.val);\n\n    ListNode mid = findMid(head);\n    TreeNode root = new TreeNode(mid.val);\n    root.left = sortedListToBST(head);\n    root.right = sortedListToBST(mid.next);\n\n    return root;\n  } \n\n  private ListNode findMid(ListNode head) {\n    ListNode prev = null;\n    ListNode slow = head;\n    ListNode fast = head;\n\n    while (fast != null && fast.next != null) {\n      prev = slow;\n      slow = slow.next;\n      fast = fast.next.next;\n    }\n    prev.next = null;\n\n    return slow;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "110. Balanced Binary Tree",
      "code": "class Solution {\n  public boolean isBalanced(TreeNode root) {\n    if (root == null)\n      return true;\n    return Math.abs(maxDepth(root.left) - maxDepth(root.right)) <= 1 &&\n           isBalanced(root.left) &&\n           isBalanced(root.right);\n  } \n\n  private int maxDepth(TreeNode root) {\n    if (root == null)\n      return 0;\n    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n  }\n }\n"
    }
  ],
  [
    {
      "id": "111. Minimum Depth of Binary Tree",
      "code": "class Solution {\n  public int minDepth(TreeNode root) {\n    if (root == null)\n      return 0;\n    if (root.left == null)\n      return minDepth(root.right) + 1;\n    if (root.right == null)\n      return minDepth(root.left) + 1;\n    return Math.min(minDepth(root.left), minDepth(root.right)) + 1;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "112. Path Sum",
      "code": "class Solution {\n  public boolean hasPathSum(TreeNode root, int sum) {\n    if (root == null)\n      return false;\n    if (root.val == sum && root.left == null && root.right == null)\n      return true;\n    return hasPathSum(root.left, sum - root.val) ||\n           hasPathSum(root.right, sum - root.val);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "113. Path Sum II",
      "code": "class Solution {\n  public List<List<Integer>> pathSum(TreeNode root, int sum) {\n    List<List<Integer>> ans = new ArrayList<>();\n    dfs(root, sum, new ArrayList<>(), ans);\n    return ans;\n  } \n\n  private void dfs(TreeNode root, int sum, List<Integer> path, List<List<Integer>> ans) {\n    if (root == null)\n      return;\n    if (root.val == sum && root.left == null && root.right == null) {\n      path.add(root.val);\n      ans.add(new ArrayList<>(path));\n      path.remove(path.size() - 1);\n      return;\n    } \n\n    path.add(root.val);\n    dfs(root.left, sum - root.val, path, ans);\n    dfs(root.right, sum - root.val, path, ans);\n    path.remove(path.size() - 1);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "114. Flatten Binary Tree to Linked List",
      "code": "class Solution {\n  public void flatten(TreeNode root) {\n    if (root == null)\n      return;\n\n    flatten(root.left);\n    flatten(root.right);\n\n    TreeNode left = root.left;   // Flattened left\n    TreeNode right = root.right; // Flattened right\n\n    root.left = null;\n    root.right = left;\n\n    // Connect the original right subtree\n    // To the end of new right subtree\n    TreeNode rightmost = root;\n    while (rightmost.right != null)\n      rightmost = rightmost.right;\n    rightmost.right = right;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "115. Distinct Subsequences",
      "code": "class Solution {\n  public int numDistinct(String s, String t) {\n    final int m = s.length();\n    final int n = t.length();\n    long[][] dp = new long[m + 1][n + 1];\n\n    for (int i = 0; i <= m; ++i)\n      dp[i][0] = 1;\n\n    for (int i = 1; i <= m; ++i)\n      for (int j = 1; j <= n; ++j)\n        if (s.charAt(i - 1) == t.charAt(j - 1))\n          dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n        else\n          dp[i][j] = dp[i - 1][j];\n\n    return (int) dp[m][n];\n  }\n }\n"
    }
  ],
  [
    {
      "id": "116. Populating Next Right Pointers in Each Node",
      "code": "class Solution {\n  public Node connect(Node root) {\n    if (root == null)\n      return null;\n    connectTwoNodes(root.left, root.right);\n    return root;\n  } \n\n  private void connectTwoNodes(Node p, Node q) {\n    if (p == null)\n      return;\n    p.next = q;\n    connectTwoNodes(p.left, p.right);\n    connectTwoNodes(q.left, q.right);\n    connectTwoNodes(p.right, q.left);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "117. Populating Next Right Pointers in Each Node II",
      "code": "class Solution {\n  public Node connect(Node root) {\n    Node node = root; // The node just above current needling\n\n    while (node != null) {\n      Node dummy = new Node(); // Dummy node before needling\n      // Needle children of node\n      for (Node needle = dummy; node != null; node = node.next) {\n        if (node.left != null) { // Needle left child\n          needle.next = node.left;\n          needle = needle.next;\n        }\n        if (node.right != null) { // Needle right child\n          needle.next = node.right;\n          needle = needle.next;\n        }\n      }\n      node = dummy.next; // Move node to the next level\n    } \n\n    return root;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "118. Pascal's Triangle",
      "code": "class Solution {\n  public List<List<Integer>> generate(int numRows) {\n    List<List<Integer>> ans = new ArrayList<>();\n\n    for (int i = 0; i < numRows; ++i) {\n      Integer[] temp = new Integer[i + 1];\n      Arrays.fill(temp, 1);\n      ans.add(Arrays.asList(temp));\n    } \n\n    for (int i = 2; i < numRows; ++i)\n      for (int j = 1; j < ans.get(i).size() - 1; ++j)\n        ans.get(i).set(j, ans.get(i - 1).get(j - 1) + ans.get(i - 1).get(j));\n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "119. Pascal's Triangle II",
      "code": "class Solution {\n  public List<Integer> getRow(int rowIndex) {\n    Integer[] ans = new Integer[rowIndex + 1];\n    Arrays.fill(ans, 1);\n\n    for (int i = 2; i < rowIndex + 1; ++i)\n      for (int j = 1; j < i; ++j)\n        ans[i - j] += ans[i - j - 1];\n\n    return Arrays.asList(ans);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "120. Triangle",
      "code": "class Solution {\n  public int minimumTotal(List<List<Integer>> triangle) {\n    for (int i = triangle.size() - 2; i >= 0; --i)\n      for (int j = 0; j <= i; ++j)\n        triangle.get(i).set(j, triangle.get(i).get(j) + Math.min(triangle.get(i + 1).get(j),\n        triangle.get(i + 1).get(j + 1)));\n    return triangle.get(0).get(0);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "121. Best Time to Buy and Sell Stock",
      "code": "class Solution {\n  public int maxProfit(int[] prices) {\n    int sellOne = 0;\n    int holdOne = Integer.MIN_VALUE;\n\n    for (final int price : prices) {\n      sellOne = Math.max(sellOne, holdOne + price);\n      holdOne = Math.max(holdOne, -price);\n    } \n\n    return sellOne;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "122. Best Time to Buy and Sell Stock II",
      "code": "class Solution {\n  public int maxProfit(int[] prices) {\n    int sell = 0;\n    int hold = Integer.MIN_VALUE;\n\n    for (final int price : prices) {\n      sell = Math.max(sell, hold + price);\n      hold = Math.max(hold, sell - price);\n    } \n\n    return sell;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "123. Best Time to Buy and Sell Stock III",
      "code": "class Solution {\n  public int maxProfit(int[] prices) {\n    int sellTwo = 0;\n    int holdTwo = Integer.MIN_VALUE;\n    int sellOne = 0;\n    int holdOne = Integer.MIN_VALUE;\n\n    for (final int price : prices) {\n      sellTwo = Math.max(sellTwo, holdTwo + price);\n      holdTwo = Math.max(holdTwo, sellOne - price);\n      sellOne = Math.max(sellOne, holdOne + price);\n      holdOne = Math.max(holdOne, -price);\n    } \n\n    return sellTwo;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "124. Binary Tree Maximum Path Sum",
      "code": "class Solution {\n  public int maxPathSum(TreeNode root) {\n    maxPathSumDownFrom(root);\n    return ans;\n  } \n\n  private int ans = Integer.MIN_VALUE;\n\n  // root->val + 0/1 of its subtrees\n  private int maxPathSumDownFrom(TreeNode root) {\n    if (root == null)\n      return 0;\n\n    final int l = Math.max(maxPathSumDownFrom(root.left), 0);\n    final int r = Math.max(maxPathSumDownFrom(root.right), 0);\n    ans = Math.max(ans, root.val + l + r);\n    return root.val + Math.max(l, r);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "125. Valid Palindrome",
      "code": "class Solution {\n  public boolean isPalindrome(String s) {\n    int l = 0;\n    int r = s.length() - 1;\n\n    while (l < r) {\n      while (l < r && !Character.isLetterOrDigit(s.charAt(l)))\n        ++l;\n      while (l < r && !Character.isLetterOrDigit(s.charAt(r)))\n        --r;\n      if (Character.toLowerCase(s.charAt(l)) != Character.toLowerCase(s.charAt(r)))\n        return false;\n      ++l;\n      --r;\n    } \n\n    return true;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "126. Word Ladder II",
      "code": "class Solution {\n  public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n    Set<String> wordSet = new HashSet<>(wordList);\n    if (!wordSet.contains(endWord))\n      return new ArrayList<>();\n\n    // {\"hit\": [\"hot\"], \"hot\": [\"dot\", \"lot\"], ...}\n    Map<String, List<String>> graph = new HashMap<>();\n\n    // Build graph from beginWord -> endWord\n    if (!bfs(beginWord, endWord, wordSet, graph))\n      return new ArrayList<>();\n\n    List<List<String>> ans = new ArrayList<>();\n    List<String> path = new ArrayList<>(Arrays.asList(beginWord));\n\n    dfs(graph, beginWord, endWord, path, ans);\n    return ans;\n  } \n\n  private boolean bfs(final String beginWord, final String endWord, Set<String> wordSet,\n                      Map<String, List<String>> graph) {\n    Set<String> currentLevelWords = new HashSet<>();\n    currentLevelWords.add(beginWord);\n    boolean reachEndWord = false;\n\n    while (!currentLevelWords.isEmpty()) {\n      for (final String word : currentLevelWords)\n        wordSet.remove(word);\n      Set<String> nextLevelWords = new HashSet<>();\n      for (final String parent : currentLevelWords) {\n        graph.putIfAbsent(parent, new ArrayList<>());\n        for (final String child : getChildren(parent, wordSet)) {\n          if (wordSet.contains(child)) {\n            nextLevelWords.add(child);\n            graph.get(parent).add(child);\n          }\n          if (child.equals(endWord))\n            reachEndWord = true;\n        }\n      }\n      if (reachEndWord)\n        return true;\n      currentLevelWords = nextLevelWords;\n    } \n\n    return false;\n  } \n\n  private List<String> getChildren(final String parent, Set<String> wordSet) {\n    List<String> children = new ArrayList<>();\n    StringBuilder sb = new StringBuilder(parent);\n\n    for (int i = 0; i < sb.length(); ++i) {\n      final char cache = sb.charAt(i);\n      for (char c = 'a'; c <= 'z'; ++c) {\n        if (c == cache)\n          continue;\n        sb.setCharAt(i, c);\n        final String child = sb.toString();\n        if (wordSet.contains(child))\n          children.add(child);\n      }\n      sb.setCharAt(i, cache);\n    } \n\n    return children;\n  } \n\n  private void dfs(Map<String, List<String>> graph, final String word, final String endWord,\n                   List<String> path, List<List<String>> ans) {\n    if (word.equals(endWord)) {\n      ans.add(new ArrayList<>(path));\n      return;\n    }\n    if (!graph.containsKey(word))\n      return;\n\n    for (final String child : graph.get(word)) {\n      path.add(child);\n      dfs(graph, child, endWord, path, ans);\n      path.remove(path.size() - 1);\n    }\n  }\n }\n"
    }
  ],
  [
    {
      "id": "127. Word Ladder",
      "code": "class Solution {\n  public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n    Set<String> wordSet = new HashSet<>(wordList);\n    if (!wordSet.contains(endWord))\n      return 0;\n\n    int ans = 0;\n    Queue<String> q = new ArrayDeque<>(Arrays.asList(beginWord));\n\n    while (!q.isEmpty()) {\n      ++ans;\n      for (int sz = q.size(); sz > 0; --sz) {\n        StringBuilder sb = new StringBuilder(q.poll());\n        for (int i = 0; i < sb.length(); ++i) {\n          final char cache = sb.charAt(i);\n          for (char c = 'a'; c <= 'z'; ++c) {\n            sb.setCharAt(i, c);\n            final String word = sb.toString();\n            if (word.equals(endWord))\n              return ans + 1;\n            if (wordSet.contains(word)) {\n              q.offer(word);\n              wordSet.remove(word);\n            }\n          }\n          sb.setCharAt(i, cache);\n        }\n      }\n    } \n\n    return 0;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "128. Longest Consecutive Sequence",
      "code": "class Solution {\n  public int longestConsecutive(int[] nums) {\n    int ans = 0;\n    Set<Integer> seen = Arrays.stream(nums).boxed().collect(Collectors.toSet());\n\n    for (int num : nums) {\n      // Num is the start of a sequence\n      if (seen.contains(num - 1))\n        continue;\n      int length = 1;\n      while (seen.contains(++num))\n        ++length;\n      ans = Math.max(ans, length);\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "129. Sum Root to Leaf Numbers",
      "code": "class Solution {\n  public int sumNumbers(TreeNode root) {\n    dfs(root, 0);\n    return ans;\n  } \n\n  private int ans = 0;\n\n  private void dfs(TreeNode root, int path) {\n    if (root == null)\n      return;\n    if (root.left == null && root.right == null) {\n      ans += path * 10 + root.val;\n      return;\n    } \n\n    dfs(root.left, path * 10 + root.val);\n    dfs(root.right, path * 10 + root.val);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "130. Surrounded Regions",
      "code": "class Solution {\n  public void solve(char[][] board) {\n    if (board.length == 0)\n      return;\n\n    final int m = board.length;\n    final int n = board[0].length;\n    final int[] dirs = {0, 1, 0, -1, 0};\n    Queue<int[]> q = new ArrayDeque<>();\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (i * j == 0 || i == m - 1 || j == n - 1)\n          if (board[i][j] == 'O') {\n            q.offer(new int[] {i, j});\n            board[i][j] = '*';\n          } \n\n    // Mark grids that stretch from four sides with '*'\n    while (!q.isEmpty()) {\n      final int i = q.peek()[0];\n      final int j = q.poll()[1];\n      for (int k = 0; k < 4; ++k) {\n        final int x = i + dirs[k];\n        final int y = j + dirs[k + 1];\n        if (x < 0 || x == m || y < 0 || y == n)\n          continue;\n        if (board[x][y] != 'O')\n          continue;\n        q.offer(new int[] {x, y});\n        board[x][y] = '*';\n      }\n    } \n\n    for (char[] row : board)\n      for (int i = 0; i < row.length; ++i)\n        if (row[i] == '*')\n          row[i] = 'O';\n        else if (row[i] == 'O')\n          row[i] = 'X';\n  }\n }\n"
    }
  ],
  [
    {
      "id": "131. Palindrome Partitioning",
      "code": "class Solution {\n  public List<List<String>> partition(String s) {\n    List<List<String>> ans = new ArrayList<>();\n    dfs(s, 0, new ArrayList<>(), ans);\n    return ans;\n  } \n\n  private void dfs(final String s, int start, List<String> path, List<List<String>> ans) {\n    if (start == s.length()) {\n      ans.add(new ArrayList<>(path));\n      return;\n    } \n\n    for (int i = start; i < s.length(); ++i)\n      if (isPalindrome(s, start, i)) {\n        path.add(s.substring(start, i + 1));\n        dfs(s, i + 1, path, ans);\n        path.remove(path.size() - 1);\n      }\n  } \n\n  private boolean isPalindrome(final String s, int l, int r) {\n    while (l < r)\n      if (s.charAt(l++) != s.charAt(r--))\n        return false;\n    return true;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "132. Palindrome Partitioning II",
      "code": "class Solution {\n  public int minCut(String s) {\n    final int n = s.length();\n    // isPalindrome[i][j] := true if s[i..j] is a palindrome\n    boolean[][] isPalindrome = new boolean[n][n];\n    for (boolean[] row : isPalindrome)\n      Arrays.fill(row, true);\n    // dp[i] := min cuts needed for a palindrome partitioning of s[0..i]\n    int[] dp = new int[n];\n    Arrays.fill(dp, n);\n\n    for (int l = 2; l <= n; ++l)\n      for (int i = 0, j = l - 1; j < n; ++i, ++j)\n        isPalindrome[i][j] = s.charAt(i) == s.charAt(j) && isPalindrome[i + 1][j - 1];\n\n    for (int i = 0; i < n; ++i) {\n      if (isPalindrome[0][i]) {\n        dp[i] = 0;\n        continue;\n      } \n\n      // Try all possible partitions\n      for (int j = 0; j < i; ++j)\n        if (isPalindrome[j + 1][i])\n          dp[i] = Math.min(dp[i], dp[j] + 1);\n    } \n\n    return dp[n - 1];\n  }\n }\n"
    }
  ],
  [
    {
      "id": "133. Clone Graph",
      "code": "class Solution {\n  public Node cloneGraph(Node node) {\n    if (node == null)\n      return null;\n\n    Queue<Node> q = new ArrayDeque<>(Arrays.asList(node));\n    Map<Node, Node> map = new HashMap<>();\n    map.put(node, new Node(node.val));\n\n    while (!q.isEmpty()) {\n      Node u = q.poll();\n      for (Node v : u.neighbors) {\n        if (!map.containsKey(v)) {\n          map.put(v, new Node(v.val));\n          q.offer(v);\n        }\n        map.get(u).neighbors.add(map.get(v));\n      }\n    } \n\n    return map.get(node);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "134. Gas Station",
      "code": "class Solution {\n  public int canCompleteCircuit(int[] gas, int[] cost) {\n    final int gasses = Arrays.stream(gas).sum();\n    final int costs = Arrays.stream(cost).sum();\n    if (gasses - costs < 0)\n      return -1;\n\n    int ans = 0;\n    int sum = 0;\n\n    // Try to start from each index\n    for (int i = 0; i < gas.length; ++i) {\n      sum += gas[i] - cost[i];\n      if (sum < 0) {\n        sum = 0;\n        ans = i + 1; // Start from next index\n      }\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "135. Candy",
      "code": "class Solution {\n  public int candy(int[] ratings) {\n    final int n = ratings.length;\n\n    int ans = 0;\n    int[] l = new int[n];\n    int[] r = new int[n];\n    Arrays.fill(l, 1);\n    Arrays.fill(r, 1);\n\n    for (int i = 1; i < n; ++i)\n      if (ratings[i] > ratings[i - 1])\n        l[i] = l[i - 1] + 1;\n\n    for (int i = n - 2; i >= 0; --i)\n      if (ratings[i] > ratings[i + 1])\n        r[i] = r[i + 1] + 1;\n\n    for (int i = 0; i < n; ++i)\n      ans += Math.max(l[i], r[i]);\n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "136. Single Number",
      "code": "class Solution {\n  public int singleNumber(int[] nums) {\n    int ans = 0;\n\n    for (final int num : nums)\n      ans ^= num;\n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "137. Single Number II",
      "code": "class Solution {\n  public int singleNumber(int[] nums) {\n    int ans = 0;\n\n    for (int i = 0; i < 32; ++i) {\n      int sum = 0;\n      for (final int num : nums)\n        sum += num >> i & 1;\n      sum %= 3;\n      ans |= sum << i;\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "138. Copy List with Random Pointer",
      "code": "class Solution {\n  public Node copyRandomList(Node head) {\n    if (head == null)\n      return null;\n    if (map.containsKey(head))\n      return map.get(head);\n\n    Node newNode = new Node(head.val);\n    map.put(head, newNode);\n    newNode.next = copyRandomList(head.next);\n    newNode.random = copyRandomList(head.random);\n    return newNode;\n  } \n\n  private Map<Node, Node> map = new HashMap<>();\n}\n"
    }
  ],
  [
    {
      "id": "139. Word Break",
      "code": "class Solution {\n  public boolean wordBreak(String s, List<String> wordDict) {\n    return wordBreak(s, new HashSet<>(wordDict), new HashMap<>());\n  } \n\n  private boolean wordBreak(final String s, Set<String> wordSet, Map<String, Boolean> memo) {\n    if (memo.containsKey(s))\n      return memo.get(s);\n    if (wordSet.contains(s)) {\n      memo.put(s, true);\n      return true;\n    } \n\n    // 1 <= prefix.length() < s.length()\n    for (int i = 1; i < s.length(); ++i) {\n      final String prefix = s.substring(0, i);\n      final String suffix = s.substring(i);\n      if (wordSet.contains(prefix) && wordBreak(suffix, wordSet, memo)) {\n        memo.put(s, true);\n        return true;\n      }\n    } \n\n    memo.put(s, false);\n    return false;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "140. Word Break II",
      "code": "class Solution {\n  public List<String> wordBreak(String s, List<String> wordDict) {\n    Set<String> wordSet = new HashSet<>(wordDict);\n    Map<String, List<String>> memo = new HashMap<>();\n    return wordBreak(s, wordSet, memo);\n  } \n\n  private List<String> wordBreak(final String s, Set<String> wordSet,\n                                 Map<String, List<String>> memo) {\n    if (memo.containsKey(s))\n      return memo.get(s);\n\n    List<String> ans = new ArrayList<>();\n\n    // 1 <= prefix.length() < s.length()\n    for (int i = 1; i < s.length(); ++i) {\n      final String prefix = s.substring(0, i);\n      final String suffix = s.substring(i);\n      if (wordSet.contains(prefix))\n        for (final String word : wordBreak(suffix, wordSet, memo))\n          ans.add(prefix + \" \" + word);\n    } \n\n    // Contains whole string, so don't add any space\n    if (wordSet.contains(s))\n      ans.add(s);\n\n    memo.put(s, ans);\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "141. Linked List Cycle",
      "code": "public class Solution {\n  public boolean hasCycle(ListNode head) {\n    ListNode slow = head;\n    ListNode fast = head;\n\n    while (fast != null && fast.next != null) {\n      slow = slow.next;\n      fast = fast.next.next;\n      if (slow == fast)\n        return true;\n    } \n\n    return false;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "142. Linked List Cycle II",
      "code": "public class Solution {\n  public ListNode detectCycle(ListNode head) {\n    ListNode slow = head;\n    ListNode fast = head;\n\n    while (fast != null && fast.next != null) {\n      slow = slow.next;\n      fast = fast.next.next;\n      if (slow == fast) {\n        slow = head;\n        while (slow != fast) {\n          slow = slow.next;\n          fast = fast.next;\n        }\n        return slow;\n      }\n    } \n\n    return null;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "143. Reorder List",
      "code": "class Solution {\n  public void reorderList(ListNode head) {\n    if (head == null || head.next == null)\n      return;\n\n    ListNode mid = findMid(head);\n    ListNode reversed = reverse(mid);\n    merge(head, reversed);\n  } \n\n  private ListNode findMid(ListNode head) {\n    ListNode prev = null;\n    ListNode slow = head;\n    ListNode fast = head;\n\n    while (fast != null && fast.next != null) {\n      prev = slow;\n      slow = slow.next;\n      fast = fast.next.next;\n    }\n    prev.next = null;\n\n    return slow;\n  } \n\n  private ListNode reverse(ListNode head) {\n    ListNode prev = null;\n    ListNode curr = head;\n\n    while (curr != null) {\n      ListNode next = curr.next;\n      curr.next = prev;\n      prev = curr;\n      curr = next;\n    } \n\n    return prev;\n  } \n\n  private void merge(ListNode l1, ListNode l2) {\n    while (l2 != null) {\n      ListNode next = l1.next;\n      l1.next = l2;\n      l1 = l2;\n      l2 = next;\n    }\n  }\n }\n"
    }
  ],
  [
    {
      "id": "144. Binary Tree Preorder Traversal",
      "code": "class Solution {\n  public List<Integer> preorderTraversal(TreeNode root) {\n    List<Integer> ans = new ArrayList<>();\n    preorder(root, ans);\n    return ans;\n  } \n\n  private void preorder(TreeNode root, List<Integer> ans) {\n    if (root == null)\n      return;\n\n    ans.add(root.val);\n    preorder(root.left, ans);\n    preorder(root.right, ans);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "145. Binary Tree Postorder Traversal",
      "code": "class Solution {\n  public List<Integer> postorderTraversal(TreeNode root) {\n    List<Integer> ans = new ArrayList<>();\n    postorder(root, ans);\n    return ans;\n  } \n\n  private void postorder(TreeNode root, List<Integer> ans) {\n    if (root == null)\n      return;\n\n    postorder(root.left, ans);\n    postorder(root.right, ans);\n    ans.add(root.val);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "146. LRU Cache",
      "code": "class Node {\n  public int key;\n  public int value;\n  public Node(int key, int value) {\n    this.key = key;\n    this.value = value;\n  }\n } \n\n class LRUCache {\n  public LRUCache(int capacity) {\n    this.capacity = capacity;\n  } \n\n  public int get(int key) {\n    if (!keyToNode.containsKey(key))\n      return -1;\n\n    Node node = keyToNode.get(key);\n    cache.remove(node);\n    cache.add(node);\n    return node.value;\n  } \n\n  public void put(int key, int value) {\n    if (keyToNode.containsKey(key)) {\n      keyToNode.get(key).value = value;\n      get(key);\n      return;\n    } \n\n    if (cache.size() == capacity) {\n      Node lastNode = cache.iterator().next();\n      cache.remove(lastNode);\n      keyToNode.remove(lastNode.key);\n    } \n\n    Node node = new Node(key, value);\n    cache.add(node);\n    keyToNode.put(key, node);\n  } \n\n  private int capacity;\n  private Set<Node> cache = new LinkedHashSet<>();\n  private Map<Integer, Node> keyToNode = new HashMap<>();\n}\n"
    }
  ],
  [
    {
      "id": "147. Insertion Sort List",
      "code": "class Solution {\n  public ListNode insertionSortList(ListNode head) {\n    ListNode dummy = new ListNode(0);\n    ListNode prev = dummy; // The last (largest) of the sorted list\n\n    while (head != null) {       // Current inserting node\n      ListNode next = head.next; // Cache next inserting node\n      if (prev.val >= head.val)  // `prev` >= current inserting node\n        prev = dummy;            // Move `prev` to the front\n      while (prev.next != null && prev.next.val < head.val)\n        prev = prev.next;\n      head.next = prev.next;\n      prev.next = head;\n      head = next; // Update current inserting node\n    } \n\n    return dummy.next;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "148. Sort List",
      "code": "class Solution {\n  public ListNode sortList(ListNode head) {\n    final int length = getLength(head);\n    ListNode dummy = new ListNode(0, head);\n\n    for (int k = 1; k < length; k *= 2) {\n      ListNode curr = dummy.next;\n      ListNode tail = dummy;\n      while (curr != null) {\n        ListNode l = curr;\n        ListNode r = split(l, k);\n        curr = split(r, k);\n        ListNode[] merged = merge(l, r);\n        tail.next = merged[0];\n        tail = merged[1];\n      }\n    } \n\n    return dummy.next;\n  } \n\n  private int getLength(ListNode head) {\n    int length = 0;\n    for (ListNode curr = head; curr != null; curr = curr.next)\n      ++length;\n    return length;\n  } \n\n  private ListNode split(ListNode head, int k) {\n    while (--k > 0 && head != null)\n      head = head.next;\n    ListNode rest = head == null ? null : head.next;\n    if (head != null)\n      head.next = null;\n    return rest;\n  } \n\n  private ListNode[] merge(ListNode l1, ListNode l2) {\n    ListNode dummy = new ListNode(0);\n    ListNode tail = dummy;\n\n    while (l1 != null && l2 != null) {\n      if (l1.val > l2.val) {\n        ListNode temp = l1;\n        l1 = l2;\n        l2 = temp;\n      }\n      tail.next = l1;\n      l1 = l1.next;\n      tail = tail.next;\n    }\n    tail.next = l1 == null ? l2 : l1;\n    while (tail.next != null)\n      tail = tail.next;\n\n    return new ListNode[] {dummy.next, tail};\n  }\n }\n"
    }
  ],
  [
    {
      "id": "149. Max Points on a Line",
      "code": "class Solution {\n  public int maxPoints(int[][] points) {\n    int ans = 0;\n\n    for (int i = 0; i < points.length; ++i) {\n      Map<Pair<Integer, Integer>, Integer> slopeCount = new HashMap<>();\n      int[] p1 = points[i];\n      int samePoints = 1;\n      int maxPoints = 0; // Maximum number of points with the same slope\n      for (int j = i + 1; j < points.length; ++j) {\n        int[] p2 = points[j];\n        if (p1[0] == p2[0] && p1[1] == p2[1])\n          ++samePoints;\n        else {\n          Pair<Integer, Integer> slope = getSlope(p1, p2);\n          slopeCount.merge(slope, 1, Integer::sum);\n          maxPoints = Math.max(maxPoints, slopeCount.get(slope));\n        }\n      }\n      ans = Math.max(ans, samePoints + maxPoints);\n    } \n\n    return ans;\n  } \n\n  private Pair<Integer, Integer> getSlope(int[] p, int[] q) {\n    final int dx = p[0] - q[0];\n    final int dy = p[1] - q[1];\n    if (dx == 0)\n      return new Pair<>(0, p[0]);\n    if (dy == 0)\n      return new Pair<>(p[1], 0);\n    final int d = gcd(dx, dy);\n    return new Pair<>(dx / d, dy / y);\n  } \n\n  private int gcd(int a, int b) {\n    return b == 0 ? a : gcd(b, a % b);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "150. Evaluate Reverse Polish Notation",
      "code": "class Solution {\n  public int evalRPN(String[] tokens) {\n    Deque<Long> stack = new ArrayDeque<>();\n\n    for (final String token : tokens)\n      switch (token) {\n        case \"+\":\n          stack.push(stack.pop() + stack.pop());\n          break;\n        case \"-\":\n          stack.push(-stack.pop() + stack.pop());\n          break;\n        case \"*\":\n          stack.push(stack.pop() * stack.pop());\n          break;\n        case \"/\":\n          final long b = stack.pop();\n          final long a = stack.pop();\n          stack.push(a / b);\n          break;\n        default:\n          stack.push(Long.parseLong(token));\n      } \n\n    return stack.peek().intValue();\n  }\n }\n"
    }
  ],
  [
    {
      "id": "151. Reverse Words in a String",
      "code": "class Solution {\n  public String reverseWords(String s) {\n    StringBuilder sb = new StringBuilder(s).reverse(); // Reverse the whole string\n    reverseWords(sb, sb.length());                     // Reverse each word\n    return cleanSpaces(sb, sb.length());               // Clean up spaces\n  } \n\n  private void reverseWords(StringBuilder sb, int n) {\n    int i = 0;\n    int j = 0;\n\n    while (i < n) {\n      while (i < j || i < n && sb.charAt(i) == ' ') // Skip spaces\n        ++i;\n      while (j < i || j < n && sb.charAt(j) != ' ') // Skip non spaces\n        ++j;\n      reverse(sb, i, j - 1); // Reverse the word\n    }\n  } \n\n  // Trim leading, trailing, and middle spaces\n  private String cleanSpaces(StringBuilder sb, int n) {\n    int i = 0;\n    int j = 0;\n\n    while (j < n) {\n      while (j < n && sb.charAt(j) == ' ') // Skip spaces\n        ++j;\n      while (j < n && sb.charAt(j) != ' ') // Keep non spaces\n        sb.setCharAt(i++, sb.charAt(j++));\n      while (j < n && sb.charAt(j) == ' ') // Skip spaces\n        ++j;\n      if (j < n) // Keep only one space\n        sb.setCharAt(i++, ' ');\n    } \n\n    return sb.substring(0, i).toString();\n  } \n\n  private void reverse(StringBuilder sb, int l, int r) {\n    while (l < r) {\n      final char temp = sb.charAt(l);\n      sb.setCharAt(l++, sb.charAt(r));\n      sb.setCharAt(r--, temp);\n    }\n  }\n }\n"
    }
  ],
  [
    {
      "id": "152. Maximum Product Subarray",
      "code": "class Solution {\n  public int maxProduct(int[] nums) {\n    int ans = nums[0];\n    int dpMin = nums[0]; // Min so far\n    int dpMax = nums[0]; // Max so far\n\n    for (int i = 1; i < nums.length; ++i) {\n      final int num = nums[i];\n      final int prevMin = dpMin; // dpMin[i - 1]\n      final int prevMax = dpMax; // dpMax[i - 1]\n      if (num < 0) {\n        dpMin = Math.min(prevMax * num, num);\n        dpMax = Math.max(prevMin * num, num);\n      } else {\n        dpMin = Math.min(prevMin * num, num);\n        dpMax = Math.max(prevMax * num, num);\n      }\n      ans = Math.max(ans, dpMax);\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "153. Find Minimum in Rotated Sorted Array",
      "code": "class Solution {\n  public int findMin(int[] nums) {\n    int l = 0;\n    int r = nums.length - 1;\n\n    while (l < r) {\n      final int m = (l + r) / 2;\n      if (nums[m] < nums[r])\n        r = m;\n      else\n        l = m + 1;\n    } \n\n    return nums[l];\n  }\n }\n"
    }
  ],
  [
    {
      "id": "154. Find Minimum in Rotated Sorted Array II",
      "code": "class Solution {\n  public int findMin(int[] nums) {\n    int l = 0;\n    int r = nums.length - 1;\n\n    while (l < r) {\n      final int m = (l + r) / 2;\n      if (nums[m] == nums[r])\n        --r;\n      else if (nums[m] < nums[r])\n        r = m;\n      else\n        l = m + 1;\n    } \n\n    return nums[l];\n  }\n }\n"
    }
  ],
  [
    {
      "id": "155. Min Stack",
      "code": "class MinStack {\n  public void push(int x) {\n    if (stack.isEmpty())\n      stack.push(new int[] {x, x});\n    else\n      stack.push(new int[] {x, Math.min(x, stack.peek()[1])});\n  } \n\n  public void pop() {\n    stack.pop();\n  } \n\n  public int top() {\n    return stack.peek()[0];\n  } \n\n  public int getMin() {\n    return stack.peek()[1];\n  } \n\n  private Stack<int[]> stack = new Stack<>(); // {x, min}\n }\n"
    }
  ],
  [
    {
      "id": "156. Binary Tree Upside Down",
      "code": "class Solution {\n  public TreeNode upsideDownBinaryTree(TreeNode root) {\n    if (root == null || root.left == null)\n      return root;\n\n    TreeNode newRoot = upsideDownBinaryTree(root.left);\n    root.left.left = root.right; // 2's left = 3 (root's right)\n    root.left.right = root;      // 2's right = 1 (root)\n    root.left = null;\n    root.right = null;\n    return newRoot;\n  }\n }\n"
    }
  ],
  null,
  null,
  [
    {
      "id": "159. Longest Substring with At Most Two Distinct Characters",
      "code": "class Solution {\n  public int lengthOfLongestSubstringTwoDistinct(String s) {\n    int ans = 0;\n    int distinct = 0;\n    int[] count = new int[128];\n\n    for (int l = 0, r = 0; r < s.length(); ++r) {\n      if (++count[s.charAt(r)] == 1)\n        ++distinct;\n      while (distinct == 3)\n        if (--count[s.charAt(l++)] == 0)\n          --distinct;\n      ans = Math.max(ans, r - l + 1);\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "160. Intersection of Two Linked Lists",
      "code": "public class Solution {\n  public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n    ListNode a = headA;\n    ListNode b = headB;\n\n    while (a != b) {\n      a = a == null ? headB : a.next;\n      b = b == null ? headA : b.next;\n    } \n\n    return a;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "161. One Edit Distance",
      "code": "class Solution {\n  public boolean isOneEditDistance(String s, String t) {\n    final int m = s.length();\n    final int n = t.length();\n    if (m > n) // Make sure len(s) <= len(t)\n      return isOneEditDistance(t, s);\n\n    for (int i = 0; i < m; ++i)\n      if (s.charAt(i) != t.charAt(i)) {\n        if (m == n)\n          return s.substring(i + 1).equals(t.substring(i + 1)); // Replace s[i] with t[i]\n        return s.substring(i).equals(t.substring(i + 1));       // Delete t[i]\n      } \n\n    return m + 1 == n; // Delete t[-1]\n  }\n }\n"
    }
  ],
  [
    {
      "id": "162. Find Peak Element",
      "code": "class Solution {\n  public int findPeakElement(int[] nums) {\n    int l = 0;\n    int r = nums.length - 1;\n\n    while (l < r) {\n      final int m = (l + r) / 2;\n      if (nums[m] >= nums[m + 1])\n        r = m;\n      else\n        l = m + 1;\n    } \n\n    return l;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "163. Missing Ranges",
      "code": "class Solution {\n  public List<String> findMissingRanges(int[] nums, int lower, int upper) {\n    if (nums.length == 0)\n      return new ArrayList<>(Arrays.asList(getRange(lower, upper)));\n\n    List<String> ans = new ArrayList<>();\n\n    if (nums[0] > lower)\n      ans.add(getRange(lower, nums[0] - 1));\n\n    for (int i = 1; i < nums.length; ++i)\n      if (nums[i] > nums[i - 1] + 1)\n        ans.add(getRange(nums[i - 1] + 1, nums[i] - 1));\n\n    if (nums[nums.length - 1] < upper)\n      ans.add(getRange(nums[nums.length - 1] + 1, upper));\n\n    return ans;\n  } \n\n  private String getRange(int lo, int hi) {\n    if (lo == hi)\n      return String.valueOf(lo);\n    return lo + \"->\" + hi;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "164. Maximum Gap",
      "code": "class Bucket {\n  public int min;\n  public int max;\n  public Bucket(int min, int max) {\n    this.min = min;\n    this.max = max;\n  }\n } \n\n class Solution {\n  public int maximumGap(int[] nums) {\n    if (nums.length < 2)\n      return 0;\n\n    final int min = Arrays.stream(nums).min().getAsInt();\n    final int max = Arrays.stream(nums).max().getAsInt();\n    if (min == max)\n      return 0;\n\n    final int gap = (int) Math.ceil((double) (max - min) / (nums.length - 1));\n    final int bucketsLength = (max - min) / gap + 1;\n    Bucket[] buckets = new Bucket[bucketsLength];\n\n    for (int i = 0; i < buckets.length; ++i)\n      buckets[i] = new Bucket(Integer.MAX_VALUE, Integer.MIN_VALUE);\n\n    for (final int num : nums) {\n      final int i = (num - min) / gap;\n      buckets[i].min = Math.min(buckets[i].min, num);\n      buckets[i].max = Math.max(buckets[i].max, num);\n    } \n\n    int ans = 0;\n    int prevMax = min;\n\n    for (final Bucket bucket : buckets) {\n      if (bucket.min == Integer.MAX_VALUE) // Empty bucket\n        continue;\n      ans = Math.max(ans, bucket.min - prevMax);\n      prevMax = bucket.max;\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "165. Compare Version Numbers",
      "code": "class Solution {\n  public int compareVersion(String version1, String version2) {\n    final String[] levels1 = version1.split(\"\\\\.\");\n    final String[] levels2 = version2.split(\"\\\\.\");\n    final int length = Math.max(levels1.length, levels2.length);\n\n    for (int i = 0; i < length; ++i) {\n      final Integer v1 = i < levels1.length ? Integer.parseInt(levels1[i]) : 0;\n      final Integer v2 = i < levels2.length ? Integer.parseInt(levels2[i]) : 0;\n      final int compare = v1.compareTo(v2);\n      if (compare != 0)\n        return compare;\n    } \n\n    return 0;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "166. Fraction to Recurring Decimal",
      "code": "class Solution {\n  public String fractionToDecimal(int numerator, int denominator) {\n    if (numerator == 0)\n      return \"0\";\n\n    StringBuilder sb = new StringBuilder();\n\n    if (numerator < 0 ^ denominator < 0)\n      sb.append(\"-\");\n\n    long n = Math.abs((long) numerator);\n    long d = Math.abs((long) denominator);\n    sb.append(n / d);\n\n    if (n % d == 0)\n      return sb.toString();\n\n    sb.append(\".\");\n    Map<Long, Integer> seen = new HashMap<>();\n\n    for (long r = n % d; r > 0; r %= d) {\n      if (seen.containsKey(r)) {\n        sb.insert(seen.get(r), \"(\");\n        sb.append(\")\");\n        break;\n      }\n      seen.put(r, sb.length());\n      r *= 10;\n      sb.append(r / d);\n    } \n\n    return sb.toString();\n  }\n }\n"
    }
  ],
  [
    {
      "id": "167. Two Sum II - Input Array Is Sorted",
      "code": "class Solution {\n  public int[] twoSum(int[] numbers, int target) {\n    int l = 0;\n    int r = numbers.length - 1;\n\n    while (numbers[l] + numbers[r] != target)\n      if (numbers[l] + numbers[r] < target)\n        ++l;\n      else\n        --r;\n\n    return new int[] {l + 1, r + 1};\n  }\n }\n"
    }
  ],
  [
    {
      "id": "168. Excel Sheet Column Title",
      "code": "class Solution {\n  public String convertToTitle(int n) {\n    return n == 0 ? \"\" : convertToTitle((n - 1) / 26) + (char) ('A' + ((n - 1) % 26));\n  }\n }\n"
    }
  ],
  [
    {
      "id": "169. Majority Element",
      "code": "class Solution {\n  public int majorityElement(int[] nums) {\n    Integer ans = null;\n    int count = 0;\n\n    for (final int num : nums) {\n      if (count == 0)\n        ans = num;\n      count += num == ans ? 1 : -1;\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "170. Two Sum III - Data structure design",
      "code": "class TwoSum {\n  public void add(int number) {\n    count.put(number, count.getOrDefault(number, 0) + 1);\n  } \n\n  public boolean find(int value) {\n    for (Map.Entry<Integer, Integer> entry : count.entrySet()) {\n      final int key = entry.getKey();\n      final int remain = value - key;\n      if (key == remain && entry.getValue() > 1)\n        return true;\n      if (key != remain && count.containsKey(remain))\n        return true;\n    } \n\n    return false;\n  } \n\n  private HashMap<Integer, Integer> count = new HashMap<>();\n}\n"
    }
  ],
  [
    {
      "id": "171. Excel Sheet Column Number",
      "code": "class Solution {\n  public int titleToNumber(String s) {\n    int ans = 0;\n\n    for (final char c : s.toCharArray())\n      ans = ans * 26 + c - '@';\n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "172. Factorial Trailing Zeroes",
      "code": "class Solution {\n  public int trailingZeroes(int n) {\n    return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "173. Binary Search Tree Iterator",
      "code": "class BSTIterator {\n  public BSTIterator(TreeNode root) {\n    inorder(root);\n  } \n\n  /** @return the next smallest number */\n  public int next() {\n    return vals.get(i++);\n  } \n\n  /** @return whether we have a next smallest number */\n  public boolean hasNext() {\n    return i < vals.size();\n  } \n\n  private int i = 0;\n  private List<Integer> vals = new ArrayList<>();\n\n  private void inorder(TreeNode root) {\n    if (root == null)\n      return;\n\n    inorder(root.left);\n    vals.add(root.val);\n    inorder(root.right);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "174. Dungeon Game",
      "code": "class Solution {\n  public int calculateMinimumHP(int[][] dungeon) {\n    final int m = dungeon.length;\n    final int n = dungeon[0].length;\n    int[][] dp = new int[m + 1][n + 1];\n    Arrays.stream(dp).forEach(A -> Arrays.fill(A, Integer.MAX_VALUE));\n    dp[m][n - 1] = 1;\n    dp[m - 1][n] = 1;\n\n    for (int i = m - 1; i >= 0; --i)\n      for (int j = n - 1; j >= 0; --j) {\n        dp[i][j] = Math.min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j];\n        dp[i][j] = Math.max(dp[i][j], 1);\n      } \n\n    return dp[0][0];\n  }\n }\n"
    }
  ],
  null,
  null,
  null,
  null,
  [
    {
      "id": "179. Largest Number",
      "code": "class Solution {\n  public String largestNumber(int[] nums) {\n    final String s = Arrays.stream(nums)\n                         .mapToObj(String::valueOf)\n                         .sorted((a, b) -> (b + a).compareTo(a + b))\n                         .collect(Collectors.joining(\"\"));\n    return s.startsWith(\"00\") ? \"0\" : s;\n  }\n }\n"
    }
  ],
  null,
  null,
  null,
  null,
  null,
  null,
  [
    {
      "id": "186. Reverse Words in a String II",
      "code": "class Solution {\n  public void reverseWords(char[] s) {\n    reverse(s, 0, s.length - 1); // Reverse the whole string\n    reverseWords(s, s.length);   // Reverse each word\n  } \n\n  private void reverse(char[] s, int l, int r) {\n    while (l < r) {\n      final char c = s[l];\n      s[l++] = s[r];\n      s[r--] = c;\n    }\n  } \n\n  private void reverseWords(char[] s, int n) {\n    int i = 0;\n    int j = 0;\n\n    while (i < n) {\n      while (i < j || i < n && s[i] == ' ') // Skip spaces\n        ++i;\n      while (j < i || j < n && s[j] != ' ') // Skip non spaces\n        ++j;\n      reverse(s, i, j - 1); // Reverse the word\n    }\n  }\n }\n"
    }
  ],
  [
    {
      "id": "187. Repeated DNA Sequences",
      "code": "class Solution {\n  public List<String> findRepeatedDnaSequences(String s) {\n    Set<String> ans = new HashSet<>();\n    Set<String> seen = new HashSet<>();\n\n    for (int i = 0; i + 10 <= s.length(); ++i) {\n      final String seq = s.substring(i, i + 10);\n      if (seen.contains(seq))\n        ans.add(seq);\n      seen.add(seq);\n    } \n\n    return new ArrayList<>(ans);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "188. Best Time to Buy and Sell Stock IV",
      "code": "class Solution {\n  public int maxProfit(int k, int[] prices) {\n    if (k >= prices.length / 2) {\n      int sell = 0;\n      int hold = Integer.MIN_VALUE;\n\n      for (final int price : prices) {\n        sell = Math.max(sell, hold + price);\n        hold = Math.max(hold, sell - price);\n      } \n\n      return sell;\n    } \n\n    int[] sell = new int[k + 1];\n    int[] hold = new int[k + 1];\n    Arrays.fill(hold, Integer.MIN_VALUE);\n\n    for (final int price : prices)\n      for (int i = k; i > 0; --i) {\n        sell[i] = Math.max(sell[i], hold[i] + price);\n        hold[i] = Math.max(hold[i], sell[i - 1] - price);\n      } \n\n    return sell[k];\n  }\n }\n"
    }
  ],
  [
    {
      "id": "189. Rotate Array",
      "code": "class Solution {\n  public void rotate(int[] nums, int k) {\n    k %= nums.length;\n    reverse(nums, 0, nums.length - 1);\n    reverse(nums, 0, k - 1);\n    reverse(nums, k, nums.length - 1);\n  } \n\n  private void reverse(int[] nums, int l, int r) {\n    while (l < r)\n      swap(nums, l++, r--);\n  } \n\n  private void swap(int[] nums, int l, int r) {\n    final int temp = nums[l];\n    nums[l] = nums[r];\n    nums[r] = temp;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "190. Reverse Bits",
      "code": "public class Solution {\n  // You need treat n as an unsigned value\n  public int reverseBits(int n) {\n    int ans = 0;\n\n    for (int i = 0; i < 32; ++i)\n      if ((n >> i & 1) == 1)\n        ans |= 1 << 31 - i;\n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "191. Number of 1 Bits",
      "code": "public class Solution {\n  // You need to treat n as an unsigned value\n  public int hammingWeight(int n) {\n    int ans = 0;\n\n    for (int i = 0; i < 32; ++i)\n      if (((n >> i) & 1) == 1)\n        ++ans;\n\n    return ans;\n  }\n }\n"
    }
  ],
  null,
  null,
  null,
  null,
  null,
  null,
  [
    {
      "id": "198. House Robber",
      "code": "class Solution {\n  public int rob(int[] nums) {\n    final int n = nums.length;\n    if (n == 0)\n      return 0;\n    if (n == 1)\n      return nums[0];\n\n    // dp[i] := max money of robbing nums[0..i]\n    int[] dp = new int[n];\n    dp[0] = nums[0];\n    dp[1] = Math.max(nums[0], nums[1]);\n\n    for (int i = 2; i < n; ++i)\n      dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);\n\n    return dp[n - 1];\n  }\n }\n"
    }
  ],
  [
    {
      "id": "199. Binary Tree Right Side View",
      "code": "class Solution {\n  public List<Integer> rightSideView(TreeNode root) {\n    if (root == null)\n      return new ArrayList<>();\n\n    List<Integer> ans = new ArrayList<>();\n    Queue<TreeNode> q = new ArrayDeque<>(Arrays.asList(root));\n\n    while (!q.isEmpty()) {\n      final int size = q.size();\n      for (int i = 0; i < size; ++i) {\n        TreeNode node = q.poll();\n        if (i == size - 1)\n          ans.add(node.val);\n        if (node.left != null)\n          q.offer(node.left);\n        if (node.right != null)\n          q.offer(node.right);\n      }\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "200. Number of Islands",
      "code": "class Solution {\n  public int numIslands(char[][] grid) {\n    int ans = 0;\n\n    for (int i = 0; i < grid.length; ++i)\n      for (int j = 0; j < grid[0].length; ++j)\n        if (grid[i][j] == '1') {\n          bfs(grid, i, j);\n          ++ans;\n        } \n\n    return ans;\n  } \n\n  private static final int[] dirs = {0, 1, 0, -1, 0};\n\n  private void bfs(char[][] grid, int r, int c) {\n    Queue<int[]> q = new ArrayDeque<>();\n    q.offer(new int[] {r, c});\n    grid[r][c] = '2'; // Mark '2' as visited\n    while (!q.isEmpty()) {\n      final int i = q.peek()[0];\n      final int j = q.poll()[1];\n      for (int k = 0; k < 4; ++k) {\n        final int x = i + dirs[k];\n        final int y = j + dirs[k + 1];\n        if (x < 0 || x == grid.length || y < 0 || y == grid[0].length)\n          continue;\n        if (grid[x][y] != '1')\n          continue;\n        q.offer(new int[] {x, y});\n        grid[x][y] = '2'; // Mark '2' as visited\n      }\n    }\n  }\n }\n"
    }
  ],
  [
    {
      "id": "201. Bitwise AND of Numbers Range",
      "code": "class Solution {\n  public int rangeBitwiseAnd(int m, int n) {\n    int shiftBits = 0;\n\n    while (m != n) {\n      m >>= 1;\n      n >>= 1;\n      ++shiftBits;\n    } \n\n    return m << shiftBits;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "202. Happy Number",
      "code": "class Solution {\n  public boolean isHappy(int n) {\n    int slow = squaredSum(n);\n    int fast = squaredSum(squaredSum(n));\n\n    while (slow != fast) {\n      slow = squaredSum(slow);\n      fast = squaredSum(squaredSum(fast));\n    } \n\n    return slow == 1;\n  } \n\n  private int squaredSum(int n) {\n    int sum = 0;\n    while (n > 0) {\n      sum += Math.pow(n % 10, 2);\n      n /= 10;\n    }\n    return sum;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "203. Remove Linked List Elements",
      "code": "class Solution {\n  public ListNode removeElements(ListNode head, int val) {\n    ListNode dummy = new ListNode(0, head);\n    ListNode prev = dummy;\n\n    for (; head != null; head = head.next)\n      if (head.val != val) {\n        prev.next = head;\n        prev = prev.next;\n      }\n    prev.next = null; // In case the last val == val\n\n    return dummy.next;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "204. Count Primes",
      "code": "class Solution {\n  public int countPrimes(int n) {\n    if (n <= 2)\n      return 0;\n    final boolean[] isPrime = sieveEratosthenes(n);\n    int ans = 0;\n    for (final boolean p : isPrime)\n      if (p)\n        ++ans;\n    return ans;\n  } \n\n  private boolean[] sieveEratosthenes(int n) {\n    boolean[] isPrime = new boolean[n];\n    Arrays.fill(isPrime, true);\n    isPrime[0] = false;\n    isPrime[1] = false;\n    for (int i = 2; i * i < n; ++i)\n      if (isPrime[i])\n        for (int j = i * i; j < n; j += i)\n          isPrime[j] = false;\n    return isPrime;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "205. Isomorphic Strings",
      "code": "class Solution {\n  public boolean isIsomorphic(String s, String t) {\n    Map<Character, Integer> charToIndex_s = new HashMap<>();\n    Map<Character, Integer> charToIndex_t = new HashMap<>();\n\n    for (Integer i = 0; i < s.length(); ++i)\n      if (charToIndex_s.put(s.charAt(i), i) != charToIndex_t.put(t.charAt(i), i))\n        return false;\n\n    return true;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "206. Reverse Linked List",
      "code": "class Solution {\n  public ListNode reverseList(ListNode head) {\n    if (head == null || head.next == null)\n      return head;\n\n    ListNode newHead = reverseList(head.next);\n    head.next.next = head;\n    head.next = null;\n    return newHead;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "207. Course Schedule",
      "code": "enum State { kInit, kVisiting, kVisited } \n\n class Solution {\n  public boolean canFinish(int numCourses, int[][] prerequisites) {\n    List<Integer>[] graph = new List[numCourses];\n    State[] state = new State[numCourses];\n\n    for (int i = 0; i < numCourses; ++i)\n      graph[i] = new ArrayList<>();\n\n    for (int[] p : prerequisites)\n      graph[p[1]].add(p[0]);\n\n    for (int i = 0; i < numCourses; ++i)\n      if (hasCycle(graph, i, state))\n        return false;\n\n    return true;\n  } \n\n  private boolean hasCycle(List<Integer>[] graph, int u, State[] state) {\n    if (state[u] == State.kVisiting)\n      return true;\n    if (state[u] == State.kVisited)\n      return false;\n\n    state[u] = State.kVisiting;\n    for (final int v : graph[u])\n      if (hasCycle(graph, v, state))\n        return true;\n    state[u] = State.kVisited;\n\n    return false;\n  }\n }\n"
    }
  ],
  null,
  [
    {
      "id": "209. Minimum Size Subarray Sum",
      "code": "class Solution {\n  public int minSubArrayLen(int s, int[] nums) {\n    int ans = Integer.MAX_VALUE;\n    int sum = 0;\n\n    for (int l = 0, r = 0; r < nums.length; ++r) {\n      sum += nums[r];\n      while (sum >= s) {\n        ans = Math.min(ans, r - l + 1);\n        sum -= nums[l++];\n      }\n    } \n\n    return ans != Integer.MAX_VALUE ? ans : 0;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "210. Course Schedule II",
      "code": "enum State { kInit, kVisiting, kVisited } \n\n class Solution {\n  public int[] findOrder(int numCourses, int[][] prerequisites) {\n    Deque<Integer> ans = new ArrayDeque<>();\n    List<Integer>[] graph = new List[numCourses];\n    State[] state = new State[numCourses];\n\n    for (int i = 0; i < numCourses; ++i)\n      graph[i] = new ArrayList<>();\n\n    for (int[] p : prerequisites)\n      graph[p[1]].add(p[0]);\n\n    for (int i = 0; i < numCourses; ++i)\n      if (hasCycle(graph, i, state, ans))\n        return new int[] {};\n\n    return ans.stream().mapToInt(Integer::intValue).toArray();\n  } \n\n  private boolean hasCycle(List<Integer>[] graph, int u, State[] state, Deque<Integer> ans) {\n    if (state[u] == State.kVisiting)\n      return true;\n    if (state[u] == State.kVisited)\n      return false;\n\n    state[u] = State.kVisiting;\n    for (final int v : graph[u])\n      if (hasCycle(graph, v, state, ans))\n        return true;\n    state[u] = State.kVisited;\n    ans.addFirst(u);\n\n    return false;\n  }\n }\n"
    }
  ],
  null,
  null,
  [
    {
      "id": "213. House Robber II",
      "code": "class Solution {\n  public int rob(int[] nums) {\n    if (nums.length == 0)\n      return 0;\n    if (nums.length == 1)\n      return nums[0];\n    return Math.max(rob(nums, 0, nums.length - 2), rob(nums, 1, nums.length - 1));\n  } \n\n  private int rob(int[] nums, int l, int r) {\n    int prev1 = 0; // dp[i - 1]\n    int prev2 = 0; // dp[i - 2]\n\n    for (int i = l; i <= r; ++i) {\n      final int dp = Math.max(prev1, prev2 + nums[i]);\n      prev2 = prev1;\n      prev1 = dp;\n    } \n\n    return prev1;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "214. Shortest Palindrome",
      "code": "class Solution {\n  public String shortestPalindrome(String s) {\n    final String t = new StringBuilder(s).reverse().toString();\n\n    for (int i = 0; i < t.length(); ++i)\n      if (s.startsWith(t.substring(i)))\n        return t.substring(0, i) + s;\n\n    return t + s;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "215. Kth Largest Element in an Array",
      "code": "class Solution {\n  public int findKthLargest(int[] nums, int k) {\n    Queue<Integer> minHeap = new PriorityQueue<>();\n\n    for (final int num : nums) {\n      minHeap.offer(num);\n      while (minHeap.size() > k)\n        minHeap.poll();\n    } \n\n    return minHeap.peek();\n  }\n }\n"
    }
  ],
  [
    {
      "id": "216. Combination Sum III",
      "code": "class Solution {\n  public List<List<Integer>> combinationSum3(int k, int n) {\n    List<List<Integer>> ans = new ArrayList<>();\n    dfs(k, n, 1, new ArrayList<>(), ans);\n    return ans;\n  } \n\n  private void dfs(int k, int n, int s, List<Integer> path, List<List<Integer>> ans) {\n    if (k == 0 && n == 0) {\n      ans.add(new ArrayList<>(path));\n      return;\n    }\n    if (k == 0 || n < 0)\n      return;\n\n    for (int i = s; i <= 9; ++i) {\n      path.add(i);\n      dfs(k - 1, n - i, i + 1, path, ans);\n      path.remove(path.size() - 1);\n    }\n  }\n }\n"
    }
  ],
  [
    {
      "id": "217. Contains Duplicate",
      "code": "class Solution {\n  public boolean containsDuplicate(int[] nums) {\n    Set<Integer> seen = new HashSet<>();\n\n    for (final int num : nums)\n      if (!seen.add(num))\n        return true;\n\n    return false;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "218. The Skyline Problem",
      "code": "class Solution {\n  public List<List<Integer>> getSkyline(int[][] buildings) {\n    final int n = buildings.length;\n    if (n == 0)\n      return new ArrayList<>();\n    if (n == 1) {\n      final int left = buildings[0][0];\n      final int right = buildings[0][1];\n      final int height = buildings[0][2];\n      List<List<Integer>> ans = new ArrayList<>();\n      ans.add(new ArrayList<>(Arrays.asList(left, height)));\n      ans.add(new ArrayList<>(Arrays.asList(right, 0)));\n      return ans;\n    } \n\n    List<List<Integer>> leftSkyline = getSkyline(Arrays.copyOfRange(buildings, 0, n / 2));\n    List<List<Integer>> rightSkyline = getSkyline(Arrays.copyOfRange(buildings, n / 2, n));\n    return merge(leftSkyline, rightSkyline);\n  } \n\n  private List<List<Integer>> merge(List<List<Integer>> left, List<List<Integer>> right) {\n    List<List<Integer>> ans = new ArrayList<>();\n    int i = 0; // left's index\n    int j = 0; // right's index\n    int leftY = 0;\n    int rightY = 0;\n\n    while (i < left.size() && j < right.size())\n      // Choose the point with smaller x\n      if (left.get(i).get(0) < right.get(j).get(0)) {\n        leftY = left.get(i).get(1); // Update the ongoing leftY\n        addPoint(ans, left.get(i).get(0), Math.max(left.get(i++).get(1), rightY));\n      } else {\n        rightY = right.get(j).get(1); // Update the ongoing rightY\n        addPoint(ans, right.get(j).get(0), Math.max(right.get(j++).get(1), leftY));\n      } \n\n    while (i < left.size())\n      addPoint(ans, left.get(i).get(0), left.get(i++).get(1));\n\n    while (j < right.size())\n      addPoint(ans, right.get(j).get(0), right.get(j++).get(1));\n\n    return ans;\n  } \n\n  private void addPoint(List<List<Integer>> ans, int x, int y) {\n    if (!ans.isEmpty() && ans.get(ans.size() - 1).get(0) == x) {\n      ans.get(ans.size() - 1).set(1, y);\n      return;\n    }\n    if (!ans.isEmpty() && ans.get(ans.size() - 1).get(1) == y)\n      return;\n    ans.add(new ArrayList<>(Arrays.asList(x, y)));\n  }\n }\n"
    }
  ],
  [
    {
      "id": "219. Contains Duplicate II",
      "code": "class Solution {\n  public boolean containsNearbyDuplicate(int[] nums, int k) {\n    Set<Integer> seen = new HashSet<>();\n\n    for (int i = 0; i < nums.length; ++i) {\n      if (!seen.add(nums[i]))\n        return true;\n      if (i >= k)\n        seen.remove(nums[i - k]);\n    } \n\n    return false;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "220. Contains Duplicate III",
      "code": "class Solution {\n  public boolean containsNearbyAlmostDuplicate(int[] nums, int indexDiff, int valueDiff) {\n    TreeSet<Long> set = new TreeSet<>();\n\n    for (int i = 0; i < nums.length; ++i) {\n      final long num = (long) nums[i];\n      final Long ceiling = set.ceiling(num); // The smallest num >= nums[i]\n      if (ceiling != null && ceiling - num <= valueDiff)\n        return true;\n      final Long floor = set.floor(num); // The largest num <= nums[i]\n      if (floor != null && num - floor <= valueDiff)\n        return true;\n      set.add(num);\n      if (i >= indexDiff)\n        set.remove((long) nums[i - indexDiff]);\n    } \n\n    return false;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "221. Maximal Square",
      "code": "class Solution {\n  public int maximalSquare(char[][] matrix) {\n    final int m = matrix.length;\n    final int n = matrix[0].length;\n    int[][] dp = new int[m][n];\n    int maxLength = 0;\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j) {\n        if (i == 0 || j == 0 || matrix[i][j] == '0')\n          dp[i][j] = matrix[i][j] == '1' ? 1 : 0;\n        else\n          dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;\n        maxLength = Math.max(maxLength, dp[i][j]);\n      } \n\n    return maxLength * maxLength;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "222. Count Complete Tree Nodes",
      "code": "class Solution {\n  public int countNodes(TreeNode root) {\n    if (root == null)\n      return 0;\n    return 1 + countNodes(root.left) + countNodes(root.right);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "223. Rectangle Area",
      "code": "class Solution {\n  public int computeArea(long A, long B, long C, long D, long E, long F, long G, long H) {\n    final long x = Math.max(A, E) < Math.min(C, G) ? (Math.min(C, G) - Math.max(A, E)) : 0;\n    final long y = Math.max(B, F) < Math.min(D, H) ? (Math.min(D, H) - Math.max(B, F)) : 0;\n    return (int) ((C - A) * (D - B) + (G - E) * (H - F) - x * y);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "224. Basic Calculator",
      "code": "class Solution {\n  public int calculate(String s) {\n    int ans = 0;\n    int num = 0;\n    int sign = 1;\n    Deque<Integer> stack = new ArrayDeque<>(); // Stack.peek(): current env's sign\n    stack.push(sign);\n\n    for (final char c : s.toCharArray())\n      if (Character.isDigit(c))\n        num = num * 10 + (c - '0');\n      else if (c == '(')\n        stack.push(sign);\n      else if (c == ')')\n        stack.pop();\n      else if (c == '+' || c == '-') {\n        ans += sign * num;\n        sign = (c == '+' ? 1 : -1) * stack.peek();\n        num = 0;\n      } \n\n    return ans + sign * num;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "225. Implement Stack using Queues",
      "code": "class MyStack {\n  public void push(int x) {\n    q.offer(x);\n    for (int i = 0; i < q.size() - 1; ++i)\n      q.offer(q.poll());\n  } \n\n  public int pop() {\n    return q.poll();\n  } \n\n  public int top() {\n    return q.peek();\n  } \n\n  public boolean empty() {\n    return q.isEmpty();\n  } \n\n  private Queue<Integer> q = new ArrayDeque<>();\n}\n"
    }
  ],
  [
    {
      "id": "226. Invert Binary Tree",
      "code": "class Solution {\n  public TreeNode invertTree(TreeNode root) {\n    if (root == null)\n      return null;\n\n    TreeNode left = root.left;\n    TreeNode right = root.right;\n    root.left = invertTree(right);\n    root.right = invertTree(left);\n    return root;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "227. Basic Calculator II",
      "code": "class Solution {\n  public int calculate(String s) {\n    Deque<Integer> nums = new ArrayDeque<>();  // Stores nums\n    Deque<Character> ops = new ArrayDeque<>(); // Stores operators and parentheses\n\n    for (int i = 0; i < s.length(); ++i) {\n      final char c = s.charAt(i);\n      if (Character.isDigit(c)) {\n        int num = c - '0';\n        while (i + 1 < s.length() && Character.isDigit(s.charAt(i + 1))) {\n          num = num * 10 + (s.charAt(i + 1) - '0');\n          ++i;\n        }\n        nums.push(num);\n      } else if (c == '+' || c == '-' || c == '*' || c == '/') {\n        while (!ops.isEmpty() && compare(ops.peek(), c))\n          nums.push(calculate(ops.pop(), nums.pop(), nums.pop()));\n        ops.push(c);\n      }\n    } \n\n    while (!ops.isEmpty())\n      nums.push(calculate(ops.pop(), nums.pop(), nums.pop()));\n\n    return nums.peek();\n  } \n\n  private int calculate(char op, int b, int a) {\n    switch (op) {\n      case '+':\n        return a + b;\n      case '-':\n        return a - b;\n      case '*':\n        return a * b;\n      case '/':\n        return a / b;\n    }\n    throw new IllegalArgumentException();\n  } \n\n  // Returns true if priority(op1) >= priority(op2)\n  private boolean compare(char op1, char op2) {\n    return op1 == '*' || op1 == '/' || op2 == '+' || op2 == '-';\n  }\n }\n"
    }
  ],
  [
    {
      "id": "228. Summary Ranges",
      "code": "class Solution {\n  public List<String> summaryRanges(int[] nums) {\n    List<String> ans = new ArrayList<>();\n\n    for (int i = 0; i < nums.length; ++i) {\n      final int begin = nums[i];\n      while (i + 1 < nums.length && nums[i] == nums[i + 1] - 1)\n        ++i;\n      final int end = nums[i];\n      if (begin == end)\n        ans.add(\"\" + begin);\n      else\n        ans.add(\"\" + begin + \"->\" + end);\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "229. Majority Element II",
      "code": "class Solution {\n  public List<Integer> majorityElement(int[] nums) {\n    List<Integer> ans = new ArrayList<>();\n    int candidate1 = 0;\n    int candidate2 = 1;  // Any number different from candidate1\n    int countSoFar1 = 0; // # of candidate1 so far\n    int countSoFar2 = 0; // # of candidate2 so far\n\n    for (final int num : nums)\n      if (num == candidate1) {\n        ++countSoFar1;\n      } else if (num == candidate2) {\n        ++countSoFar2;\n      } else if (countSoFar1 == 0) { // Assign new candidate\n        candidate1 = num;\n        ++countSoFar1;\n      } else if (countSoFar2 == 0) { // Assign new candidate\n        candidate2 = num;\n        ++countSoFar2;\n      } else { // Meet a new number, so pair out previous counts\n        --countSoFar1;\n        --countSoFar2;\n      } \n\n    int count1 = 0;\n    int count2 = 0;\n\n    for (final int num : nums)\n      if (num == candidate1)\n        ++count1;\n      else if (num == candidate2)\n        ++count2;\n\n    if (count1 > nums.length / 3)\n      ans.add(candidate1);\n    if (count2 > nums.length / 3)\n      ans.add(candidate2);\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "230. Kth Smallest Element in a BST",
      "code": "class Solution {\n  public int kthSmallest(TreeNode root, int k) {\n    final int leftCount = countNodes(root.left);\n\n    if (leftCount == k - 1)\n      return root.val;\n    if (leftCount >= k)\n      return kthSmallest(root.left, k);\n    return kthSmallest(root.right, k - 1 - leftCount); // LeftCount < k\n  } \n\n  private int countNodes(TreeNode root) {\n    if (root == null)\n      return 0;\n    return 1 + countNodes(root.left) + countNodes(root.right);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "231. Power of Two",
      "code": "class Solution {\n  public boolean isPowerOfTwo(int n) {\n    return n < 0 ? false : Integer.bitCount(n) == 1;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "232. Implement Queue using Stacks",
      "code": "class MyQueue {\n  public void push(int x) {\n    input.push(x);\n  } \n\n  public int pop() {\n    peek();\n    return output.pop();\n  } \n\n  public int peek() {\n    if (output.isEmpty())\n      while (!input.isEmpty())\n        output.push(input.pop());\n    return output.peek();\n  } \n\n  public boolean empty() {\n    return input.isEmpty() && output.isEmpty();\n  } \n\n  private Deque<Integer> input = new ArrayDeque<>();\n  private Deque<Integer> output = new ArrayDeque<>();\n}\n"
    }
  ],
  [
    {
      "id": "233. Number of Digit One",
      "code": "class Solution {\n  public int countDigitOne(int n) {\n    int ans = 0;\n\n    for (long pow10 = 1; pow10 <= n; pow10 *= 10) {\n      final long divisor = pow10 * 10;\n      final int quotient = (int) (n / divisor);\n      final int remainder = (int) (n % divisor);\n      if (quotient > 0)\n        ans += quotient * pow10;\n      if (remainder >= pow10)\n        ans += Math.min(remainder - pow10 + 1, pow10);\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "234. Palindrome Linked List",
      "code": "class Solution {\n  public boolean isPalindrome(ListNode head) {\n    ListNode slow = head;\n    ListNode fast = head;\n\n    while (fast != null && fast.next != null) {\n      slow = slow.next;\n      fast = fast.next.next;\n    } \n\n    if (fast != null)\n      slow = slow.next;\n    slow = reverseList(slow);\n\n    while (slow != null) {\n      if (slow.val != head.val)\n        return false;\n      slow = slow.next;\n      head = head.next;\n    } \n\n    return true;\n  } \n\n  private ListNode reverseList(ListNode head) {\n    ListNode prev = null;\n\n    while (head != null) {\n      ListNode next = head.next;\n      head.next = prev;\n      prev = head;\n      head = next;\n    } \n\n    return prev;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "235. Lowest Common Ancestor of a Binary Search Tree",
      "code": "class Solution {\n  public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n    if (root.val > Math.max(p.val, q.val))\n      return lowestCommonAncestor(root.left, p, q);\n    if (root.val < Math.min(p.val, q.val))\n      return lowestCommonAncestor(root.right, p, q);\n    return root;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "236. Lowest Common Ancestor of a Binary Tree",
      "code": "class Solution {\n  public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n    if (root == null || root == p || root == q)\n      return root;\n\n    TreeNode l = lowestCommonAncestor(root.left, p, q);\n    TreeNode r = lowestCommonAncestor(root.right, p, q);\n\n    if (l != null && r != null)\n      return root;\n    return l == null ? r : l;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "237. Delete Node in a Linked List",
      "code": "class Solution {\n  public void deleteNode(ListNode node) {\n    node.val = node.next.val;\n    node.next = node.next.next;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "238. Product of Array Except Self",
      "code": "class Solution {\n  public int[] productExceptSelf(int[] nums) {\n    final int n = nums.length;\n    int[] ans = new int[n];    // Can also use nums as the ans array\n    int[] prefix = new int[n]; // Prefix product\n    int[] suffix = new int[n]; // Suffix product\n\n    prefix[0] = 1;\n    for (int i = 1; i < n; ++i)\n      prefix[i] = prefix[i - 1] * nums[i - 1];\n\n    suffix[n - 1] = 1;\n    for (int i = n - 2; i >= 0; --i)\n      suffix[i] = suffix[i + 1] * nums[i + 1];\n\n    for (int i = 0; i < n; ++i)\n      ans[i] = prefix[i] * suffix[i];\n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "239. Sliding Window Maximum",
      "code": "class Solution {\n  public int[] maxSlidingWindow(int[] nums, int k) {\n    int[] ans = new int[nums.length - k + 1];\n    Deque<Integer> q = new ArrayDeque<>(); // Max queue\n\n    for (int i = 0; i < nums.length; ++i) {\n      while (!q.isEmpty() && q.peekLast() < nums[i])\n        q.pollLast();\n      q.offerLast(nums[i]);\n      if (i >= k && nums[i - k] == q.peekFirst()) // Out of bound\n        q.pollFirst();\n      if (i >= k - 1)\n        ans[i - k + 1] = q.peekFirst();\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "240. Search a 2D Matrix II",
      "code": "class Solution {\n  public boolean searchMatrix(int[][] matrix, int target) {\n    int r = 0;\n    int c = matrix[0].length - 1;\n\n    while (r <= matrix.length && c >= 0) {\n      if (matrix[r][c] == target)\n        return true;\n      if (matrix[r][c] > target)\n        --c;\n      else\n        ++r;\n    } \n\n    return false;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "241. Different Ways to Add Parentheses",
      "code": "class Solution {\n  public List<Integer> diffWaysToCompute(String expression) {\n    return ways(expression, new HashMap<>());\n  } \n\n  private List<Integer> ways(final String s, Map<String, List<Integer>> memo) {\n    if (memo.containsKey(s))\n      return memo.get(s);\n\n    List<Integer> ans = new ArrayList<>();\n\n    for (int i = 0; i < s.length(); ++i)\n      if (!Character.isDigit(s.charAt(i)))\n        for (final int a : ways(s.substring(0, i), memo))\n          for (final int b : ways(s.substring(i + 1), memo))\n            if (s.charAt(i) == '+')\n              ans.add(a + b);\n            else if (s.charAt(i) == '-')\n              ans.add(a - b);\n            else\n              ans.add(a * b);\n\n    if (ans.isEmpty()) { // Single number\n      memo.put(s, Arrays.asList(Integer.parseInt(s)));\n      return memo.get(s);\n    }\n    memo.put(s, ans);\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "242. Valid Anagram",
      "code": "class Solution {\n  public boolean isAnagram(String s, String t) {\n    if (s.length() != t.length())\n      return false;\n\n    int[] count = new int[128];\n\n    for (final char c : s.toCharArray())\n      ++count[c];\n\n    for (final char c : t.toCharArray())\n      if (--count[c] < 0)\n        return false;\n\n    return true;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "243. Shortest Word Distance",
      "code": "class Solution {\n  public int shortestDistance(String[] wordsDict, String word1, String word2) {\n    int ans = wordsDict.length;\n    int index1 = -1; // wordsDict[index1] == word1\n    int index2 = -1; // wordsDict[index2] == word2\n\n    for (int i = 0; i < wordsDict.length; ++i) {\n      if (wordsDict[i].equals(word1)) {\n        index1 = i;\n        if (index2 != -1)\n          ans = Math.min(ans, index1 - index2);\n      }\n      if (wordsDict[i].equals(word2)) {\n        index2 = i;\n        if (index1 != -1)\n          ans = Math.min(ans, index2 - index1);\n      }\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "244. Shortest Word Distance II",
      "code": "class WordDistance {\n  public WordDistance(String[] words) {\n    for (int i = 0; i < words.length; ++i) {\n      wordToIndices.putIfAbsent(words[i], new ArrayList<>());\n      wordToIndices.get(words[i]).add(i);\n    }\n  } \n\n  public int shortest(String word1, String word2) {\n    List<Integer> indices1 = wordToIndices.get(word1);\n    List<Integer> indices2 = wordToIndices.get(word2);\n    int ans = Integer.MAX_VALUE;\n\n    for (int i = 0, j = 0; i < indices1.size() && j < indices2.size();) {\n      ans = Math.min(ans, Math.abs(indices1.get(i) - indices2.get(j)));\n      if (indices1.get(i) < indices2.get(j))\n        ++i;\n      else\n        ++j;\n    } \n\n    return ans;\n  } \n\n  private Map<String, List<Integer>> wordToIndices = new HashMap<>();\n}\n"
    }
  ],
  [
    {
      "id": "245. Shortest Word Distance III",
      "code": "class Solution {\n  public int shortestWordDistance(String[] words, String word1, String word2) {\n    final boolean isSame = word1.equals(word2);\n    int ans = Integer.MAX_VALUE;\n    int index1 = words.length;  // If word1 == word2, index1 is the newest index\n    int index2 = -words.length; // If word1 == word2, index2 is the previous index\n\n    for (int i = 0; i < words.length; ++i) {\n      if (words[i].equals(word1)) {\n        if (isSame)\n          index2 = index1;\n        index1 = i;\n      } else if (words[i].equals(word2)) {\n        index2 = i;\n      }\n      ans = Math.min(ans, Math.abs(index1 - index2));\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "246. Strobogrammatic Number",
      "code": "class Solution {\n  public boolean isStrobogrammatic(String num) {\n    final char[] rotated = {'0', '1', 'n', 'n', 'n', 'n', '9', 'n', '8', '6'};\n    int l = 0;\n    int r = num.length() - 1;\n\n    while (l <= r)\n      if (num.charAt(l++) != rotated[num.charAt(r--) - '0'])\n        return false;\n\n    return true;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "247. Strobogrammatic Number II",
      "code": "class Solution {\n  public List<String> findStrobogrammatic(int n) {\n    return helper(n, n);\n  } \n\n  private List<String> helper(int n, int k) {\n    if (n == 0)\n      return new ArrayList<>(Arrays.asList(\"\"));\n    if (n == 1)\n      return new ArrayList<>(Arrays.asList(\"0\", \"1\", \"8\"));\n\n    List<String> ans = new ArrayList<>();\n\n    for (final String inner : helper(n - 2, k)) {\n      if (n < k)\n        ans.add(\"0\" + inner + \"0\");\n      ans.add(\"1\" + inner + \"1\");\n      ans.add(\"6\" + inner + \"9\");\n      ans.add(\"8\" + inner + \"8\");\n      ans.add(\"9\" + inner + \"6\");\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "248. Strobogrammatic Number III",
      "code": "class Solution {\n  public int strobogrammaticInRange(String low, String high) {\n    for (int n = low.length(); n <= high.length(); ++n) {\n      char[] c = new char[n];\n      dfs(low, high, c, 0, n - 1);\n    } \n\n    return ans;\n  } \n\n  private int ans = 0;\n\n  private static final char[][] pairs = {\n      {'0', '0'}, {'1', '1'}, {'6', '9'}, {'8', '8'}, {'9', '6'}};\n\n  private void dfs(final String low, final String high, char[] c, int l, int r) {\n    if (l > r) {\n      final String s = new String(c);\n      if (s.length() == low.length() && s.compareTo(low) < 0)\n        return;\n      if (s.length() == high.length() && s.compareTo(high) > 0)\n        return;\n      ++ans;\n      return;\n    } \n\n    for (char[] pair : pairs) {\n      if (l == r && pair[0] != pair[1])\n        continue;\n      c[l] = pair[0];\n      c[r] = pair[1];\n      if (c.length > 1 && c[0] == '0')\n        continue;\n      dfs(low, high, c, l + 1, r - 1);\n    }\n  }\n }\n"
    }
  ],
  [
    {
      "id": "249. Group Shifted Strings",
      "code": "class Solution {\n  public List<List<String>> groupStrings(String[] strings) {\n    Map<String, List<String>> keyToStrings = new HashMap<>();\n\n    for (final String s : strings)\n      keyToStrings.computeIfAbsent(getKey(s), k -> new ArrayList<>()).add(s);\n\n    return new ArrayList<>(keyToStrings.values());\n  } \n\n  // \"abc\" -> \"11\" because diff(a, b) = 1 and diff(b, c) = 1\n  private String getKey(final String s) {\n    StringBuilder sb = new StringBuilder();\n\n    for (int i = 1; i < s.length(); ++i) {\n      final int diff = (s.charAt(i) - s.charAt(i - 1) + 26) % 26;\n      sb.append(diff).append(\",\");\n    } \n\n    return sb.toString();\n  }\n }\n"
    }
  ],
  [
    {
      "id": "250. Count Univalue Subtrees",
      "code": "class Solution {\n  public int countUnivalSubtrees(TreeNode root) {\n    isUnival(root, Integer.MAX_VALUE);\n    return ans;\n  } \n\n  private int ans = 0;\n\n  private boolean isUnival(TreeNode root, int val) {\n    if (root == null)\n      return true;\n\n    if (isUnival(root.left, root.val) & isUnival(root.right, root.val)) {\n      ++ans;\n      return root.val == val;\n    } \n\n    return false;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "251. Flatten 2D Vector",
      "code": "class Vector2D {\n  public Vector2D(int[][] vec) {\n    for (int[] A : vec)\n      for (final int a : A)\n        this.vec.add(a);\n  } \n\n  public int next() {\n    return vec.get(i++);\n  } \n\n  public boolean hasNext() {\n    return i < vec.size();\n  } \n\n  private List<Integer> vec = new ArrayList<>();\n  private int i = 0;\n}\n"
    }
  ],
  [
    {
      "id": "252. Meeting Rooms",
      "code": "class Solution {\n  public boolean canAttendMeetings(int[][] intervals) {\n    Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\n\n    for (int i = 1; i < intervals.length; ++i)\n      if (intervals[i - 1][1] > intervals[i][0])\n        return false;\n\n    return true;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "253. Meeting Rooms II",
      "code": "class Solution {\n  public int minMeetingRooms(int[][] intervals) {\n    // Store end times of each room\n    Queue<Integer> minHeap = new PriorityQueue<>();\n\n    Arrays.sort(intervals, (a, b) -> (a[0] - b[0]));\n\n    for (int[] interval : intervals) {\n      if (!minHeap.isEmpty() && interval[0] >= minHeap.peek())\n        minHeap.poll(); // No overlap, we can reuse the same room\n      minHeap.offer(interval[1]);\n    } \n\n    return minHeap.size();\n  }\n }\n"
    }
  ],
  [
    {
      "id": "254. Factor Combinations",
      "code": "class Solution {\n  public List<List<Integer>> getFactors(int n) {\n    List<List<Integer>> ans = new ArrayList<>();\n    dfs(n, 2, new ArrayList<>(), ans);\n    return ans;\n  } \n\n  private void dfs(int n, int s, List<Integer> path, List<List<Integer>> ans) {\n    if (n == 1) {\n      if (path.size() > 1)\n        ans.add(new ArrayList<>(path));\n      return;\n    } \n\n    for (int i = s; i <= n; ++i)\n      if (n % i == 0) {\n        path.add(i);\n        dfs(n / i, i, path, ans);\n        path.remove(path.size() - 1);\n      }\n  }\n }\n"
    }
  ],
  [
    {
      "id": "255. Verify Preorder Sequence in Binary Search Tree",
      "code": "class Solution {\n  public boolean verifyPreorder(int[] preorder) {\n    dfs(preorder, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    return i == preorder.length;\n  } \n\n  private int i = 0;\n\n  private void dfs(int[] preorder, int min, int max) {\n    if (i == preorder.length)\n      return;\n    if (preorder[i] < min || preorder[i] > max)\n      return;\n\n    final int val = preorder[i++];\n    dfs(preorder, min, val);\n    dfs(preorder, val, max);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "256. Paint House",
      "code": "class Solution {\n  public int minCost(int[][] costs) {\n    final int n = costs.length;\n\n    for (int i = 1; i < n; ++i) {\n      costs[i][0] += Math.min(costs[i - 1][1], costs[i - 1][2]);\n      costs[i][1] += Math.min(costs[i - 1][0], costs[i - 1][2]);\n      costs[i][2] += Math.min(costs[i - 1][0], costs[i - 1][1]);\n    } \n\n    return Math.min(costs[n - 1][0], Math.min(costs[n - 1][1], costs[n - 1][2]));\n  }\n }\n"
    }
  ],
  [
    {
      "id": "257. Binary Tree Paths",
      "code": "class Solution {\n  public List<String> binaryTreePaths(TreeNode root) {\n    List<String> ans = new ArrayList<>();\n    dfs(root, new StringBuilder(), ans);\n    return ans;\n  } \n\n  private void dfs(TreeNode root, StringBuilder sb, List<String> ans) {\n    if (root == null)\n      return;\n    if (root.left == null && root.right == null) {\n      ans.add(sb.append(root.val).toString());\n      return;\n    } \n\n    final int length = sb.length();\n    dfs(root.left, sb.append(root.val).append(\"->\"), ans);\n    sb.setLength(length);\n    dfs(root.right, sb.append(root.val).append(\"->\"), ans);\n    sb.setLength(length);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "258. Add Digits",
      "code": "class Solution {\n  public int addDigits(int num) {\n    return 1 + (num - 1) % 9;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "259. 3Sum Smaller",
      "code": "class Solution {\n  public int threeSumSmaller(int[] nums, int target) {\n    if (nums.length < 3)\n      return 0;\n\n    int ans = 0;\n\n    Arrays.sort(nums);\n\n    for (int i = 0; i + 2 < nums.length; ++i) {\n      int l = i + 1;\n      int r = nums.length - 1;\n      while (l < r)\n        if (nums[i] + nums[l] + nums[r] < target) {\n          // (nums[i], nums[l], nums[r])\n          // (nums[i], nums[l], nums[r - 1])\n          // ...,\n          // (nums[i], nums[l], nums[l + 1])\n          ans += r - l;\n          ++l;\n        } else {\n          --r;\n        }\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "260. Single Number III",
      "code": "class Solution {\n  public int[] singleNumber(int[] nums) {\n    final int xors = Arrays.stream(nums).reduce((a, b) -> a ^ b).getAsInt();\n    final int lowbit = xors & -xors;\n    int[] ans = new int[2];\n\n    // Seperate nums into two groups by the lowbit\n    for (final int num : nums)\n      if ((num & lowbit) > 0)\n        ans[0] ^= num;\n      else\n        ans[1] ^= num;\n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "261. Graph Valid Tree",
      "code": "class Solution {\n  public boolean validTree(int n, int[][] edges) {\n    if (n == 0 || edges.length != n - 1)\n      return false;\n\n    List<Integer>[] graph = new List[n];\n    Queue<Integer> q = new ArrayDeque<>(Arrays.asList(0));\n    Set<Integer> seen = new HashSet<>(Arrays.asList(0));\n\n    for (int i = 0; i < n; ++i)\n      graph[i] = new ArrayList<>();\n\n    for (int[] edge : edges) {\n      final int u = edge[0];\n      final int v = edge[1];\n      graph[u].add(v);\n      graph[v].add(u);\n    } \n\n    while (!q.isEmpty()) {\n      final int u = q.poll();\n      for (final int v : graph[u])\n        if (!seen.contains(v)) {\n          q.offer(v);\n          seen.add(v);\n        }\n    } \n\n    return seen.size() == n;\n  }\n }\n"
    }
  ],
  null,
  [
    {
      "id": "263. Ugly Number",
      "code": "class Solution {\n  public boolean isUgly(int n) {\n    if (n == 0)\n      return false;\n\n    for (final int prime : new int[] {2, 3, 5})\n      while (n % prime == 0)\n        n /= prime;\n\n    return n == 1;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "264. Ugly Number II",
      "code": "class Solution {\n  public int nthUglyNumber(int n) {\n    List<Integer> uglyNums = new ArrayList<>();\n    uglyNums.add(1);\n    int i2 = 0;\n    int i3 = 0;\n    int i5 = 0;\n\n    while (uglyNums.size() < n) {\n      final int next2 = uglyNums.get(i2) * 2;\n      final int next3 = uglyNums.get(i3) * 3;\n      final int next5 = uglyNums.get(i5) * 5;\n      final int next = Math.min(next2, Math.min(next3, next5));\n      if (next == next2)\n        ++i2;\n      if (next == next3)\n        ++i3;\n      if (next == next5)\n        ++i5;\n      uglyNums.add(next);\n    } \n\n    return uglyNums.get(uglyNums.size() - 1);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "265. Paint House II",
      "code": "class Solution {\n  public int minCostII(int[][] costs) {\n    int prevIndex = -1; // The previous minimum index\n    int prevMin1 = 0;   // Minimum cost so far\n    int prevMin2 = 0;   // 2nd minimum cost so far\n\n    for (int[] cost : costs) { // O(n)\n      // The painted index s.t. achieve the minimum cost after painting current house\n      int index = -1;\n      int min1 = Integer.MAX_VALUE;           // The minimum cost after painting current house\n      int min2 = Integer.MAX_VALUE;           // The 2nd minimum cost after painting current house\n      for (int i = 0; i < cost.length; ++i) { // O(k)\n        final int theCost = cost[i] + (i == prevIndex ? prevMin2 : prevMin1);\n        if (theCost < min1) {\n          index = i;\n          min2 = min1;\n          min1 = theCost;\n        } else if (theCost < min2) { // Min1 <= theCost < min2\n          min2 = theCost;\n        }\n      }\n      prevIndex = index;\n      prevMin1 = min1;\n      prevMin2 = min2;\n    } \n\n    return prevMin1;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "266. Palindrome Permutation",
      "code": "class Solution {\n  public boolean canPermutePalindrome(String s) {\n    Set<Character> seen = new HashSet<>();\n\n    for (final char c : s.toCharArray())\n      if (!seen.add(c))\n        seen.remove(c);\n\n    return seen.size() <= 1;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "267. Palindrome Permutation II",
      "code": "class Solution {\n  public List<String> generatePalindromes(String s) {\n    int odd = 0;\n    Map<Character, Integer> count = new HashMap<>();\n\n    // Get character occurrence\n    for (final char c : s.toCharArray())\n      count.put(c, count.getOrDefault(c, 0) + 1);\n\n    // Count odd one\n    for (Map.Entry<Character, Integer> entry : count.entrySet())\n      if (entry.getValue() % 2 == 1)\n        ++odd;\n\n    // can't form any palindrome\n    if (odd > 1)\n      return new ArrayList<>();\n\n    List<String> ans = new ArrayList<>();\n    List<Character> candidates = new ArrayList<>();\n    StringBuilder mid = new StringBuilder();\n\n    // Get mid and candidates characters\n    for (Map.Entry<Character, Integer> entry : count.entrySet()) {\n      final char key = entry.getKey();\n      final int value = entry.getValue();\n      if (value % 2 == 1)\n        mid.append(key);\n      for (int i = 0; i < value / 2; ++i)\n        candidates.add(key);\n    } \n\n    // Backtracking to generate our ans (strings)\n    dfs(candidates, mid, new boolean[candidates.size()], new StringBuilder(), ans);\n    return ans;\n  } \n\n  // Generate all unique palindromes from candidates\n  private void dfs(List<Character> candidates, StringBuilder mid, boolean[] used, StringBuilder sb,\n                   List<String> ans) {\n    if (sb.length() == candidates.size()) {\n      ans.add(sb.toString() + mid + sb.reverse().toString());\n      sb.reverse();\n      return;\n    } \n\n    for (int i = 0; i < candidates.size(); ++i) {\n      if (used[i])\n        continue;\n      if (i > 0 && candidates.get(i) == candidates.get(i - 1) && !used[i - 1])\n        continue;\n      used[i] = true;\n      sb.append(candidates.get(i));\n      dfs(candidates, mid, used, sb, ans);\n      sb.deleteCharAt(sb.length() - 1);\n      used[i] = false;\n    }\n  }\n }\n"
    }
  ],
  [
    {
      "id": "268. Missing Number",
      "code": "class Solution {\n  public int missingNumber(int[] nums) {\n    int ans = nums.length;\n\n    for (int i = 0; i < nums.length; ++i)\n      ans ^= i ^ nums[i];\n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "269. Alien Dictionary",
      "code": "class Solution {\n  public String alienOrder(String[] words) {\n    Map<Character, Set<Character>> graph = new HashMap<>();\n    int[] inDegree = new int[26];\n    buildGraph(graph, words, inDegree);\n    return topology(graph, inDegree);\n  } \n\n  private void buildGraph(Map<Character, Set<Character>> graph, String[] words, int[] inDegree) {\n    // Create node for each character in each word\n    for (final String word : words)\n      for (final char c : word.toCharArray())\n        graph.putIfAbsent(c, new HashSet<>());\n\n    for (int i = 1; i < words.length; ++i) {\n      final String first = words[i - 1];\n      final String second = words[i];\n      final int length = Math.min(first.length(), second.length());\n      for (int j = 0; j < length; ++j) {\n        final char u = first.charAt(j);\n        final char v = second.charAt(j);\n        if (u != v) {\n          if (!graph.get(u).contains(v)) {\n            graph.get(u).add(v);\n            ++inDegree[v - 'a'];\n          }\n          break; // Later characters' order are meaningless\n        }\n        // First = \"ab\", second = \"a\" -> invalid\n        if (j == length - 1 && first.length() > second.length()) {\n          graph.clear();\n          return;\n        }\n      }\n    }\n  } \n\n  private String topology(Map<Character, Set<Character>> graph, int[] inDegree) {\n    StringBuilder sb = new StringBuilder();\n    Queue<Character> q = graph.keySet()\n                             .stream()\n                             .filter(c -> inDegree[c - 'a'] == 0)\n                             .collect(Collectors.toCollection(ArrayDeque::new));\n\n    while (!q.isEmpty()) {\n      final char u = q.poll();\n      sb.append(u);\n      for (final char v : graph.get(u))\n        if (--inDegree[v - 'a'] == 0)\n          q.offer(v);\n    } \n\n    // Words = [\"z\", \"x\", \"y\", \"x\"]\n    return sb.length() == graph.size() ? sb.toString() : \"\";\n  }\n }\n"
    }
  ],
  [
    {
      "id": "270. Closest Binary Search Tree Value",
      "code": "class Solution {\n  public int closestValue(TreeNode root, double target) {\n    // If target < root.val, search left subtree\n    if (target < root.val && root.left != null) {\n      final int left = closestValue(root.left, target);\n      if (Math.abs(left - target) < Math.abs(root.val - target))\n        return left;\n    } \n\n    // If target > root.val, search right subtree\n    if (target > root.val && root.right != null) {\n      final int right = closestValue(root.right, target);\n      if (Math.abs(right - target) < Math.abs(root.val - target))\n        return right;\n    } \n\n    return root.val;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "271. Encode and Decode Strings",
      "code": "public class Codec {\n  // Encodes a list of strings to a single string.\n  public String encode(List<String> strs) {\n    StringBuilder encoded = new StringBuilder();\n\n    for (final String s : strs)\n      encoded.append(s.length()).append('/').append(s);\n\n    return encoded.toString();\n  } \n\n  // Decodes a single string to a list of strings.\n  public List<String> decode(String s) {\n    List<String> decoded = new ArrayList<>();\n\n    for (int i = 0; i < s.length();) {\n      final int slash = s.indexOf('/', i);\n      final int length = Integer.parseInt(s.substring(i, slash));\n      i = slash + length + 1;\n      decoded.add(s.substring(slash + 1, i));\n    } \n\n    return decoded;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "272. Closest Binary Search Tree Value II",
      "code": "class Solution {\n  public List<Integer> closestKValues(TreeNode root, double target, int k) {\n    Deque<Integer> q = new ArrayDeque<>();\n\n    inorder(root, q);\n\n    while (q.size() > k)\n      if (Math.abs(q.peekFirst() - target) > Math.abs(q.peekLast() - target))\n        q.pollFirst();\n      else\n        q.pollLast();\n\n    return new ArrayList<>(q);\n  } \n\n  private void inorder(TreeNode root, Deque<Integer> q) {\n    if (root == null)\n      return;\n\n    inorder(root.left, q);\n    q.addLast(root.val);\n    inorder(root.right, q);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "273. Integer to English Words",
      "code": "class Solution {\n  public String numberToWords(int num) {\n    return num == 0 ? \"Zero\" : helper(num);\n  } \n\n  private final String[] belowTwenty = {\"\",        \"One\",     \"Two\",       \"Three\",    \"Four\",\n                                        \"Five\",    \"Six\",     \"Seven\",     \"Eight\",    \"Nine\",\n                                        \"Ten\",     \"Eleven\",  \"Twelve\",    \"Thirteen\", \"Fourteen\",\n                                        \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\n  private final String[] tens = {\"\",      \"\",      \"Twenty\",  \"Thirty\", \"Forty\",\n                                 \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\n\n  private String helper(int num) {\n    StringBuilder s = new StringBuilder();\n\n    if (num < 20)\n      s.append(belowTwenty[num]);\n    else if (num < 100)\n      s.append(tens[num / 10]).append(\" \").append(belowTwenty[num % 10]);\n    else if (num < 1000)\n      s.append(helper(num / 100)).append(\" Hundred \").append(helper(num % 100));\n    else if (num < 1000000)\n      s.append(helper(num / 1000)).append(\" Thousand \").append(helper(num % 1000));\n    else if (num < 1000000000)\n      s.append(helper(num / 1000000)).append(\" Million \").append(helper(num % 1000000));\n    else\n      s.append(helper(num / 1000000000)).append(\" Billion \").append(helper(num % 1000000000));\n\n    return s.toString().trim();\n  }\n }\n"
    }
  ],
  [
    {
      "id": "274. H-Index",
      "code": "class Solution {\n  public int hIndex(int[] citations) {\n    final int n = citations.length;\n    int accumulate = 0;\n    int[] count = new int[n + 1];\n\n    for (final int citation : citations)\n      ++count[Math.min(citation, n)];\n\n    // To find the largeset h-index, loop from back to front\n    // I is the candidate h-index\n    for (int i = n; i >= 0; --i) {\n      accumulate += count[i];\n      if (accumulate >= i)\n        return i;\n    } \n\n    throw new IllegalArgumentException();\n  }\n }\n"
    }
  ],
  [
    {
      "id": "275. H-Index II",
      "code": "class Solution {\n  public int hIndex(int[] citations) {\n    int l = 0;\n    int r = citations.length;\n\n    while (l < r) {\n      final int m = (l + r) / 2;\n      if (citations[m] >= citations.length - m)\n        r = m;\n      else\n        l = m + 1;\n    } \n\n    return citations.length - l;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "276. Paint Fence",
      "code": "class Solution {\n  public int numWays(int n, int k) {\n    if (n == 0)\n      return 0;\n    if (n == 1)\n      return k;\n    if (n == 2)\n      return k * k;\n\n    // dp[i] := # of ways to paint n posts with k colors\n    int[] dp = new int[n + 1];\n    dp[0] = 0;\n    dp[1] = k;\n    dp[2] = k * k;\n\n    for (int i = 3; i <= n; ++i)\n      dp[i] = (dp[i - 1] + dp[i - 2]) * (k - 1);\n\n    return dp[n];\n  }\n }\n"
    }
  ],
  [
    {
      "id": "277. Find the Celebrity",
      "code": "public class Solution extends Relation {\n  public int findCelebrity(int n) {\n    int candidate = 0;\n\n    // Everyone knows the celebrity\n    for (int i = 1; i < n; ++i)\n      if (knows(candidate, i))\n        candidate = i;\n\n    // Candidate knows nobody and everyone knows the celebrity\n    for (int i = 0; i < n; ++i) {\n      if (i < candidate && knows(candidate, i) || !knows(i, candidate))\n        return -1;\n      if (i > candidate && !knows(i, candidate))\n        return -1;\n    } \n\n    return candidate;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "278. First Bad Version",
      "code": "public class Solution extends VersionControl {\n  public int firstBadVersion(int n) {\n    int l = 1;\n    int r = n;\n\n    while (l < r) {\n      final int m = l + (r - l) / 2;\n      if (isBadVersion(m))\n        r = m;\n      else\n        l = m + 1;\n    } \n\n    return l;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "279. Perfect Squares",
      "code": "class Solution {\n  public int numSquares(int n) {\n    int[] dp = new int[n + 1];\n    Arrays.fill(dp, n); // 1^2 x n\n\n    dp[0] = 0; // No way\n    dp[1] = 1; // 1^2\n\n    for (int i = 2; i <= n; ++i)\n      for (int j = 1; j * j <= i; ++j)\n        dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n\n    return dp[n];\n  }\n }\n"
    }
  ],
  [
    {
      "id": "280. Wiggle Sort",
      "code": "class Solution {\n  public void wiggleSort(int[] nums) {\n    // 1. if i is even, then nums[i] <= nums[i - 1]\n    // 2. if i is odd, then nums[i] >= nums[i - 1]\n    for (int i = 1; i < nums.length; ++i)\n      if ((i % 2 == 0 && nums[i] > nums[i - 1]) || (i % 2 == 1 && nums[i] < nums[i - 1]))\n        swap(nums, i, i - 1);\n  } \n\n  private void swap(int[] nums, int i, int j) {\n    final int temp = nums[i];\n    nums[i] = nums[j];\n    nums[j] = temp;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "281. Zigzag Iterator",
      "code": "public class ZigzagIterator {\n  public ZigzagIterator(List<Integer> v1, List<Integer> v2) {\n    if (!v1.isEmpty())\n      q.offer(v1.iterator());\n    if (!v2.isEmpty())\n      q.offer(v2.iterator());\n  } \n\n  public int next() {\n    final Iterator it = q.poll();\n    final int next = (int) it.next();\n    if (it.hasNext())\n      q.offer(it);\n    return next;\n  } \n\n  public boolean hasNext() {\n    return !q.isEmpty();\n  } \n\n  private Queue<Iterator> q = new ArrayDeque<>();\n}\n"
    }
  ],
  [
    {
      "id": "282. Expression Add Operators",
      "code": "class Solution {\n  public List<String> addOperators(String num, int target) {\n    List<String> ans = new ArrayList<>();\n    dfs(num, target, 0, 0, 0, new StringBuilder(), ans);\n    return ans;\n  } \n\n  private void dfs(String num, int target, int s, long prev, long eval, StringBuilder sb,\n                   List<String> ans) {\n    if (s == num.length()) {\n      if (eval == target)\n        ans.add(sb.toString());\n      return;\n    } \n\n    for (int i = s; i < num.length(); ++i) {\n      if (i > s && num.charAt(s) == '0')\n        return;\n      final long curr = Long.parseLong(num.substring(s, i + 1));\n      final int length = sb.length();\n      if (s == 0) { // First num\n        dfs(num, target, i + 1, curr, curr, sb.append(curr), ans);\n        sb.setLength(length);\n      } else {\n        dfs(num, target, i + 1, curr, eval + curr, sb.append(\"+\").append(curr), ans);\n        sb.setLength(length);\n        dfs(num, target, i + 1, -curr, eval - curr, sb.append(\"-\").append(curr), ans);\n        sb.setLength(length);\n        dfs(num, target, i + 1, prev * curr, eval - prev + prev * curr, sb.append(\"*\").append(curr),\n            ans);\n        sb.setLength(length);\n      }\n    }\n  }\n }\n"
    }
  ],
  [
    {
      "id": "283. Move Zeroes",
      "code": "class Solution {\n  public void moveZeroes(int[] nums) {\n    int i = 0;\n    for (final int num : nums)\n      if (num != 0)\n        nums[i++] = num;\n\n    while (i < nums.length)\n      nums[i++] = 0;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "284. Peeking Iterator",
      "code": "class PeekingIterator implements Iterator<Integer> {\n  public PeekingIterator(Iterator<Integer> iterator) {\n    this.iterator = iterator;\n    buffer = iterator.hasNext() ? iterator.next() : null;\n  } \n\n  // Returns the next element in the iteration without advancing the iterator.\n  public Integer peek() {\n    return buffer;\n  } \n\n  // hasNext() and next() should behave the same as in the Iterator interface.\n  // Override them if needed.\n  @Override\n  public Integer next() {\n    Integer next = buffer;\n    buffer = iterator.hasNext() ? iterator.next() : null;\n    return next;\n  } \n\n  @Override\n  public boolean hasNext() {\n    return buffer != null;\n  } \n\n  private Iterator<Integer> iterator;\n  private Integer buffer;\n}\n"
    }
  ],
  [
    {
      "id": "285. Inorder Successor in BST",
      "code": "class Solution {\n  public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {\n    if (root == null)\n      return null;\n    if (root.val <= p.val)\n      return inorderSuccessor(root.right, p);\n\n    TreeNode left = inorderSuccessor(root.left, p);\n    return left == null ? root : left;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "286. Walls and Gates",
      "code": "class Solution {\n  public void wallsAndGates(int[][] rooms) {\n    final int m = rooms.length;\n    final int n = rooms[0].length;\n    final int[] dirs = {0, 1, 0, -1, 0};\n    Queue<int[]> q = new ArrayDeque<>();\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (rooms[i][j] == 0)\n          q.offer(new int[] {i, j});\n\n    while (!q.isEmpty()) {\n      int[] p = q.poll();\n      final int i = p[0];\n      final int j = p[1];\n      for (int k = 0; k < 4; ++k) {\n        final int x = i + dirs[k];\n        final int y = j + dirs[k + 1];\n        if (x < 0 || x == m || y < 0 || y == n)\n          continue;\n        if (rooms[x][y] != Integer.MAX_VALUE)\n          continue;\n        rooms[x][y] = rooms[i][j] + 1;\n        q.offer(new int[] {x, y});\n      }\n    }\n  }\n }\n"
    }
  ],
  [
    {
      "id": "287. Find the Duplicate Number",
      "code": "class Solution {\n  public int findDuplicate(int[] nums) {\n    int slow = nums[nums[0]];\n    int fast = nums[nums[nums[0]]];\n\n    while (slow != fast) {\n      slow = nums[slow];\n      fast = nums[nums[fast]];\n    } \n\n    slow = nums[0];\n\n    while (slow != fast) {\n      slow = nums[slow];\n      fast = nums[fast];\n    } \n\n    return slow;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "288. Unique Word Abbreviation",
      "code": "class ValidWordAbbr {\n  public ValidWordAbbr(String[] dictionary) {\n    dict = new HashSet<>(Arrays.asList(dictionary));\n\n    for (final String word : dict) {\n      final String abbr = getAbbr(word);\n      abbrUnique.put(abbr, !abbrUnique.containsKey(abbr));\n    }\n  } \n\n  public boolean isUnique(String word) {\n    final String abbr = getAbbr(word);\n    final Boolean hasAbbr = abbrUnique.get(abbr);\n    return hasAbbr == null || hasAbbr && dict.contains(word);\n  } \n\n  private Set<String> dict;\n  private Map<String, Boolean> abbrUnique = new HashMap<>(); // T := unique, F := not unique\n\n  private String getAbbr(final String s) {\n    final int n = s.length();\n    if (n <= 2)\n      return s;\n    return s.charAt(0) + Integer.toString(n - 2) + s.charAt(n - 1);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "289. Game of Life",
      "code": "class Solution {\n  public void gameOfLife(int[][] board) {\n    final int m = board.length;\n    final int n = board[0].length;\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j) {\n        int ones = 0;\n        for (int x = Math.max(0, i - 1); x < Math.min(m, i + 2); ++x)\n          for (int y = Math.max(0, j - 1); y < Math.min(n, j + 2); ++y)\n            ones += board[x][y] & 1;\n        // Any live cell with 2 or 3 live neighbors\n        // lives on to the next generation\n        if (board[i][j] == 1 && (ones == 3 || ones == 4))\n          board[i][j] |= 0b10;\n        // Any dead cell with exactly 3 live neighbors\n        // becomes a live cell, as if by reproduction\n        if (board[i][j] == 0 && ones == 3)\n          board[i][j] |= 0b10;\n      } \n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        board[i][j] >>= 1;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "290. Word Pattern",
      "code": "class Solution {\n  public boolean wordPattern(String pattern, String str) {\n    String[] words = str.split(\" \");\n    if (words.length != pattern.length())\n      return false;\n\n    Map<Character, Integer> charToIndex = new HashMap<>();\n    Map<String, Integer> stringToIndex = new HashMap<>();\n\n    for (Integer i = 0; i < pattern.length(); ++i)\n      if (charToIndex.put(pattern.charAt(i), i) != stringToIndex.put(words[i], i))\n        return false;\n\n    return true;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "291. Word Pattern II",
      "code": "class Solution {\n  public boolean wordPatternMatch(String pattern, String s) {\n    return isMatch(pattern, 0, s, 0, new HashMap<>(), new HashSet<>());\n  } \n\n  private boolean isMatch(final String pattern, int i, final String s, int j,\n                          Map<Character, String> charToString, Set<String> seen) {\n    if (i == pattern.length() && j == s.length())\n      return true;\n    if (i == pattern.length() || j == s.length())\n      return false;\n\n    final char c = pattern.charAt(i);\n\n    if (charToString.containsKey(c)) {\n      final String t = charToString.get(c);\n      // Check if we can match t w/ s[j:]\n      if (!s.startsWith(t, j))\n        return false;\n\n      // If can match, so continue match the rest\n      return isMatch(pattern, i + 1, s, j + t.length(), charToString, seen);\n    } \n\n    for (int k = j; k < s.length(); ++k) {\n      final String t = s.substring(j, k + 1);\n\n      // This string is already mapped by other character\n      if (seen.contains(t))\n        continue;\n\n      charToString.put(c, t);\n      seen.add(t);\n\n      if (isMatch(pattern, i + 1, s, k + 1, charToString, seen))\n        return true;\n\n      // Backtracking\n      charToString.remove(c);\n      seen.remove(t);\n    } \n\n    return false;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "292. Nim Game",
      "code": "class Solution {\n  public boolean canWinNim(int n) {\n    return n % 4 != 0;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "293. Flip Game",
      "code": "class Solution {\n  public List<String> generatePossibleNextMoves(String currentState) {\n    List<String> ans = new ArrayList<>();\n\n    for (int i = 0; i + 1 < currentState.length(); ++i)\n      if (currentState.charAt(i) == '+' && currentState.charAt(i + 1) == '+') {\n        StringBuilder sb = new StringBuilder(currentState);\n        sb.setCharAt(i, '-');\n        sb.setCharAt(i + 1, '-');\n        ans.add(sb.toString());\n      } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "294. Flip Game II",
      "code": "class Solution {\n  public boolean canWin(String currentState) {\n    if (memo.containsKey(currentState))\n      memo.get(currentState);\n\n    // If any of currentState[i:i + 2] == \"++\" and your friend can't win after\n    // Changing currentState[i:i + 2] to \"--\" (or \"-\"), then you can win\n    for (int i = 0; i + 1 < currentState.length(); ++i)\n      if (currentState.charAt(i) == '+' && currentState.charAt(i + 1) == '+' &&\n          !canWin(currentState.substring(0, i) + \"-\" + currentState.substring(i + 2))) {\n        memo.put(currentState, true);\n        return true;\n      } \n\n    memo.put(currentState, false);\n    return false;\n  } \n\n  private Map<String, Boolean> memo = new HashMap<>();\n}\n"
    }
  ],
  [
    {
      "id": "295. Find Median from Data Stream",
      "code": "class MedianFinder {\n  public void addNum(int num) {\n    if (maxHeap.isEmpty() || num <= maxHeap.peek())\n      maxHeap.offer(num);\n    else\n      minHeap.offer(num);\n\n    // Balance two heaps s.t.\n    // |maxHeap| >= |minHeap| and |maxHeap| - |minHeap| <= 1\n    if (maxHeap.size() < minHeap.size())\n      maxHeap.offer(minHeap.poll());\n    else if (maxHeap.size() - minHeap.size() > 1)\n      minHeap.offer(maxHeap.poll());\n  } \n\n  public double findMedian() {\n    if (maxHeap.size() == minHeap.size())\n      return (double) (maxHeap.peek() + minHeap.peek()) / 2.0;\n    return (double) maxHeap.peek();\n  } \n\n  private Queue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\n  private Queue<Integer> minHeap = new PriorityQueue<>();\n}\n"
    }
  ],
  [
    {
      "id": "296. Best Meeting Point",
      "code": "class Solution {\n  public int minTotalDistance(int[][] grid) {\n    final int m = grid.length;\n    final int n = grid[0].length;\n    List<Integer> I = new ArrayList<>(); // I indices s.t. grid[i][j] == 1\n    List<Integer> J = new ArrayList<>(); // J indices s.t. grid[i][j] == 1\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (grid[i][j] == 1)\n          I.add(i);\n\n    for (int j = 0; j < n; ++j)\n      for (int i = 0; i < m; ++i)\n        if (grid[i][j] == 1)\n          J.add(j);\n\n    // Sum(i - median(I)) + sum(j - median(J))\n    return minTotalDistance(I) + minTotalDistance(J);\n  } \n\n  private int minTotalDistance(List<Integer> grid) {\n    int sum = 0;\n    int i = 0;\n    int j = grid.size() - 1;\n\n    while (i < j)\n      sum += grid.get(j--) - grid.get(i++);\n\n    return sum;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "297. Serialize and Deserialize Binary Tree",
      "code": "public class Codec {\n  // Encodes a tree to a single string.\n  public String serialize(TreeNode root) {\n    if (root == null)\n      return \"\";\n\n    StringBuilder sb = new StringBuilder();\n    Queue<TreeNode> q = new LinkedList<>(Arrays.asList(root));\n\n    while (!q.isEmpty()) {\n      TreeNode node = q.poll();\n      if (node == null) {\n        sb.append(\"n \");\n      } else {\n        sb.append(node.val).append(\" \");\n        q.offer(node.left);\n        q.offer(node.right);\n      }\n    } \n\n    return sb.toString();\n  } \n\n  // Decodes your encoded data to tree.\n  public TreeNode deserialize(String data) {\n    if (data.equals(\"\"))\n      return null;\n\n    final String[] vals = data.split(\" \");\n    TreeNode root = new TreeNode(Integer.parseInt(vals[0]));\n    Queue<TreeNode> q = new LinkedList<>(Arrays.asList(root));\n\n    for (int i = 1; i < vals.length; i += 2) {\n      TreeNode node = q.poll();\n      if (!vals[i].equals(\"n\")) {\n        node.left = new TreeNode(Integer.parseInt(vals[i]));\n        q.offer(node.left);\n      }\n      if (!vals[i + 1].equals(\"n\")) {\n        node.right = new TreeNode(Integer.parseInt(vals[i + 1]));\n        q.offer(node.right);\n      }\n    } \n\n    return root;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "298. Binary Tree Longest Consecutive Sequence",
      "code": "class Solution {\n  public int longestConsecutive(TreeNode root) {\n    if (root == null)\n      return 0;\n    return dfs(root, -1, 0, 1);\n  } \n\n  private int dfs(TreeNode root, int target, int length, int max) {\n    if (root == null)\n      return max;\n    if (root.val == target)\n      max = Math.max(max, ++length);\n    else\n      length = 1;\n    return Math.max(dfs(root.left, root.val + 1, length, max),\n                    dfs(root.right, root.val + 1, length, max));\n  }\n }\n"
    }
  ],
  [
    {
      "id": "299. Bulls and Cows",
      "code": "class Solution {\n  public String getHint(String secret, String guess) {\n    int A = 0;\n    int B = 0;\n    int[] count1 = new int[10];\n    int[] count2 = new int[10];\n\n    for (int i = 0; i < secret.length(); ++i)\n      if (secret.charAt(i) == guess.charAt(i))\n        ++A;\n      else {\n        ++count1[secret.charAt(i) - '0'];\n        ++count2[guess.charAt(i) - '0'];\n      } \n\n    for (int i = 0; i < 10; ++i)\n      B += Math.min(count1[i], count2[i]);\n\n    return String.valueOf(A) + \"A\" + String.valueOf(B) + \"B\";\n  }\n }\n"
    }
  ],
  [
    {
      "id": "300. Longest Increasing Subsequence",
      "code": "class Solution {\n  public int lengthOfLIS(int[] nums) {\n    if (nums.length == 0)\n      return 0;\n\n    // dp[i] := Length of LIS ending at nums[i]\n    int[] dp = new int[nums.length];\n    Arrays.fill(dp, 1);\n\n    for (int i = 1; i < nums.length; ++i)\n      for (int j = 0; j < i; ++j)\n        if (nums[j] < nums[i])\n          dp[i] = Math.max(dp[i], dp[j] + 1);\n\n    return Arrays.stream(dp).max().getAsInt();\n  }\n }\n"
    }
  ],
  [
    {
      "id": "301. Remove Invalid Parentheses",
      "code": "class Solution {\n  public List<String> removeInvalidParentheses(String s) {\n    List<String> ans = new ArrayList<>();\n    final int[] counts = getLeftAndRightCounts(s);\n    dfs(s, 0, counts[0], counts[1], ans);\n    return ans;\n  } \n\n  // Very simliar to 921. Minimum Add to Make Parentheses Valid\n  // Returns how many '(' and ')' need to be deleted\n  private int[] getLeftAndRightCounts(final String s) {\n    int l = 0;\n    int r = 0;\n\n    for (final char c : s.toCharArray())\n      if (c == '(')\n        ++l;\n      else if (c == ')') {\n        if (l == 0)\n          ++r;\n        else\n          --l;\n      } \n\n    return new int[] {l, r};\n  } \n\n  private void dfs(final String s, int start, int l, int r, List<String> ans) {\n    if (l == 0 && r == 0 && isValid(s)) {\n      ans.add(s);\n      return;\n    } \n\n    for (int i = start; i < s.length(); ++i) {\n      if (i > start && s.charAt(i) == s.charAt(i - 1))\n        continue;\n      if (l > 0 && s.charAt(i) == '(') // Delete s[i]\n        dfs(s.substring(0, i) + s.substring(i + 1), i, l - 1, r, ans);\n      else if (r > 0 && s.charAt(i) == ')') // Delete s[i]\n        dfs(s.substring(0, i) + s.substring(i + 1), i, l, r - 1, ans);\n    }\n  } \n\n  private boolean isValid(final String s) {\n    int count = 0; // # of '(' - # of ')'\n\n    for (final char c : s.toCharArray()) {\n      if (c == '(')\n        ++count;\n      else if (c == ')')\n        --count;\n      if (count < 0)\n        return false;\n    } \n\n    return true; // Count == 0\n  }\n }\n"
    }
  ],
  [
    {
      "id": "302. Smallest Rectangle Enclosing Black Pixels",
      "code": "class Solution {\n  public int minArea(char[][] image, int x, int y) {\n    final int m = image.length;\n    final int n = image[0].length;\n    final int[] dirs = {0, 1, 0, -1, 0};\n    int[] topLeft = {x, y};\n    int[] bottomRight = {x, y};\n    Queue<int[]> q = new ArrayDeque<>(Arrays.asList(new int[] {x, y}));\n    image[x][y] = '2'; // Visited\n\n    while (!q.isEmpty()) {\n      final int i = q.peek()[0];\n      final int j = q.poll()[1];\n      for (int k = 0; k < 4; ++k) {\n        final int r = i + dirs[k];\n        final int c = j + dirs[k + 1];\n        if (r < 0 || r == m || c < 0 || c == n)\n          continue;\n        if (image[r][c] != '1')\n          continue;\n        topLeft[0] = Math.min(topLeft[0], r);\n        topLeft[1] = Math.min(topLeft[1], c);\n        bottomRight[0] = Math.max(bottomRight[0], r);\n        bottomRight[1] = Math.max(bottomRight[1], c);\n        q.offer(new int[] {r, c});\n        image[r][c] = '2';\n      }\n    } \n\n    final int width = bottomRight[1] - topLeft[1] + 1;\n    final int height = bottomRight[0] - topLeft[0] + 1;\n    return width * height;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "303. Range Sum Query - Immutable",
      "code": "class NumArray {\n  public NumArray(int[] nums) {\n    prefix = new int[nums.length + 1];\n    for (int i = 0; i < nums.length; ++i)\n      prefix[i + 1] = nums[i] + prefix[i];\n  } \n\n  public int sumRange(int left, int right) {\n    return prefix[right + 1] - prefix[left];\n  } \n\n  private int[] prefix;\n}\n"
    }
  ],
  [
    {
      "id": "304. Range Sum Query 2D - Immutable",
      "code": "class NumMatrix {\n  public NumMatrix(int[][] matrix) {\n    if (matrix.length == 0)\n      return;\n\n    final int m = matrix.length;\n    final int n = matrix[0].length;\n    // prefix[i][j] := sum of matrix[0..i)[0..j)\n    prefix = new int[m + 1][n + 1];\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        prefix[i + 1][j + 1] = matrix[i][j] + prefix[i][j + 1] + prefix[i + 1][j] - prefix[i][j];\n  } \n\n  public int sumRegion(int row1, int col1, int row2, int col2) {\n    return prefix[row2 + 1][col2 + 1] - prefix[row1][col2 + 1]\n         - prefix[row2 + 1][col1] + prefix[row1][col1];\n  } \n\n  private int[][] prefix;\n}\n"
    }
  ],
  [
    {
      "id": "305. Number of Islands II",
      "code": "class UnionFind {\n  public int[] id;\n\n  public UnionFind(int n) {\n    id = new int[n];\n    rank = new int[n];\n    Arrays.fill(id, -1); // Water\n  } \n\n  public void unionByRank(int u, int v) {\n    final int i = find(u);\n    final int j = find(v);\n    if (i == j)\n      return;\n    if (rank[i] < rank[j]) {\n      id[i] = id[j];\n    } else if (rank[i] > rank[j]) {\n      id[j] = id[i];\n    } else {\n      id[i] = id[j];\n      ++rank[j];\n    }\n  } \n\n  public int find(int u) {\n    return id[u] == u ? u : (id[u] = find(id[u]));\n  } \n\n  private int[] rank;\n} \n\n class Solution {\n  public List<Integer> numIslands2(int m, int n, int[][] positions) {\n    final int[] dirs = {0, 1, 0, -1, 0};\n    List<Integer> ans = new ArrayList<>();\n    boolean[][] seen = new boolean[m][n];\n    UnionFind uf = new UnionFind(m * n);\n    int count = 0;\n\n    for (int[] p : positions) {\n      final int i = p[0];\n      final int j = p[1];\n      if (seen[i][j]) {\n        ans.add(count);\n        continue;\n      }\n      seen[i][j] = true;\n      final int id = getId(i, j, n);\n      uf.id[id] = id;\n      ++count;\n      for (int k = 0; k < 4; ++k) {\n        final int x = i + dirs[k];\n        final int y = j + dirs[k + 1];\n        if (x < 0 || x == m || y < 0 || y == n)\n          continue;\n        final int neighborId = getId(x, y, n);\n        if (uf.id[neighborId] == -1) // Water\n          continue;\n        final int currentParent = uf.find(id);\n        final int neighborParent = uf.find(neighborId);\n        if (currentParent != neighborParent) {\n          uf.unionByRank(currentParent, neighborParent);\n          --count;\n        }\n      }\n      ans.add(count);\n    } \n\n    return ans;\n  } \n\n  private int getId(int i, int j, int n) {\n    return i * n + j;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "306. Additive Number",
      "code": "class Solution {\n  public boolean isAdditiveNumber(String num) {\n    final int n = num.length();\n\n    // num[0..i] = firstNum\n    for (int i = 0; i < n / 2; ++i) {\n      if (i > 0 && num.charAt(0) == '0')\n        return false;\n      final long firstNum = Long.parseLong(num.substring(0, i + 1));\n      // num[i + 1..j] = secondNum\n      // Len(thirdNum) >= max(len(firstNum), len(secondNum))\n      for (int j = i + 1; Math.max(i, j - i) < n - j; ++j) {\n        if (j > i + 1 && num.charAt(i + 1) == '0')\n          break;\n        final long secondNum = Long.parseLong(num.substring(i + 1, j + 1));\n        if (dfs(num, firstNum, secondNum, j + 1))\n          return true;\n      }\n    } \n\n    return false;\n  } \n\n  private boolean dfs(final String num, long firstNum, long secondNum, long s) {\n    if (s == num.length())\n      return true;\n\n    final long thirdNum = firstNum + secondNum;\n    final String thirdNumStr = String.valueOf(thirdNum);\n    return num.indexOf(thirdNumStr, (int) s) == s &&\n        dfs(num, secondNum, thirdNum, s + thirdNumStr.length());\n  }\n }\n"
    }
  ],
  [
    {
      "id": "307. Range Sum Query - Mutable",
      "code": "class FenwickTree {\n  public FenwickTree(int n) {\n    sums = new int[n + 1];\n  } \n\n  public void update(int i, int delta) {\n    while (i < sums.length) {\n      sums[i] += delta;\n      i += lowbit(i);\n    }\n  } \n\n  public int get(int i) {\n    int sum = 0;\n    while (i > 0) {\n      sum += sums[i];\n      i -= lowbit(i);\n    }\n    return sum;\n  } \n\n  private int[] sums;\n\n  private static int lowbit(int i) {\n    return i & -i;\n  }\n } \n\n class NumArray {\n  public NumArray(int[] nums) {\n    this.nums = nums;\n    tree = new FenwickTree(nums.length);\n    for (int i = 0; i < nums.length; ++i)\n      tree.update(i + 1, nums[i]);\n  } \n\n  public void update(int index, int val) {\n    tree.update(index + 1, val - nums[index]);\n    nums[index] = val;\n  } \n\n  public int sumRange(int left, int right) {\n    return tree.get(right + 1) - tree.get(left);\n  } \n\n  private int[] nums;\n  private FenwickTree tree;\n}\n"
    }
  ],
  [
    {
      "id": "308. Range Sum Query 2D - Mutable",
      "code": "class FenwickTree {\n  public FenwickTree(int m, int n) {\n    sums = new int[m + 1][n + 1];\n  } \n\n  public void update(int row, int col, int delta) {\n    for (int i = row; i < sums.length; i += i & -i)\n      for (int j = col; j < sums[0].length; j += j & -j)\n        sums[i][j] += delta;\n  } \n\n  public int get(int row, int col) {\n    int sum = 0;\n    for (int i = row; i > 0; i -= i & -i)\n      for (int j = col; j > 0; j -= j & -j)\n        sum += sums[i][j];\n    return sum;\n  } \n\n  private int[][] sums;\n} \n\n class NumMatrix {\n  public NumMatrix(int[][] matrix) {\n    this.matrix = matrix;\n    tree = new FenwickTree(matrix.length, matrix[0].length);\n    for (int i = 0; i < matrix.length; ++i)\n      for (int j = 0; j < matrix[0].length; ++j)\n        tree.update(i + 1, j + 1, matrix[i][j]);\n  } \n\n  public void update(int row, int col, int val) {\n    tree.update(row + 1, col + 1, val - matrix[row][col]);\n    matrix[row][col] = val;\n  } \n\n  public int sumRegion(int row1, int col1, int row2, int col2) {\n    return tree.get(row2 + 1, col2 + 1) - tree.get(row1, col2 + 1) - tree.get(row2 + 1, col1) +\n        tree.get(row1, col1);\n  } \n\n  private int[][] matrix;\n  private FenwickTree tree;\n}\n"
    }
  ],
  [
    {
      "id": "309. Best Time to Buy and Sell Stock with Cooldown",
      "code": "class Solution {\n  public int maxProfit(int[] prices) {\n    int sell = 0;\n    int hold = Integer.MIN_VALUE;\n    int prev = 0;\n\n    for (final int price : prices) {\n      final int cache = sell;\n      sell = Math.max(sell, hold + price);\n      hold = Math.max(hold, prev - price);\n      prev = cache;\n    } \n\n    return sell;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "310. Minimum Height Trees",
      "code": "class Solution {\n  public List<Integer> findMinHeightTrees(int n, int[][] edges) {\n    if (n == 0 || edges.length == 0)\n      return new ArrayList<>(Arrays.asList(0));\n\n    List<Integer> ans = new ArrayList<>();\n    Map<Integer, Set<Integer>> graph = new HashMap<>();\n\n    for (int i = 0; i < n; ++i)\n      graph.put(i, new HashSet<>());\n\n    for (int[] edge : edges) {\n      final int u = edge[0];\n      final int v = edge[1];\n      graph.get(u).add(v);\n      graph.get(v).add(u);\n    } \n\n    for (Map.Entry<Integer, Set<Integer>> entry : graph.entrySet()) {\n      final int label = entry.getKey();\n      Set<Integer> children = entry.getValue();\n      if (children.size() == 1)\n        ans.add(label);\n    } \n\n    while (n > 2) {\n      n -= ans.size();\n      List<Integer> nextLeaves = new ArrayList<>();\n      for (final int leaf : ans) {\n        final int u = (int) graph.get(leaf).iterator().next();\n        graph.get(u).remove(leaf);\n        if (graph.get(u).size() == 1)\n          nextLeaves.add(u);\n      }\n      ans = nextLeaves;\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "311. Sparse Matrix Multiplication",
      "code": "class Solution {\n  public int[][] multiply(int[][] mat1, int[][] mat2) {\n    final int m = mat1.length;\n    final int n = mat2.length;\n    final int l = mat2[0].length;\n    int[][] ans = new int[m][l];\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < l; ++j)\n        for (int k = 0; k < n; ++k)\n          ans[i][j] += mat1[i][k] * mat2[k][j];\n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "312. Burst Balloons",
      "code": "class Solution {\n  public int maxCoins(int[] nums) {\n    final int n = nums.length;\n\n    A = new int[n + 2];\n\n    System.arraycopy(nums, 0, A, 1, n);\n    A[0] = 1;\n    A[n + 1] = 1;\n\n    // dp[i][j] := maxCoins(A[i..j])\n    dp = new int[n + 2][n + 2];\n    return maxCoins(1, n);\n  } \n\n  private int[][] dp;\n  private int[] A;\n\n  private int maxCoins(int i, int j) {\n    if (i > j)\n      return 0;\n    if (dp[i][j] > 0)\n      return dp[i][j];\n\n    for (int k = i; k <= j; ++k)\n      dp[i][j] = Math.max(dp[i][j],\n                          maxCoins(i, k - 1) +\n                          maxCoins(k + 1, j) +\n                          A[i - 1] * A[k] * A[j + 1]);\n\n    return dp[i][j];\n  }\n }\n"
    }
  ],
  [
    {
      "id": "313. Super Ugly Number",
      "code": "class Solution {\n  public int nthSuperUglyNumber(int n, int[] primes) {\n    final int k = primes.length;\n    int[] indices = new int[k];\n    int[] uglyNums = new int[n];\n    uglyNums[0] = 1;\n\n    for (int i = 1; i < n; ++i) {\n      int[] nexts = new int[k];\n      for (int j = 0; j < k; ++j)\n        nexts[j] = uglyNums[indices[j]] * primes[j];\n      final int next = Arrays.stream(nexts).min().getAsInt();\n      for (int j = 0; j < k; ++j)\n        if (next == nexts[j])\n          ++indices[j];\n      uglyNums[i] = next;\n    } \n\n    return uglyNums[n - 1];\n  }\n }\n"
    }
  ],
  [
    {
      "id": "314. Binary Tree Vertical Order Traversal",
      "code": "class Solution {\n  public List<List<Integer>> verticalOrder(TreeNode root) {\n    if (root == null)\n      return new ArrayList<>();\n\n    List<List<Integer>> ans = new ArrayList<>();\n    Queue<Pair<TreeNode, Integer>> q = new ArrayDeque<>(); // (TreeNode, x)\n    int[] range = new int[2];\n    getRange(root, range, 0); // Get the leftmost and rightmost x index\n\n    for (int i = range[0]; i <= range[1]; ++i)\n      ans.add(new ArrayList<>());\n\n    q.offer(new Pair<>(root, -range[0]));\n\n    while (!q.isEmpty()) {\n      final TreeNode node = q.peek().getKey();\n      final int x = q.poll().getValue();\n      ans.get(x).add(node.val);\n      if (node.left != null)\n        q.offer(new Pair<>(node.left, x - 1));\n      if (node.right != null)\n        q.offer(new Pair<>(node.right, x + 1));\n    } \n\n    return ans;\n  } \n\n  private void getRange(TreeNode root, int[] range, int x) {\n    if (root == null)\n      return;\n\n    range[0] = Math.min(range[0], x);\n    range[1] = Math.max(range[1], x);\n\n    getRange(root.left, range, x - 1);\n    getRange(root.right, range, x + 1);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "315. Count of Smaller Numbers After Self",
      "code": "class FenwickTree {\n  public FenwickTree(int n) {\n    sums = new int[n + 1];\n  } \n\n  public void update(int i, int delta) {\n    while (i < sums.length) {\n      sums[i] += delta;\n      i += lowbit(i);\n    }\n  } \n\n  public int get(int i) {\n    int sum = 0;\n    while (i > 0) {\n      sum += sums[i];\n      i -= lowbit(i);\n    }\n    return sum;\n  } \n\n  private int[] sums;\n\n  private static int lowbit(int i) {\n    return i & -i;\n  }\n } \n\n class Solution {\n  public List<Integer> countSmaller(int[] nums) {\n    List<Integer> ans = new ArrayList<>();\n    Map<Integer, Integer> ranks = new HashMap<>();\n    getRanks(nums, ranks);\n    FenwickTree tree = new FenwickTree(ranks.size());\n\n    for (int i = nums.length - 1; i >= 0; --i) {\n      final int num = nums[i];\n      ans.add(tree.get(ranks.get(num) - 1));\n      tree.update(ranks.get(num), 1);\n    } \n\n    Collections.reverse(ans);\n    return ans;\n  } \n\n  private void getRanks(int[] nums, Map<Integer, Integer> ranks) {\n    SortedSet<Integer> sorted = new TreeSet<>();\n    for (final int num : nums)\n      sorted.add(num);\n    int rank = 0;\n    for (Iterator<Integer> it = sorted.iterator(); it.hasNext();)\n      ranks.put(it.next(), ++rank);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "316. Remove Duplicate Letters",
      "code": "class Solution {\n  public String removeDuplicateLetters(String s) {\n    StringBuilder sb = new StringBuilder();\n    int[] count = new int[128];\n    boolean[] used = new boolean[128];\n\n    for (final char c : s.toCharArray())\n      ++count[c];\n\n    for (final char c : s.toCharArray()) {\n      --count[c];\n      if (used[c])\n        continue;\n      while (sb.length() > 0 && last(sb) > c && count[last(sb)] > 0) {\n        used[last(sb)] = false;\n        sb.setLength(sb.length() - 1);\n      }\n      used[c] = true;\n      sb.append(c);\n    } \n\n    return sb.toString();\n  } \n\n  private char last(StringBuilder sb) {\n    return sb.charAt(sb.length() - 1);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "317. Shortest Distance from All Buildings",
      "code": "class Solution {\n  public int shortestDistance(int[][] grid) {\n    final int m = grid.length;\n    final int n = grid[0].length;\n    final int nBuildings = getBuildingCount(grid);\n    int ans = Integer.MAX_VALUE;\n    // dist[i][j] := total distance of grid[i][j] (0) to reach all buildings (1)\n    int[][] dist = new int[m][n];\n    // reachCount[i][j] := # of buildings (1) grid[i][j] (0) can reach\n    int[][] reachCount = new int[m][n];\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (grid[i][j] == 1) // Bfs from this building\n          if (!bfs(grid, i, j, dist, reachCount, nBuildings))\n            return -1;\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (reachCount[i][j] == nBuildings)\n          ans = Math.min(ans, dist[i][j]);\n\n    return ans == Integer.MAX_VALUE ? -1 : ans;\n  } \n\n  private static final int[] dirs = {0, 1, 0, -1, 0};\n\n  private boolean bfs(int[][] grid, int row, int col, int[][] dist, int[][] reachCount,\n                      int nBuildings) {\n    final int m = grid.length;\n    final int n = grid[0].length;\n\n    Queue<int[]> q = new ArrayDeque<>(Arrays.asList(new int[] {row, col}));\n    boolean[][] seen = new boolean[m][n];\n    seen[row][col] = true;\n    int depth = 0;\n    int seenBuildings = 1;\n\n    while (!q.isEmpty()) {\n      ++depth;\n      for (int sz = q.size(); sz > 0; --sz) {\n        final int i = q.peek()[0];\n        final int j = q.poll()[1];\n        for (int k = 0; k < 4; ++k) {\n          final int x = i + dirs[k];\n          final int y = j + dirs[k + 1];\n          if (x < 0 || x == m || y < 0 || y == n)\n            continue;\n          if (seen[x][y])\n            continue;\n          seen[x][y] = true;\n          if (grid[x][y] == 0) {\n\n            dist[x][y] += depth;\n            ++reachCount[x][y];\n            q.offer(new int[] {x, y});\n          } else if (grid[x][y] == 1) {\n            ++seenBuildings;\n          }\n        }\n      }\n    } \n\n    return seenBuildings == nBuildings;\n  } \n\n  private int getBuildingCount(int[][] grid) {\n    int buildingCount = 0;\n    for (int[] row : grid)\n      for (final int cell : row)\n        if (cell == 1)\n          ++buildingCount;\n    return buildingCount;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "318. Maximum Product of Word Lengths",
      "code": "class Solution {\n  public int maxProduct(String[] words) {\n    int ans = 0;\n    int[] masks = new int[words.length]; // \"abd\" -> (1011)2\n\n    for (int i = 0; i < words.length; ++i)\n      masks[i] = getMask(words[i]);\n\n    for (int i = 0; i < masks.length; ++i)\n      for (int j = 0; j < i; ++j)\n        if ((masks[i] & masks[j]) == 0)\n          ans = Math.max(ans, words[i].length() * words[j].length());\n\n    return ans;\n  } \n\n  private int getMask(final String word) {\n    int mask = 0;\n    for (final char c : word.toCharArray())\n      mask |= 1 << c - 'a';\n    return mask;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "319. Bulb Switcher",
      "code": "class Solution {\n  public int bulbSwitch(int n) {\n    // K-th bulb only be switched when k % i == 0.\n    // So we can reiterate the problem:\n    // To find # of number <= n that have odd factors.\n    // Obviously, only square numbers have odd factor(s).\n    // E.g. n = 10, only 1, 4, and 9 are square numbers that <= 10\n    return (int) Math.sqrt(n);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "320. Generalized Abbreviation",
      "code": "class Solution {\n  public List<String> generateAbbreviations(String word) {\n    List<String> ans = new ArrayList<>();\n    dfs(word, 0, 0, new StringBuilder(), ans);\n    return ans;\n  } \n\n  private void dfs(final String word, int i, int count, StringBuilder sb, List<String> ans) {\n    if (i == word.length()) {\n      final int length = sb.length();\n      ans.add(sb.append(getCountString(count)).toString());\n      sb.setLength(length);\n      return;\n    } \n\n    // Abbreviate word.charAt(i)\n    dfs(word, i + 1, count + 1, sb, ans);\n    // Keep word.charAt(i), so consume the count as a string\n    final int length = sb.length();\n    // Reset count to 0\n    dfs(word, i + 1, 0, sb.append(getCountString(count)).append(word.charAt(i)), ans);\n    sb.setLength(length);\n  } \n\n  private String getCountString(int count) {\n    return count > 0 ? String.valueOf(count) : \"\";\n  }\n }\n"
    }
  ],
  null,
  [
    {
      "id": "322. Coin Change",
      "code": "class Solution {\n  public int coinChange(int[] coins, int amount) {\n    // dp[i] := fewest # of coins to make up i\n    int[] dp = new int[amount + 1];\n    Arrays.fill(dp, 1, dp.length, amount + 1);\n\n    for (final int coin : coins)\n      for (int i = coin; i <= amount; ++i)\n        dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n\n    return dp[amount] == amount + 1 ? -1 : dp[amount];\n  }\n }\n"
    }
  ],
  [
    {
      "id": "323. Number of Connected Components in an Undirected Graph",
      "code": "class Solution {\n  public int countComponents(int n, int[][] edges) {\n    int ans = 0;\n    List<Integer>[] graph = new List[n];\n    Set<Integer> seen = new HashSet<>();\n\n    for (int i = 0; i < n; ++i)\n      graph[i] = new ArrayList<>();\n\n    for (int[] edge : edges) {\n      final int u = edge[0];\n      final int v = edge[1];\n      graph[u].add(v);\n      graph[v].add(u);\n    } \n\n    for (int i = 0; i < n; ++i)\n      if (!seen.contains(i)) {\n        bfs(graph, i, seen);\n        ++ans;\n      } \n\n    return ans;\n  } \n\n  private void bfs(List<Integer>[] graph, int node, Set<Integer> seen) {\n    Queue<Integer> q = new ArrayDeque<>(Arrays.asList(node));\n    seen.add(node);\n\n    while (!q.isEmpty()) {\n      final int u = q.poll();\n      for (final int v : graph[u])\n        if (!seen.contains(v)) {\n          q.offer(v);\n          seen.add(v);\n        }\n    }\n  }\n }\n"
    }
  ],
  null,
  [
    {
      "id": "325. Maximum Size Subarray Sum Equals k",
      "code": "class Solution {\n  public int maxSubArrayLen(int[] nums, int k) {\n    int ans = 0;\n    int prefix = 0;\n    Map<Integer, Integer> prefixToIndex = new HashMap<>();\n    prefixToIndex.put(0, -1);\n\n    for (int i = 0; i < nums.length; ++i) {\n      prefix += nums[i];\n      final int target = prefix - k;\n      if (prefixToIndex.containsKey(target))\n        ans = Math.max(ans, i - prefixToIndex.get(target));\n      prefixToIndex.putIfAbsent(prefix, i);\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "326. Power of Three",
      "code": "class Solution {\n  public boolean isPowerOfThree(int n) {\n    return n > 0 && Math.pow(3, 19) % n == 0;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "327. Count of Range Sum",
      "code": "class Solution {\n  public int countRangeSum(int[] nums, int lower, int upper) {\n    final int n = nums.length;\n    long[] prefix = new long[n + 1];\n\n    for (int i = 0; i < n; ++i)\n      prefix[i + 1] = (long) nums[i] + prefix[i];\n\n    mergeSort(prefix, 0, n, lower, upper);\n    return ans;\n  } \n\n  private int ans = 0;\n\n  private void mergeSort(long[] prefix, int l, int r, int lower, int upper) {\n    if (l >= r)\n      return;\n\n    final int m = (l + r) / 2;\n    mergeSort(prefix, l, m, lower, upper);\n    mergeSort(prefix, m + 1, r, lower, upper);\n    merge(prefix, l, m, r, lower, upper);\n  } \n\n  private void merge(long[] prefix, int l, int m, int r, int lower, int upper) {\n    int lo = m + 1; // 1st index s.t. prefix[lo] - prefix[i] >= lower\n    int hi = m + 1; // 1st index s.t. prefix[hi] - prefix[i] > upper\n\n    // For each index i in range [l, m], add hi - lo to ans\n    for (int i = l; i <= m; ++i) {\n      while (lo <= r && prefix[lo] - prefix[i] < lower)\n        ++lo;\n      while (hi <= r && prefix[hi] - prefix[i] <= upper)\n        ++hi;\n      ans += hi - lo;\n    } \n\n    long[] sorted = new long[r - l + 1];\n    int k = 0;     // sorted's index\n    int i = l;     // left's index\n    int j = m + 1; // right's index\n\n    while (i <= m && j <= r)\n      if (prefix[i] < prefix[j])\n        sorted[k++] = prefix[i++];\n      else\n        sorted[k++] = prefix[j++];\n\n    // Put possible remaining left part to the sorted array\n    while (i <= m)\n      sorted[k++] = prefix[i++];\n\n    // Put possible remaining right part to the sorted array\n    while (j <= r)\n      sorted[k++] = prefix[j++];\n\n    System.arraycopy(sorted, 0, prefix, l, sorted.length);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "328. Odd Even Linked List",
      "code": "class Solution {\n  public ListNode oddEvenList(ListNode head) {\n    ListNode oddHead = new ListNode(0);\n    ListNode evenHead = new ListNode(0);\n    ListNode odd = oddHead;\n    ListNode even = evenHead;\n\n    for (boolean isOdd = true; head != null; head = head.next, isOdd = !isOdd)\n      if (isOdd) {\n        odd.next = head;\n        odd = odd.next;\n      } else {\n        even.next = head;\n        even = even.next;\n      } \n\n    odd.next = evenHead.next;\n    even.next = null;\n    return oddHead.next;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "329. Longest Increasing Path in a Matrix",
      "code": "class Solution {\n  public int longestIncreasingPath(int[][] matrix) {\n    final int m = matrix.length;\n    final int n = matrix[0].length;\n    int ans = 0;\n    // memo[i][j] := the LIP starting from matrix[i][j]\n    int[][] memo = new int[m][n];\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        ans = Math.max(ans, dfs(matrix, i, j, Integer.MIN_VALUE, memo));\n\n    return ans;\n  } \n\n  private int dfs(int[][] matrix, int i, int j, int prev, int[][] memo) {\n    if (i < 0 || i == matrix.length || j < 0 || j == matrix[0].length)\n      return 0;\n    if (matrix[i][j] <= prev)\n      return 0;\n    if (memo[i][j] > 0)\n      return memo[i][j];\n\n    final int curr = matrix[i][j];\n    final int a = dfs(matrix, i + 1, j, curr, memo);\n    final int b = dfs(matrix, i - 1, j, curr, memo);\n    final int c = dfs(matrix, i, j + 1, curr, memo);\n    final int d = dfs(matrix, i, j - 1, curr, memo);\n    return memo[i][j] = 1 + Math.max(Math.max(a, b), Math.max(c, d));\n  }\n }\n"
    }
  ],
  [
    {
      "id": "330. Patching Array",
      "code": "class Solution {\n  public int minPatches(int[] nums, int n) {\n    int ans = 0;\n    int i = 0;     // Point to nums\n    long miss = 1; // Min sum in [1, n] we might miss\n\n    while (miss <= n)\n      if (i < nums.length && nums[i] <= miss) {\n        miss += nums[i++];\n      } else {\n        // Greedily add miss itself to increase the range\n        // From [1, miss) to [1, 2 * miss)\n        miss += miss;\n        ++ans;\n      } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "331. Verify Preorder Serialization of a Binary Tree",
      "code": "class Solution {\n  public boolean isValidSerialization(String preorder) {\n    int degree = 1; // OutDegree (children) - inDegree (parent)\n\n    for (final String node : preorder.split(\",\")) {\n      if (--degree < 0) // One parent\n        return false;\n      if (!node.equals(\"#\"))\n        degree += 2; // Two children\n    } \n\n    return degree == 0;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "332. Reconstruct Itinerary",
      "code": "class Solution {\n  public List<String> findItinerary(List<List<String>> tickets) {\n    LinkedList<String> ans = new LinkedList<>();\n    Map<String, Queue<String>> graph = new HashMap<>();\n\n    for (final List<String> ticket : tickets) {\n      graph.putIfAbsent(ticket.get(0), new PriorityQueue<>());\n      graph.get(ticket.get(0)).offer(ticket.get(1));\n    } \n\n    dfs(graph, \"JFK\", ans);\n    return ans;\n  } \n\n  private void dfs(Map<String, Queue<String>> graph, final String u, LinkedList<String> ans) {\n    final Queue<String> arrivals = graph.get(u);\n    while (arrivals != null && !arrivals.isEmpty())\n      dfs(graph, arrivals.poll(), ans);\n    ans.addFirst(u);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "333. Largest BST Subtree",
      "code": "class T {\n  public int min;  // Min value in the subtree\n  public int max;  // Max value in the subtree\n  public int size; // Total size of the subtree\n  public T(int min, int max, int size) {\n    this.min = min;\n    this.max = max;\n    this.size = size;\n  }\n } \n\n class Solution {\n  public int largestBSTSubtree(TreeNode root) {\n    return dfs(root).size;\n  } \n\n  private T dfs(TreeNode root) {\n    if (root == null)\n      return new T(Integer.MAX_VALUE, Integer.MIN_VALUE, 0);\n\n    T l = dfs(root.left);\n    T r = dfs(root.right);\n\n    if (l.max < root.val && root.val < r.min)\n      return new T(Math.min(l.min, root.val), Math.max(r.max, root.val), 1 + l.size + r.size);\n\n    // Mark as invalid one, but still record the size of children\n    // Returns (-INF, INF) because any node won't > INT and < -INF\n    return new T(Integer.MIN_VALUE, Integer.MAX_VALUE, Math.max(l.size, r.size));\n  }\n }\n"
    }
  ],
  [
    {
      "id": "334. Increasing Triplet Subsequence",
      "code": "class Solution {\n  public boolean increasingTriplet(int[] nums) {\n    int first = Integer.MAX_VALUE;\n    int second = Integer.MAX_VALUE;\n\n    for (final int num : nums)\n      if (num <= first)\n        first = num;\n      else if (num <= second) // First < num <= second\n        second = num;\n      else // First < second < num (third)\n        return true;\n\n    return false;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "335. Self Crossing",
      "code": "class Solution {\n  public boolean isSelfCrossing(int[] x) {\n    if (x.length <= 3)\n      return false;\n\n    for (int i = 3; i < x.length; ++i) {\n      if (x[i - 2] <= x[i] && x[i - 1] <= x[i - 3])\n        return true;\n      if (i >= 4 && x[i - 1] == x[i - 3] && x[i - 2] <= x[i] + x[i - 4])\n        return true;\n      if (i >= 5 && x[i - 4] <= x[i - 2] && x[i - 2] <= x[i] + x[i - 4] && x[i - 1] <= x[i - 3] &&\n          x[i - 3] <= x[i - 1] + x[i - 5])\n        return true;\n    } \n\n    return false;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "336. Palindrome Pairs",
      "code": "class Solution {\n  public List<List<Integer>> palindromePairs(String[] words) {\n    List<List<Integer>> ans = new ArrayList<>();\n    Map<String, Integer> map = new HashMap<>(); // {reversed word: its index} \n\n    for (int i = 0; i < words.length; ++i)\n      map.put(new StringBuilder(words[i]).reverse().toString(), i);\n\n    for (int i = 0; i < words.length; ++i) {\n      final String word = words[i];\n      // Special case to prevent duplicate calculation\n      if (map.containsKey(\"\") && map.get(\"\") != i && isPalindrome(word))\n        ans.add(Arrays.asList(i, map.get(\"\")));\n      for (int j = 1; j <= word.length(); ++j) {\n        final String l = word.substring(0, j);\n        final String r = word.substring(j);\n        if (map.containsKey(l) && map.get(l) != i && isPalindrome(r))\n          ans.add(Arrays.asList(i, map.get(l)));\n        if (map.containsKey(r) && map.get(r) != i && isPalindrome(l))\n          ans.add(Arrays.asList(map.get(r), i));\n      }\n    } \n\n    return ans;\n  } \n\n  private boolean isPalindrome(final String word) {\n    int l = 0;\n    int r = word.length() - 1;\n    while (l < r)\n      if (word.charAt(l++) != word.charAt(r--))\n        return false;\n    return true;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "337. House Robber III",
      "code": "class T {\n  public int robRoot;\n  public int notRobRoot;\n  public T(int robRoot, int notRobRoot) {\n    this.robRoot = robRoot;\n    this.notRobRoot = notRobRoot;\n  }\n } \n\n class Solution {\n  public int rob(TreeNode root) {\n    T t = robOrNotRob(root);\n    return Math.max(t.robRoot, t.notRobRoot);\n  } \n\n  private T robOrNotRob(TreeNode root) {\n    if (root == null)\n      return new T(0, 0);\n\n    T l = robOrNotRob(root.left);\n    T r = robOrNotRob(root.right);\n\n    return new T(root.val + l.notRobRoot + r.notRobRoot,\n                 Math.max(l.robRoot, l.notRobRoot) + Math.max(r.robRoot, r.notRobRoot));\n  }\n }\n"
    }
  ],
  [
    {
      "id": "338. Counting Bits",
      "code": "class Solution {\n  public int[] countBits(int n) {\n    // Let f(i) := i's # of 1's in bitmask\n    // f(i) = f(i / 2) + i % 2\n    int[] ans = new int[n + 1];\n\n    for (int i = 1; i <= n; ++i)\n      ans[i] = ans[i / 2] + (i % 2 == 0 ? 0 : 1);\n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "339. Nested List Weight Sum",
      "code": "class Solution {\n  public int depthSum(List<NestedInteger> nestedList) {\n    int ans = 0;\n    int depth = 0;\n    Queue<NestedInteger> q = new ArrayDeque<>();\n\n    addIntegers(q, nestedList);\n\n    while (!q.isEmpty()) {\n      ++depth;\n      for (int sz = q.size(); sz > 0; --sz) {\n        final NestedInteger ni = q.poll();\n        if (ni.isInteger())\n          ans += ni.getInteger() * depth;\n        else\n          addIntegers(q, ni.getList());\n      }\n    } \n\n    return ans;\n  } \n\n  private void addIntegers(Queue<NestedInteger> q, List<NestedInteger> nestedList) {\n    for (final NestedInteger ni : nestedList)\n      q.offer(ni);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "340. Longest Substring with At Most K Distinct Characters",
      "code": "class Solution {\n  public int lengthOfLongestSubstringKDistinct(String s, int k) {\n    int ans = 0;\n    int distinct = 0;\n    int[] count = new int[128];\n\n    for (int l = 0, r = 0; r < s.length(); ++r) {\n      if (++count[s.charAt(r)] == 1)\n        ++distinct;\n      while (distinct == k + 1)\n        if (--count[s.charAt(l++)] == 0)\n          --distinct;\n      ans = Math.max(ans, r - l + 1);\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "341. Flatten Nested List Iterator",
      "code": "public class NestedIterator implements Iterator<Integer> {\n  public NestedIterator(List<NestedInteger> nestedList) {\n    addInteger(nestedList);\n  } \n\n  @Override\n  public Integer next() {\n    return q.poll();\n  } \n\n  @Override\n  public boolean hasNext() {\n    return !q.isEmpty();\n  } \n\n  private Queue<Integer> q = new ArrayDeque<>();\n\n  private void addInteger(final List<NestedInteger> nestedList) {\n    for (final NestedInteger ni : nestedList)\n      if (ni.isInteger())\n        q.offer(ni.getInteger());\n      else\n        addInteger(ni.getList());\n  }\n }\n"
    }
  ],
  [
    {
      "id": "342. Power of Four",
      "code": "class Solution {\n  public boolean isPowerOfFour(int n) {\n    // Why (4^n - 1) % 3 == 0?\n    // (4^n - 1) = (2^n - 1)(2^n + 1) and 2^n - 1, 2^n, 2^n + 1 are\n    // Three consecutive numbers; among one of them, there must be a multiple\n    // Of 3, and that can't be 2^n, so it must be either 2^n - 1 or 2^n + 1.\n    // Therefore, 4^n - 1 is a multiple of 3\n    return n > 0 && Integer.bitCount(n) == 1 && (n - 1) % 3 == 0;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "343. Integer Break",
      "code": "class Solution {\n  public int integerBreak(int n) {\n    // If an optimal product contains a factor f >= 4, then we can replace it\n    // With 2 and f - 2 without losing optimality. As 2(f - 2) = 2f - 4 >= f,\n    // We never need a factor >= 4, meaning we only need factors 1, 2, and 3\n    // (and 1 is wasteful).\n    // Also, 3 * 3 is better than 2 * 2 * 2, so we never use 2 more than twice.\n    if (n == 2)\n      return 1; // 1 * 1\n    if (n == 3)\n      return 2; // 1 * 2\n\n    int ans = 1;\n\n    while (n > 4) {\n      n -= 3;\n      ans *= 3;\n    }\n    ans *= n;\n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "344. Reverse String",
      "code": "class Solution {\n  public void reverseString(char[] s) {\n    int l = 0;\n    int r = s.length - 1;\n\n    while (l < r) {\n      char temp = s[l];\n      s[l++] = s[r];\n      s[r--] = temp;\n    }\n  }\n }\n"
    }
  ],
  [
    {
      "id": "345. Reverse Vowels of a String",
      "code": "class Solution {\n  public String reverseVowels(String s) {\n    final String vowels = \"aeiouAEIOU\";\n    StringBuilder sb = new StringBuilder(s);\n    int l = 0;\n    int r = s.length() - 1;\n\n    while (l < r) {\n      while (l < r && !vowels.contains(\"\" + sb.charAt(l)))\n        ++l;\n      while (l < r && !vowels.contains(\"\" + sb.charAt(r)))\n        --r;\n      sb.setCharAt(l, s.charAt(r));\n      sb.setCharAt(r, s.charAt(l));\n      ++l;\n      --r;\n    } \n\n    return sb.toString();\n  }\n }\n"
    }
  ],
  [
    {
      "id": "346. Moving Average from Data Stream",
      "code": "class MovingAverage {\n  public MovingAverage(int size) {\n    this.size = size;\n  } \n\n  public double next(int val) {\n    if (q.size() == size)\n      sum -= q.poll();\n    sum += val;\n    q.offer(val);\n    return sum / q.size();\n  } \n\n  private int size = 0;\n  private double sum = 0;\n  private Queue<Integer> q = new ArrayDeque<>();\n}\n"
    }
  ],
  [
    {
      "id": "347. Top K Frequent Elements",
      "code": "class T {\n  public int num;\n  public int freq;\n  public T(int num, int freq) {\n    this.num = num;\n    this.freq = freq;\n  }\n } \n\n class Solution {\n  public int[] topKFrequent(int[] nums, int k) {\n    final int n = nums.length;\n    int[] ans = new int[k];\n    Map<Integer, Integer> count = new HashMap<>();\n    Queue<T> minHeap = new PriorityQueue<>((a, b) -> a.freq - b.freq);\n\n    for (final int num : nums)\n      count.merge(num, 1, Integer::sum);\n\n    for (Map.Entry<Integer, Integer> entry : count.entrySet()) {\n      final int num = entry.getKey();\n      final int freq = entry.getValue();\n      minHeap.offer(new T(num, freq));\n      if (minHeap.size() > k)\n        minHeap.poll();\n    } \n\n    for (int i = 0; i < k; ++i)\n      ans[i] = minHeap.poll().num;\n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "348. Design Tic-Tac-Toe",
      "code": "class TicTacToe {\n  public TicTacToe(int n) {\n    this.n = n;\n    rows = new int[n];\n    cols = new int[n];\n  } \n\n  /**\n   * Player {player} makes a move at ({row}, {col}).\n   *\n   * @param row    The row of the board.\n   * @param col    The column of the board.\n   * @param player The player, can be either 1 or 2.\n   * @return The current winning condition, can be either:\n   *         0: No one wins.\n   *         1: Player 1 wins.\n   *         2: Player 2 wins.\n   */\n  public int move(int row, int col, int player) {\n    final int toAdd = player == 1 ? 1 : -1;\n    final int target = player == 1 ? n : -n;\n\n    if (row == col) {\n      diag += toAdd;\n      if (diag == target)\n        return player;\n    } \n\n    if (row + col == n - 1) {\n      antiDiag += toAdd;\n      if (antiDiag == target)\n        return player;\n    } \n\n    rows[row] += toAdd;\n    if (rows[row] == target)\n      return player;\n\n    cols[col] += toAdd;\n    if (cols[col] == target)\n      return player;\n\n    return 0;\n  } \n\n  private final int n;\n  // Record count('X') - count('O')\n  private int[] rows;\n  private int[] cols;\n  private int diag = 0;\n  private int antiDiag = 0;\n}\n"
    }
  ],
  [
    {
      "id": "349. Intersection of Two Arrays",
      "code": "class Solution {\n  public int[] intersection(int[] nums1, int[] nums2) {\n    List<Integer> ans = new ArrayList<>();\n    Set<Integer> set = Arrays.stream(nums1).boxed().collect(Collectors.toSet());\n\n    for (final int num : nums2)\n      if (set.remove(num))\n        ans.add(num);\n\n    return ans.stream().mapToInt(Integer::intValue).toArray();\n  }\n }\n"
    }
  ],
  [
    {
      "id": "350. Intersection of Two Arrays II",
      "code": "class Solution {\n  public int[] intersect(int[] nums1, int[] nums2) {\n    if (nums1.length > nums2.length)\n      return intersect(nums2, nums1);\n\n    List<Integer> ans = new ArrayList<>();\n    Map<Integer, Integer> count = new HashMap<>();\n\n    for (final int num : nums1)\n      count.put(num, count.getOrDefault(num, 0) + 1);\n\n    for (final int num : nums2)\n      if (count.containsKey(num) && count.get(num) > 0) {\n        ans.add(num);\n        count.put(num, count.get(num) - 1);\n      } \n\n    return ans.stream().mapToInt(Integer::intValue).toArray();\n  }\n }\n"
    }
  ],
  [
    {
      "id": "351. Android Unlock Patterns",
      "code": "class Solution {\n  public int numberOfPatterns(int m, int n) {\n    int ans = 0;\n    int[][] across = new int[10][10];\n    boolean[] seen = new boolean[10];\n\n    across[1][3] = across[3][1] = 2;\n    across[1][7] = across[7][1] = 4;\n    across[3][9] = across[9][3] = 6;\n    across[7][9] = across[9][7] = 8;\n    across[1][9] = across[9][1] = across[2][8] = across[8][2] = across[3][7] = across[7][3] =\n        across[4][6] = across[6][4] = 5;\n\n    ans += dfs(m, n, 1, 1, seen, across) * 4; // 1, 3, 7, 9 are symmetric\n    ans += dfs(m, n, 2, 1, seen, across) * 4; // 2, 4, 6, 8 are symmetric\n    ans += dfs(m, n, 5, 1, seen, across);     // 5\n    return ans;\n  } \n\n  private int dfs(int m, int n, int u, int level, boolean[] seen, int[][] across) {\n    if (level > n)\n      return 0;\n\n    seen[u] = true;\n    int ans = level >= m;\n\n    for (int v = 1; v <= 9; ++v) {\n      if (v == u || seen[v])\n        continue;\n      final int acrossed = across[u][v];\n      if (acrossed == 0 || seen[acrossed])\n        ans += dfs(m, n, v, level + 1, seen, across);\n    } \n\n    seen[u] = false;\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "352. Data Stream as Disjoint Intervals",
      "code": "class SummaryRanges {\n  public void addNum(int val) {\n    if (map.containsKey(val))\n      return;\n\n    final Integer lo = map.lowerKey(val);  // Maximum in map < key\n    final Integer hi = map.higherKey(val); // Minimum in map > key\n\n    // {lo, map.get(lo)[1]} + val + {hi, map.get(hi)[1]} = {lo, map.get(hi)[1]}\n    if (lo != null && hi != null && map.get(lo)[1] + 1 == val && val + 1 == hi) {\n      map.get(lo)[1] = map.get(hi)[1];\n      map.remove(hi);\n      // {lo, map.get(lo)[1]} + val = {lo, val}\n      // (prevent adding duplicate entry by using '>=' instead of '==')\n    } else if (lo != null && map.get(lo)[1] + 1 >= val) {\n      map.get(lo)[1] = Math.max(map.get(lo)[1], val);\n      // Val + {hi, map.get(hi)[1]} = {val, map.get(hi)[1]}\n    } else if (hi != null && val + 1 == hi) {\n      map.put(val, new int[] {val, map.get(hi)[1]});\n      map.remove(hi);\n    } else {\n      map.put(val, new int[] {val, val});\n    }\n  } \n\n  public int[][] getIntervals() {\n    return map.values().stream().toArray(int[][] ::new);\n  } \n\n  // {start: {start, end}}\n  private TreeMap<Integer, int[]> map = new TreeMap<>();\n}\n"
    }
  ],
  null,
  [
    {
      "id": "354. Russian Doll Envelopes",
      "code": "class Solution {\n  public int maxEnvelopes(int[][] envelopes) {\n    Arrays.sort(envelopes, (a, b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\n\n    // Same as 300. Longest Increasing Subsequence\n    int ans = 0;\n    int[] dp = new int[envelopes.length];\n\n    for (int[] e : envelopes) {\n      int i = Arrays.binarySearch(dp, 0, ans, e[1]);\n      if (i < 0)\n        i = -(i + 1);\n      dp[i] = e[1];\n      if (i == ans)\n        ++ans;\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "355. Design Twitter",
      "code": "class Tweet {\n  public int id;\n  public int time;\n  public Tweet next = null;\n  public Tweet(int id, int time) {\n    this.id = id;\n    this./**time = time;\n  }\n } \n\n class User {\n  private int id;\n  public Set<Integer> followeeIds = new HashSet<>();\n  public Tweet tweetHead = null;\n\n  public User(int id) {\n    this.id = id;\n    follow(id); // Follow himself\n  } \n\n  public void follow(int followeeId) {\n    followeeIds.add(followeeId);\n  } \n\n  public void unfollow(int followeeId) {\n    followeeIds.remove(followeeId);\n  } \n\n  public void post(int tweetId, int time) {\n    final Tweet oldTweetHead = tweetHead;\n    tweetHead = new Tweet(tweetId, time);\n    tweetHead.next = oldTweetHead;\n  }\n } \n\n class Twitter {\n   Compose a new tweet. */\n  public void postTweet(int userId, int tweetId) {\n    users.putIfAbsent(userId, new User(userId));\n    users.get(userId).post(tweetId, time++);\n  } \n\n  /**\n   * Retrieve the 10 most recent tweet ids in the user's news feed. Each item in\n   * the news feed must be posted by users who the user followed or by the user\n   * herself. Tweets must be ordered from most recent to least recent.\n   */\n  public List<Integer> getNewsFeed(int userId) {\n    if (!users.containsKey(userId))\n      return new ArrayList<>();\n\n    List<Integer> newsFeed = new ArrayList<>();\n    Queue<Tweet> maxHeap = new PriorityQueue<>((a, b) -> b.time - a.time);\n\n    for (final int followeeId : users.get(userId).followeeIds) {\n      Tweet tweetHead = users.get(followeeId).tweetHead;\n      if (tweetHead != null)\n        maxHeap.offer(tweetHead);\n    } \n\n    int count = 0;\n    while (!maxHeap.isEmpty() && count++ < 10) {\n      Tweet tweet = maxHeap.poll();\n      newsFeed.add(tweet.id);\n      if (tweet.next != null)\n        maxHeap.offer(tweet.next);\n    } \n\n    return newsFeed;\n  } \n\n  /**\n   * Follower follows a followee.\n   * If the operation is invalid, it should be a no-op.\n   */\n  public void follow(int followerId, int followeeId) {\n    if (followerId == followeeId)\n      return;\n    users.putIfAbsent(followerId, new User(followerId));\n    users.putIfAbsent(followeeId, new User(followeeId));\n    users.get(followerId).follow(followeeId);\n  } \n\n  /**\n   * Follower unfollows a followee.\n   * If the operation is invalid, it should be a no-op.\n   */\n  public void unfollow(int followerId, int followeeId) {\n    if (followerId == followeeId)\n      return;\n    if (users.containsKey(followerId) && users.containsKey(followeeId))\n      users.get(followerId).unfollow(followeeId);\n  } \n\n  private int time = 0;\n  private Map<Integer, User> users = new HashMap<>(); // {userId: User}\n }\n"
    }
  ],
  [
    {
      "id": "356. Line Reflection",
      "code": "class Solution {\n  public boolean isReflected(int[][] points) {\n    int minX = Integer.MAX_VALUE;\n    int maxX = Integer.MIN_VALUE;\n    Set<String> seen = new HashSet<>();\n\n    for (int[] p : points) {\n      final int x = p[0];\n      final int y = p[1];\n      minX = Math.min(minX, x);\n      maxX = Math.max(maxX, x);\n      seen.add(x + \",\" + y);\n    } \n\n    final int sum = minX + maxX;\n    // (leftX + rightX) / 2 = (minX + maxX) / 2\n    //  leftX = minX + maxX - rightX\n    // RightX = minX + maxX - leftX\n\n    for (int[] p : points)\n      if (!seen.contains(sum - p[0] + \",\" + p[1]))\n        return false;\n\n    return true;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "357. Count Numbers with Unique Digits",
      "code": "class Solution {\n  public int countNumbersWithUniqueDigits(int n) {\n    if (n == 0)\n      return 1;\n\n    int ans = 10;\n    int uniqueDigits = 9;\n\n    for (int availableNum = 9; n > 1 && availableNum > 0; --n, --availableNum) {\n      uniqueDigits *= availableNum;\n      ans += uniqueDigits;\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "358. Rearrange String k Distance Apart",
      "code": "class Solution {\n  public String rearrangeString(String s, int k) {\n    final int n = s.length();\n    StringBuilder sb = new StringBuilder();\n    int[] count = new int[128];\n    int[] valid = new int[128]; // valid[i] := the leftmost index char i can appear\n\n    for (final char c : s.toCharArray())\n      ++count[c];\n\n    for (int i = 0; i < n; ++i) {\n      final char c = getBestLetter(count, valid, i);\n      if (c == '*')\n        return \"\";\n      sb.append(c);\n      --count[c];\n      valid[c] = i + k;\n    } \n\n    return sb.toString();\n  } \n\n  // Returns the letter that has most count and also valid\n  private char getBestLetter(int[] count, int[] valid, int index) {\n    int maxCount = -1;\n    char bestLetter = '*';\n\n    for (char c = 'a'; c <= 'z'; ++c)\n      if (count[c] > 0 && count[c] > maxCount && index >= valid[c]) {\n        bestLetter = c;\n        maxCount = count[c];\n      } \n\n    return bestLetter;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "359. Logger Rate Limiter",
      "code": "class Logger {\n  public boolean shouldPrintMessage(int timestamp, String message) {\n    // Remove messages that are 10 secs from the current timestamp\n    while (!messageQueue.isEmpty()) {\n      Pair<Integer, String> head = messageQueue.peekFirst();\n      if (timestamp - head.getKey() < 10)\n        break;\n      messageQueue.pollFirst();\n      messageSet.remove(head.getValue());\n    } \n\n    if (messageSet.contains(message))\n      return false;\n\n    messageQueue.offerLast(new Pair<>(timestamp, message));\n    messageSet.add(message);\n    return true;\n  } \n\n  // [(timestamp, message)]\n  private Deque<Pair<Integer, String>> messageQueue = new ArrayDeque<>();\n  private Set<String> messageSet = new HashSet<>();\n}\n"
    }
  ],
  null,
  [
    {
      "id": "361. Bomb Enemy",
      "code": "class Solution {\n  public int maxKilledEnemies(char[][] grid) {\n    if (grid.length == 0 || grid[0].length == 0)\n      return 0;\n\n    final int m = grid.length;\n    final int n = grid[0].length;\n    int ans = 0;\n    // dp[i][j] := max enemies grid[i][j] can kill\n    int[][] dp = new int[m][n];\n\n    // Extend four directions, if meet 'W', need to start over from 0\n    for (int i = 0; i < m; ++i) {\n      enemyCount = 0;\n      for (int j = 0; j < n; ++j)\n        update(grid, i, j, dp);\n      enemyCount = 0;\n      for (int j = n - 1; j >= 0; --j)\n        update(grid, i, j, dp);\n    } \n\n    for (int j = 0; j < n; ++j) {\n      enemyCount = 0;\n      for (int i = 0; i < m; ++i)\n        update(grid, i, j, dp);\n      enemyCount = 0;\n      for (int i = m - 1; i >= 0; --i)\n        update(grid, i, j, dp);\n    } \n\n    for (int[] row : dp)\n      ans = Math.max(ans, Arrays.stream(row).max().getAsInt());\n\n    return ans;\n  } \n\n  private int enemyCount = 0;\n\n  private void update(char[][] grid, int i, int j, int[][] dp) {\n    if (grid[i][j] == '0')\n      dp[i][j] += enemyCount;\n    else if (grid[i][j] == 'E')\n      ++enemyCount;\n    else // grid[i][j] == 'W'\n      enemyCount = 0;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "362. Design Hit Counter",
      "code": "class HitCounter {\n  public void hit(int timestamp) {\n    final int i = timestamp % 300;\n\n    if (timestamps[i] == timestamp) {\n      ++hits[i];\n    } else {\n      timestamps[i] = timestamp;\n      hits[i] = 1; // Reset hit count to 1\n    }\n  } \n\n  public int getHits(int timestamp) {\n    int countHits = 0;\n\n    for (int i = 0; i < 300; ++i)\n      if (timestamp - timestamps[i] < 300)\n        countHits += hits[i];\n\n    return countHits;\n  } \n\n  private int[] timestamps = new int[300];\n  private int[] hits = new int[300];\n}\n"
    }
  ],
  [
    {
      "id": "363. Max Sum of Rectangle No Larger Than K",
      "code": "class Solution {\n  public int maxSumSubmatrix(int[][] matrix, int k) {\n    final int m = matrix.length;\n    final int n = matrix[0].length;\n    int ans = Integer.MIN_VALUE;\n\n    for (int baseCol = 0; baseCol < n; ++baseCol) {\n      // sums[i] := sum(matrix[i][baseCol..j])\n      int[] sums = new int[m];\n      for (int j = baseCol; j < n; ++j) {\n        for (int i = 0; i < m; ++i)\n          sums[i] += matrix[i][j];\n        // Find the max subarray no more than k\n        TreeSet<Integer> accumulate = new TreeSet<>(Arrays.asList(0));\n        int prefix = 0;\n        for (final int sum : sums) {\n          prefix += sum;\n          final Integer lo = accumulate.ceiling(prefix - k);\n          if (lo != null)\n            ans = Math.max(ans, prefix - lo);\n          accumulate.add(prefix);\n        }\n      }\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "364. Nested List Weight Sum II",
      "code": "class Solution {\n  public int depthSumInverse(List<NestedInteger> nestedList) {\n    int ans = 0;\n    int prevSum = 0;\n    Queue<NestedInteger> q = new ArrayDeque<>(nestedList);\n\n    while (!q.isEmpty()) {\n      for (int sz = q.size(); sz > 0; --sz) {\n        final NestedInteger ni = q.poll();\n        if (ni.isInteger())\n          prevSum += ni.getInteger();\n        else\n          q.addAll(ni.getList());\n      }\n      ans += prevSum;\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "365. Water and Jug Problem",
      "code": "class Solution {\n  public boolean canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity) {\n    return targetCapacity == 0 || jug1Capacity + jug2Capacity >= targetCapacity &&\n                                      targetCapacity % gcd(jug1Capacity, jug2Capacity) == 0;\n  } \n\n  private int gcd(int a, int b) {\n    return b == 0 ? a : gcd(b, a % b);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "366. Find Leaves of Binary Tree",
      "code": "class Solution {\n  public List<List<Integer>> findLeaves(TreeNode root) {\n    List<List<Integer>> ans = new ArrayList<>();\n\n    depth(root, ans);\n    return ans;\n  } \n\n  // Depth of root (0-indexed)\n  private int depth(TreeNode root, List<List<Integer>> ans) {\n    if (root == null)\n      return -1;\n\n    final int l = depth(root.left, ans);\n    final int r = depth(root.right, ans);\n    final int h = 1 + Math.max(l, r);\n    if (ans.size() == h) // Meet leaf\n      ans.add(new ArrayList<>());\n\n    ans.get(h).add(root.val);\n    return h;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "367. Valid Perfect Square",
      "code": "class Solution {\n  public boolean isPerfectSquare(int num) {\n    long l = 1;\n    long r = num;\n\n    while (l < r) {\n      final long m = (l + r) / 2;\n      if (m >= num / m)\n        r = m;\n      else\n        l = m + 1;\n    } \n\n    return l * l == num;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "368. Largest Divisible Subset",
      "code": "class Solution {\n  public List<Integer> largestDivisibleSubset(int[] nums) {\n    final int n = nums.length;\n    List<Integer> ans = new ArrayList<>();\n    // sizeEndsAt[i] := largest size ends at nums[i]\n    int[] sizeEndsAt = new int[n];\n    // prevIndex[i] := the best index s.t.\n    // 1. nums[i] % nums[prevIndex[i]] == 0 and\n    // 2. can increase the size of the subset\n    int[] prevIndex = new int[n];\n    int maxSize = 0; // Max size of the subset\n    int index = -1;  // Track the best ending index\n\n    Arrays.fill(sizeEndsAt, 1);\n    Arrays.fill(prevIndex, -1);\n    Arrays.sort(nums);\n\n    // Fix max ending num in the subset first\n    for (int i = 0; i < n; ++i) {\n      for (int j = i - 1; j >= 0; --j)\n        if (nums[i] % nums[j] == 0 && sizeEndsAt[i] < sizeEndsAt[j] + 1) {\n          sizeEndsAt[i] = sizeEndsAt[j] + 1;\n          prevIndex[i] = j;\n        }\n      // Find a new subset that has a bigger size\n      if (maxSize < sizeEndsAt[i]) {\n        maxSize = sizeEndsAt[i];\n        index = i; // Update the best ending index\n      }\n    } \n\n    // Loop from back to front\n    while (index != -1) {\n      ans.add(nums[index]);\n      index = prevIndex[index];\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "369. Plus One Linked List",
      "code": "class Solution {\n  public ListNode plusOne(ListNode head) {\n    if (head == null)\n      return new ListNode(1);\n    if (addOne(head) == 1)\n      return new ListNode(1, head);\n    return head;\n  } \n\n  private int addOne(ListNode node) {\n    final int carry = node.next == null ? 1 : addOne(node.next);\n    final int sum = node.val + carry;\n    node.val = sum % 10;\n    return sum / 10;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "370. Range Addition",
      "code": "class Solution {\n  public int[] getModifiedArray(int length, int[][] updates) {\n    int[] ans = new int[length];\n    int prefix = 0;\n\n    for (int[] update : updates) {\n      final int startIndex = update[0];\n      final int endIndex = update[1];\n      final int inc = update[2];\n      ans[startIndex] += inc;\n      if (endIndex + 1 < length)\n        ans[endIndex + 1] -= inc;\n    } \n\n    for (int i = 0; i < length; ++i) {\n      prefix += ans[i];\n      ans[i] = prefix;\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "371. Sum of Two Integers",
      "code": "class Solution {\n  public int getSum(int a, int b) {\n    while (b != 0) {           // Still have carry bits\n      final int carry = a & b; // Record carry bits\n      a ^= b;                  // ^ works like + w/o handling carry bits\n      b = carry << 1;\n    }\n    return a;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "372. Super Pow",
      "code": "class Solution {\n  public int superPow(int a, int[] b) {\n    int ans = 1;\n\n    a %= k;\n    for (final int i : b)\n      ans = powMod(ans, 10) * powMod(a, i) % k;\n\n    return ans;\n  } \n\n  private final int k = 1337;\n\n  private int powMod(int x, int y) {\n    int pow = 1;\n    while (y-- > 0)\n      pow = (pow * x) % k;\n    return pow;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "373. Find K Pairs with Smallest Sums",
      "code": "class T {\n  public int i;\n  public int j;\n  public int sum; // nums1[i] + nums2[j]\n  public T(int i, int j, int sum) {\n    this.i = i;\n    this.j = j;\n    this.sum = sum;\n  }\n } \n\n class Solution {\n  public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\n    List<List<Integer>> ans = new ArrayList<>();\n    Queue<T> minHeap = new PriorityQueue<>((a, b) -> a.sum - b.sum);\n\n    for (int i = 0; i < k && i < nums1.length; ++i)\n      minHeap.offer(new T(i, 0, nums1[i] + nums2[0]));\n\n    while (!minHeap.isEmpty() && ans.size() < k) {\n      final int i = minHeap.peek().i;\n      final int j = minHeap.poll().j;\n      ans.add(Arrays.asList(nums1[i], nums2[j]));\n      if (j + 1 < nums2.length)\n        minHeap.offer(new T(i, j + 1, nums1[i] + nums2[j + 1]));\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  null,
  [
    {
      "id": "375. Guess Number Higher or Lower II",
      "code": "class Solution {\n  public int getMoneyAmount(int n) {\n    // dp[i][j] := min money you need to guarantee a win of picking i..j\n    dp = new int[n + 1][n + 1];\n    Arrays.stream(dp).forEach(A -> Arrays.fill(A, Integer.MAX_VALUE));\n    return getMoneyAmount(1, n);\n  } \n\n  private int[][] dp;\n\n  private int getMoneyAmount(int i, int j) {\n    if (i >= j)\n      return 0;\n    if (dp[i][j] != Integer.MAX_VALUE)\n      return dp[i][j];\n\n    for (int k = i; k <= j; ++k)\n      dp[i][j] = Math.min(\n          dp[i][j],\n          Math.max(getMoneyAmount(i, k - 1), getMoneyAmount(k + 1, j)) + k);\n\n    return dp[i][j];\n  }\n }\n"
    }
  ],
  [
    {
      "id": "376. Wiggle Subsequence",
      "code": "class Solution {\n  public int wiggleMaxLength(int[] nums) {\n    int increasing = 1;\n    int decreasing = 1;\n\n    for (int i = 1; i < nums.length; ++i)\n      if (nums[i] > nums[i - 1])\n        increasing = decreasing + 1;\n      else if (nums[i] < nums[i - 1])\n        decreasing = increasing + 1;\n\n    return Math.max(increasing, decreasing);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "377. Combination Sum IV",
      "code": "class Solution {\n  public int combinationSum4(int[] nums, int target) {\n    // dp[i] := # of combinations that add up to i\n    int[] dp = new int[target + 1];\n    dp[0] = 1;\n\n    for (int i = 0; i <= target; ++i)\n      for (final int num : nums)\n        if (i >= num)\n          dp[i] += dp[i - num];\n\n    return dp[target];\n  }\n }\n"
    }
  ],
  [
    {
      "id": "378. Kth Smallest Element in a Sorted Matrix",
      "code": "class T {\n  public int i;\n  public int j;\n  public int num; // matrix[i][j]\n  public T(int i, int j, int num) {\n    this.i = i;\n    this.j = j;\n    this.num = num;\n  }\n } \n\n class Solution {\n  public int kthSmallest(int[][] matrix, int k) {\n    Queue<T> minHeap = new PriorityQueue<>((a, b) -> a.num - b.num);\n\n    for (int i = 0; i < k && i < matrix.length; ++i)\n      minHeap.offer(new T(i, 0, matrix[i][0]));\n\n    while (k-- > 1) {\n      final int i = minHeap.peek().i;\n      final int j = minHeap.poll().j;\n      if (j + 1 < matrix[0].length)\n        minHeap.offer(new T(i, j + 1, matrix[i][j + 1]));\n    } \n\n    return minHeap.peek().num;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "379. Design Phone Directory",
      "code": "class PhoneDirectory {\n  /**\n   * Initialize your data structure here\n   *\n   * @param maxNumbers - The maximum numbers that can be stored in the phone\n   *                   directory.\n   */\n  public PhoneDirectory(int maxNumbers) {\n    next = new int[maxNumbers];\n    for (int i = 0; i < maxNumbers - 1; ++i)\n      next[i] = i + 1;\n    next[maxNumbers - 1] = 0;\n  } \n\n  /**\n   * Provide a number which is not assigned to anyone.\n   *\n   * @return - Return an available number. Return -1 if none is available.\n   */\n  public int get() {\n    if (next[number] == -1)\n      return -1;\n\n    final int availableNum = number;\n    number = next[number];\n    next[availableNum] = -1; // Mark as used\n    return ans;\n  } \n\n  /** Check if a number is available or not. */\n  public boolean check(int number) {\n    return next[number] != -1;\n  } \n\n  /** Recycle or release a number. */\n  public void release(int number) {\n    if (next[number] != -1)\n      return;\n\n    next[number] = this.number;\n    this.number = number;\n  } \n\n  private int number; // Current possible available number\n  private int[] next; // Next available number\n}\n"
    }
  ],
  [
    {
      "id": "380. Insert Delete GetRandom O(1)",
      "code": "class RandomizedSet {\n  /**\n   * Inserts a value to the set. Returns true if the set did not already contain the specified\n   * element.\n   */\n  public boolean insert(int val) {\n    if (valToIndex.containsKey(val))\n      return false;\n\n    valToIndex.put(val, vals.size());\n    vals.add(val);\n    return true;\n  } \n\n  /** Removes a value from the set. Returns true if the set contained the specified element. */\n  public boolean remove(int val) {\n    if (!valToIndex.containsKey(val))\n      return false;\n\n    final int index = valToIndex.get(val);\n    // Following two lines order are important when vals.size() == 1\n    valToIndex.put(last(vals), index);\n    valToIndex.remove(val);\n    vals.set(index, last(vals));\n    vals.remove(vals.size() - 1);\n    return true;\n  } \n\n  /** Get a random element from the set. */\n  public int getRandom() {\n    final int index = rand.nextInt(vals.size());\n    return vals.get(index);\n  } \n\n  private Map<Integer, Integer> valToIndex = new HashMap<>(); // {val: index in vals}\n  private List<Integer> vals = new ArrayList<>();\n  private Random rand = new Random();\n\n  private int last(List<Integer> vals) {\n    return vals.get(vals.size() - 1);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "381. Insert Delete GetRandom O(1) - Duplicates allowed",
      "code": "class Item {\n  public int val;\n  public int indexInMap;\n  public Item(int val, int indexInMap) {\n    this.val = val;\n    this.indexInMap = indexInMap;\n  }\n } \n\n class RandomizedCollection {\n  /**\n   * Inserts a value to the collection. Returns true if the collection did not already contain the\n   * specified element.\n   */\n  public boolean insert(int val) {\n    valToIndices.putIfAbsent(val, new ArrayList<>());\n    valToIndices.get(val).add(items.size());\n    items.add(new Item(val, valToIndices.get(val).size() - 1));\n    return valToIndices.get(val).size() == 1;\n  } \n\n  /**\n   * Removes a value from the collection. Returns true if the collection contained the specified\n   * element.\n   */\n  public boolean remove(int val) {\n    if (!valToIndices.containsKey(val))\n      return false;\n\n    final int index = lastIndex(valToIndices.get(val));\n    valToIndices.get(last(items).val).set(last(items).indexInMap, index);\n    final int indicesSize = valToIndices.get(val).size();\n    valToIndices.get(val).remove(indicesSize - 1);\n    if (valToIndices.get(val).isEmpty())\n      valToIndices.remove(val);\n    items.set(index, last(items));\n    items.remove(items.size() - 1);\n    return true;\n  } \n\n  /** Get a random element from the collection. */\n  public int getRandom() {\n    final int index = rand.nextInt(items.size());\n    return items.get(index).val;\n  } \n\n  private Map<Integer, List<Integer>> valToIndices = new HashMap<>();\n  private List<Item> items = new ArrayList<>();\n  private Random rand = new Random();\n\n  private int lastIndex(List<Integer> indices) {\n    return indices.get(indices.size() - 1);\n  } \n\n  private Item last(List<Item> items) {\n    return items.get(items.size() - 1);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "382. Linked List Random Node",
      "code": "class Solution {\n  /**\n   * @param head The linked list's head. Note that the head is guaranteed to be\n   *             not null, so it contains at least one node.\n   */\n  public Solution(ListNode head) {\n    this.head = head;\n  } \n\n  /** Returns a random node's value. */\n  public int getRandom() {\n    int ans = -1;\n    int i = 1;\n\n    for (ListNode curr = head; curr != null; curr = curr.next, ++i)\n      if (rand.nextInt(i) == i - 1)\n        ans = curr.val;\n\n    return ans;\n  } \n\n  private ListNode head;\n  private Random rand = new Random();\n}\n"
    }
  ],
  [
    {
      "id": "383. Ransom Note",
      "code": "class Solution {\n  public boolean canConstruct(String ransomNote, String magazine) {\n    int[] count = new int[128];\n\n    for (final char c : magazine.toCharArray())\n      ++count[c];\n\n    for (final char c : ransomNote.toCharArray())\n      if (--count[c] < 0)\n        return false;\n\n    return true;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "384. Shuffle an Array",
      "code": "class Solution {\n  public Solution(int[] nums) {\n    this.nums = nums;\n  } \n\n  /** Resets the array to its original configuration and return it. */\n  public int[] reset() {\n    return nums;\n  } \n\n  /** Returns a random shuffling of the array. */\n  public int[] shuffle() {\n    int[] A = nums.clone();\n    for (int i = A.length - 1; i > 0; --i) {\n      final int j = rand.nextInt(i + 1);\n      swap(A, i, j);\n    }\n    return A;\n  } \n\n  private int[] nums;\n  private Random rand = new Random();\n\n  private void swap(int[] A, int i, int j) {\n    final int temp = A[i];\n    A[i] = A[j];\n    A[j] = temp;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "385. Mini Parser",
      "code": "class Solution {\n  public NestedInteger deserialize(String s) {\n    if (s.charAt(0) != '[')\n      return new NestedInteger(Integer.parseInt(s));\n\n    Deque<NestedInteger> stack = new ArrayDeque<>();\n    int start = 1;\n\n    for (int i = 0; i < s.length(); ++i)\n      switch (s.charAt(i)) {\n        case '[':\n          stack.push(new NestedInteger());\n          start = i + 1;\n          break;\n        case ',':\n          if (i > start) {\n            final int num = Integer.parseInt(s.substring(start, i));\n            stack.peek().add(new NestedInteger(num));\n          }\n          start = i + 1;\n          break;\n        case ']':\n          NestedInteger popped = stack.pop();\n          if (i > start) {\n            final int num = Integer.parseInt(s.substring(start, i));\n            popped.add(new NestedInteger(num));\n          }\n          if (!stack.isEmpty())\n            stack.peek().add(popped);\n          else\n            return popped;\n          start = i + 1;\n          break;\n      } \n\n    throw new IllegalArgumentException();\n  }\n }\n"
    }
  ],
  [
    {
      "id": "386. Lexicographical Numbers",
      "code": "class Solution {\n  public List<Integer> lexicalOrder(int n) {\n    List<Integer> ans = new ArrayList<>();\n    int curr = 1;\n\n    while (ans.size() < n) {\n      ans.add(curr);\n      if (curr * 10 <= n) {\n        curr *= 10;\n      } else {\n        while (curr % 10 == 9 || curr == n)\n          curr /= 10;\n        ++curr;\n      }\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "387. First Unique Character in a String",
      "code": "class Solution {\n  public int firstUniqChar(String s) {\n    int[] count = new int[128];\n\n    for (final char c : s.toCharArray())\n      ++count[c];\n\n    for (int i = 0; i < s.length(); ++i)\n      if (count[s.charAt(i)] == 1)\n        return i;\n\n    return -1;\n  }\n }\n"
    }
  ],
  null,
  [
    {
      "id": "389. Find the Difference",
      "code": "class Solution {\n  public char findTheDifference(String s, String t) {\n    char ans = 0;\n\n    for (final char c : s.toCharArray())\n      ans ^= c;\n\n    for (final char c : t.toCharArray())\n      ans ^= c;\n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "390. Elimination Game",
      "code": "class Solution {\n  public int lastRemaining(int n) {\n    return n == 1 ? 1 : 2 * (1 + n / 2 - lastRemaining(n / 2));\n  }\n }\n"
    }
  ],
  [
    {
      "id": "391. Perfect Rectangle",
      "code": "class Solution {\n  public boolean isRectangleCover(int[][] rectangles) {\n    int area = 0;\n    int x1 = Integer.MAX_VALUE;\n    int y1 = Integer.MAX_VALUE;\n    int x2 = Integer.MIN_VALUE;\n    int y2 = Integer.MIN_VALUE;\n    Set<String> corners = new HashSet<>();\n\n    for (int[] r : rectangles) {\n      area += (r[2] - r[0]) * (r[3] - r[1]);\n      x1 = Math.min(x1, r[0]);\n      y1 = Math.min(y1, r[1]);\n      x2 = Math.max(x2, r[2]);\n      y2 = Math.max(y2, r[3]);\n\n      // Four points of current rectangle\n      String[] points = new String[] {\n        r[0] + \" \" + r[1],\n        r[0] + \" \" + r[3],\n        r[2] + \" \" + r[1],\n        r[2] + \" \" + r[3]\n      };\n      for (final String point : points)\n        if (!corners.add(point))\n          corners.remove(point);\n    } \n\n    if (corners.size() != 4)\n      return false;\n    if (!corners.contains(x1 + \" \" + y1) ||\n        !corners.contains(x1 + \" \" + y2) ||\n        !corners.contains(x2 + \" \" + y1) ||\n        !corners.contains(x2 + \" \" + y2))\n      return false;\n\n    return area == (x2 - x1) * (y2 - y1);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "392. Is Subsequence",
      "code": "class Solution {\n  public boolean isSubsequence(String s, String t) {\n    if (s.isEmpty())\n      return true;\n\n    int i = 0;\n    for (final char c : t.toCharArray())\n      if (s.charAt(i) == c && ++i == s.length())\n        return true;\n\n    return false;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "393. UTF-8 Validation",
      "code": "class Solution {\n  public boolean validUtf8(int[] data) {\n    int leftToCheck = 0;\n\n    for (final int d : data)\n      if (leftToCheck == 0) {\n        if ((d >> 3) == 0b11110)\n          leftToCheck = 3;\n        else if ((d >> 4) == 0b1110)\n          leftToCheck = 2;\n        else if ((d >> 5) == 0b110)\n          leftToCheck = 1;\n        else if ((d >> 7) == 0b0)\n          leftToCheck = 0;\n        else\n          return false;\n      } else {\n        if ((d >> 6) != 0b10)\n          return false;\n        --leftToCheck;\n      } \n\n    return leftToCheck == 0;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "394. Decode String",
      "code": "class Solution {\n  public String decodeString(String s) {\n    Stack<Pair<StringBuilder, Integer>> stack = new Stack<>(); // (prevStr, repeatCount)\n    StringBuilder currStr = new StringBuilder();\n    int currNum = 0;\n\n    for (final char c : s.toCharArray())\n      if (Character.isDigit(c)) {\n        currNum = currNum * 10 + (c - '0');\n      } else {\n        if (c == '[') {\n          stack.push(new Pair<>(currStr, currNum));\n          currStr = new StringBuilder();\n          currNum = 0;\n        } else if (c == ']') {\n          final Pair<StringBuilder, Integer> pair = stack.pop();\n          final StringBuilder prevStr = pair.getKey();\n          final int n = pair.getValue();\n          currStr = prevStr.append(getRepeatedStr(currStr, n));\n        } else {\n          currStr.append(c);\n        }\n      } \n\n    return currStr.toString();\n  } \n\n  // S * n times\n  private StringBuilder getRepeatedStr(StringBuilder s, int n) {\n    StringBuilder sb = new StringBuilder();\n    while (n-- > 0)\n      sb.append(s);\n    return sb;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "395. Longest Substring with At Least K Repeating Characters",
      "code": "class Solution {\n  public int longestSubstring(String s, int k) {\n    int ans = 0;\n\n    for (int n = 1; n <= 26; ++n)\n      ans = Math.max(ans, longestSubstringWithNUniqueCharacters(s, k, n));\n\n    return ans;\n  } \n\n  private int longestSubstringWithNUniqueCharacters(final String s, int k, int n) {\n    int ans = 0;\n    int uniqueChars = 0; // Unique chars in current substring s[l..r]\n    int noLessThanK = 0; // # of chars >= k\n    int[] count = new int[128];\n\n    for (int l = 0, r = 0; r < s.length(); ++r) {\n      if (count[s.charAt(r)] == 0)\n        ++uniqueChars;\n      if (++count[s.charAt(r)] == k)\n        ++noLessThanK;\n      while (uniqueChars > n) {\n        if (count[s.charAt(l)] == k)\n          --noLessThanK;\n        if (--count[s.charAt(l)] == 0)\n          --uniqueChars;\n        ++l;\n      }\n      if (noLessThanK == n) // Unique chars also == n\n        ans = Math.max(ans, r - l + 1);\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "396. Rotate Function",
      "code": "class Solution {\n  public int maxRotateFunction(int[] nums) {\n    final int sum = Arrays.stream(nums).sum();\n    int f = 0;\n\n    // Calculate F(0) first\n    for (int i = 0; i < nums.length; ++i)\n      f += i * nums[i];\n\n    int ans = f;\n\n    for (int i = nums.length - 1; i >= 0; --i) {\n      f += sum - nums.length * nums[i];\n      ans = Math.max(ans, f);\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "397. Integer Replacement",
      "code": "class Solution {\n  public int integerReplacement(long n) {\n    int ans = 0;\n\n    for (; n > 1; ++ans)\n      if ((n & 1) == 0) // Ends w/ 0\n        n >>= 1;\n      else if (n == 3 || ((n >> 1) & 1) == 0) // N = 3 or ends w/ 01\n        --n;\n      else // Ends w/ 11\n        ++n;\n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "398. Random Pick Index",
      "code": "class Solution {\n  public Solution(int[] nums) {\n    this.nums = nums;\n  } \n\n  public int pick(int target) {\n    int ans = -1;\n    int range = 0;\n\n    for (int i = 0; i < nums.length; ++i)\n      if (nums[i] == target && rand.nextInt(++range) == 0)\n        ans = i;\n\n    return ans;\n  } \n\n  private int[] nums;\n  private Random rand = new Random();\n}\n"
    }
  ],
  [
    {
      "id": "399. Evaluate Division",
      "code": "class Solution {\n  public double[] calcEquation(List<List<String>> equations, double[] values,\n                               List<List<String>> queries) {\n    double[] ans = new double[queries.size()];\n    // Graph.get(A).get(B) := A / B\n    Map<String, Map<String, Double>> graph = new HashMap<>();\n\n    // Construct the graph\n    for (int i = 0; i < equations.size(); ++i) {\n      final String A = equations.get(i).get(0);\n      final String B = equations.get(i).get(1);\n      graph.putIfAbsent(A, new HashMap<>());\n      graph.putIfAbsent(B, new HashMap<>());\n      graph.get(A).put(B, values[i]);\n      graph.get(B).put(A, 1.0 / values[i]);\n    } \n\n    for (int i = 0; i < queries.size(); ++i) {\n      final String A = queries.get(i).get(0);\n      final String C = queries.get(i).get(1);\n      if (!graph.containsKey(A) || !graph.containsKey(C))\n        ans[i] = -1.0;\n      else\n        ans[i] = divide(graph, A, C, new HashSet<>());\n    } \n\n    return ans;\n  } \n\n  // Returns A / C\n  private double divide(Map<String, Map<String, Double>> graph, final String A, final String C,\n                        Set<String> seen) {\n    if (A.equals(C))\n      return 1.0;\n\n    seen.add(A);\n\n    for (final String B : graph.get(A).keySet()) {\n      if (seen.contains(B))\n        continue;\n      final double res = divide(graph, B, C, seen); // B / C\n      if (res > 0)                                  // Valid result\n        return graph.get(A).get(B) * res;           // A / C = (A / B) * (B / C)\n    } \n\n    return -1.0; // Invalid result\n  }\n }\n"
    }
  ],
  [
    {
      "id": "400. Nth Digit",
      "code": "class Solution {\n  public int findNthDigit(int n) {\n    int digitSize = 1;\n    int startNum = 1;\n    long count = 9;\n\n    while (digitSize * count < n) {\n      n -= digitSize * count;\n      ++digitSize;\n      startNum *= 10;\n      count *= 10;\n    } \n\n    final int targetNum = startNum + (n - 1) / digitSize;\n    final int index = (n - 1) % digitSize;\n    return String.valueOf(targetNum).charAt(index) - '0';\n  }\n }\n"
    }
  ],
  [
    {
      "id": "401. Binary Watch",
      "code": "class Solution {\n  public List<String> readBinaryWatch(int num) {\n    List<String> ans = new ArrayList<>();\n    dfs(num, 0, 0, 0, ans);\n    return ans;\n  } \n\n  private int[] hours = new int[] {1, 2, 4, 8};\n  private int[] minutes = new int[] {1, 2, 4, 8, 16, 32};\n\n  private void dfs(int n, int s, int h, int m, List<String> ans) {\n    if (n == 0) {\n      final String time = String.valueOf(h) + \":\" + (m < 10 ? \"0\" : \"\") + String.valueOf(m);\n      ans.add(time);\n      return;\n    } \n\n    for (int i = s; i < hours.length + minutes.length; ++i)\n      if (i < 4 && h + hours[i] < 12)\n        dfs(n - 1, i + 1, h + hours[i], m, ans);\n      else if (i >= 4 && m + minutes[i - 4] < 60)\n        dfs(n - 1, i + 1, h, m + minutes[i - 4], ans);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "402. Remove K Digits",
      "code": "class Solution {\n  public String removeKdigits(String num, int k) {\n    if (num.length() == k)\n      return \"0\";\n\n    StringBuilder sb = new StringBuilder();\n    LinkedList<Character> stack = new LinkedList<>();\n\n    for (int i = 0; i < num.length(); ++i) {\n      while (k > 0 && !stack.isEmpty() && stack.getLast() > num.charAt(i)) {\n        stack.pollLast();\n        --k;\n      }\n      stack.addLast(num.charAt(i));\n    } \n\n    while (k-- > 0)\n      stack.pollLast();\n\n    for (final char c : stack) {\n      if (c == '0' && sb.length() == 0)\n        continue;\n      sb.append(c);\n    } \n\n    return sb.length() == 0 ? \"0\" : sb.toString();\n  }\n }\n"
    }
  ],
  [
    {
      "id": "403. Frog Jump",
      "code": "class Solution {\n  public boolean canCross(int[] stones) {\n    final int n = stones.length;\n    // dp[i][j] := 1 if a frog can make a size j jump to stones[i]\n    int[][] dp = new int[n][n + 1];\n    dp[0][0] = 1;\n\n    for (int i = 1; i < n; ++i)\n      for (int j = 0; j < i; ++j) {\n        final int k = stones[i] - stones[j];\n        if (k > n)\n          continue;\n        for (final int x : new int[] {k - 1, k, k + 1})\n          if (0 <= x && x <= n)\n            dp[i][k] |= dp[j][x];\n      } \n\n    return Arrays.stream(dp[n - 1]).anyMatch(a -> a == 1);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "404. Sum of Left Leaves",
      "code": "class Solution {\n  public int sumOfLeftLeaves(TreeNode root) {\n    if (root == null)\n      return 0;\n\n    int ans = 0;\n\n    if (root.left != null) {\n      if (root.left.left == null && root.left.right == null)\n        ans += root.left.val;\n      else\n        ans += sumOfLeftLeaves(root.left);\n    }\n    ans += sumOfLeftLeaves(root.right);\n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "405. Convert a Number to Hexadecimal",
      "code": "class Solution {\n  public String toHex(int num) {\n    final char[] hex = {'0', '1', '2', '3', '4', '5', '6', '7',\n                        '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\n    StringBuilder sb = new StringBuilder();\n\n    while (num != 0) {\n      sb.append(hex[num & 0xf]);\n      num >>>= 4;\n    } \n\n    return sb.length() == 0 ? \"0\" : sb.reverse().toString();\n  }\n }\n"
    }
  ],
  [
    {
      "id": "406. Queue Reconstruction by Height",
      "code": "class Solution {\n  public int[][] reconstructQueue(int[][] people) {\n    List<int[]> ans = new ArrayList<>();\n\n    Arrays.sort(people, (a, b) -> a[0] == b[0] ? a[1] - b[1] : b[0] - a[0]);\n\n    for (final int[] p : people)\n      ans.add(p[1], p);\n\n    return ans.stream().toArray(int[][] ::new);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "407. Trapping Rain Water II",
      "code": "class T {\n  public int i;\n  public int j;\n  public int h; // heightMap[i][j] or the height after filling water\n  public T(int i, int j, int h) {\n    this.i = i;\n    this.j = j;\n    this.h = h;\n  }\n } \n\n class Solution {\n  public int trapRainWater(int[][] heightMap) {\n    final int m = heightMap.length;\n    final int n = heightMap[0].length;\n    final int[] dirs = {0, 1, 0, -1, 0};\n    int ans = 0;\n    Queue<T> minHeap = new PriorityQueue<>((a, b) -> a.h - b.h);\n    boolean[][] seen = new boolean[m][n];\n\n    for (int i = 0; i < m; ++i) {\n      minHeap.offer(new T(i, 0, heightMap[i][0]));\n      minHeap.offer(new T(i, n - 1, heightMap[i][n - 1]));\n      seen[i][0] = true;\n      seen[i][n - 1] = true;\n    } \n\n    for (int j = 1; j < n - 1; ++j) {\n      minHeap.offer(new T(0, j, heightMap[0][j]));\n      minHeap.offer(new T(m - 1, j, heightMap[m - 1][j]));\n      seen[0][j] = true;\n      seen[m - 1][j] = true;\n    } \n\n    while (!minHeap.isEmpty()) {\n      final int i = minHeap.peek().i;\n      final int j = minHeap.peek().j;\n      final int h = minHeap.poll().h;\n      for (int k = 0; k < 4; ++k) {\n        final int x = i + dirs[k];\n        final int y = j + dirs[k + 1];\n        if (x < 0 || x == m || y < 0 || y == n)\n          continue;\n        if (seen[x][y])\n          continue;\n        if (heightMap[x][y] < h) {\n          ans += h - heightMap[x][y];\n          minHeap.offer(new T(x, y, h)); // Fill the water on grid[x][y]\n        } else {\n          minHeap.offer(new T(x, y, heightMap[x][y]));\n        }\n        seen[x][y] = true;\n      }\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "408. Valid Word Abbreviation",
      "code": "class Solution {\n  public boolean validWordAbbreviation(String word, String abbr) {\n    int i = 0; // word's index\n    int j = 0; // abbr's index\n\n    while (i < word.length() && j < abbr.length()) {\n      if (word.charAt(i) == abbr.charAt(j)) {\n        ++i;\n        ++j;\n        continue;\n      }\n      if (abbr.charAt(j) <= '0' || abbr.charAt(j) > '9')\n        return false;\n      int num = 0;\n      while (j < abbr.length() && Character.isDigit(abbr.charAt(j))) {\n        num = num * 10 + abbr.charAt(j) - '0';\n        ++j;\n      }\n      i += num;\n    } \n\n    return i == word.length() && j == abbr.length();\n  }\n }\n"
    }
  ],
  [
    {
      "id": "409. Longest Palindrome",
      "code": "class Solution {\n  public int longestPalindrome(String s) {\n    int ans = 0;\n    int[] count = new int[128];\n\n    for (final char c : s.toCharArray())\n      ++count[c];\n\n    for (final int c : count)\n      ans += c % 2 == 0 ? c : c - 1;\n\n    final boolean hasOddCount = Arrays.stream(count).anyMatch(c -> c % 2 == 1);\n\n    return ans + (hasOddCount ? 1 : 0);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "410. Split Array Largest Sum",
      "code": "class Solution {\n  public int splitArray(int[] nums, int m) {\n    final int n = nums.length;\n    // dp[i][k] := min of largest sum to split first i nums into k groups\n    dp = new int[n + 1][m + 1];\n    prefix = new int[n + 1];\n\n    Arrays.stream(dp).forEach(A -> Arrays.fill(A, Integer.MAX_VALUE));\n\n    for (int i = 0; i < n; ++i)\n      prefix[i + 1] = nums[i] + prefix[i];\n\n    return splitArray(nums, n, m);\n  } \n\n  private int[][] dp;\n  private int[] prefix;\n\n  private int splitArray(int[] nums, int i, int k) {\n    if (k == 1)\n      return prefix[i];\n    if (dp[i][k] < Integer.MAX_VALUE)\n      return dp[i][k];\n\n    // Try all possible partitions\n    for (int j = k - 1; j < i; ++j)\n      dp[i][k] = Math.min(dp[i][k], Math.max(splitArray(nums, j, k - 1), prefix[i] - prefix[j]));\n\n    return dp[i][k];\n  }\n }\n"
    }
  ],
  [
    {
      "id": "411. Minimum Unique Word Abbreviation",
      "code": "class Solution {\n  public String minAbbreviation(String target, String[] dictionary) {\n    final int m = target.length();\n    List<Integer> masks = new ArrayList<>();\n\n    for (final String word : dictionary) {\n      if (word.length() != m)\n        continue;\n      masks.add(getMask(target, word));\n    } \n\n    if (masks.isEmpty())\n      return String.valueOf(m);\n\n    List<String> abbrs = new ArrayList<>();\n\n    final int maxCand = (int) Math.pow(2, m);\n    // For all candidate representation of target\n    for (int i = 0; i < maxCand; ++i) {\n      final int cand = i;\n      // All masks have at lease one bit different from candidate\n      if (masks.stream().allMatch(mask -> (cand & mask) > 0))\n        abbrs.add(getAbbr(target, cand));\n    } \n\n    String ans = target;\n\n    for (final String abbr : abbrs)\n      if (getAbbrLen(abbr) < getAbbrLen(ans))\n        ans = abbr;\n\n    return ans;\n  } \n\n  private int getMask(final String target, final String word) {\n    final int m = target.length();\n    // mask[i] = 0 := target[i] == word[i]\n    // mask[i] = 1 := target[i] != word[i]\n    // E.g. target = \"apple\"\n    //        word = \"blade\"\n    //        mask =  11110\n    int mask = 0;\n    for (int i = 0; i < m; ++i)\n      if (word.charAt(i) != target.charAt(i))\n        mask |= 1 << m - 1 - i;\n    return mask;\n  } \n\n  String getAbbr(final String target, int cand) {\n    final int m = target.length();\n    StringBuilder sb = new StringBuilder();\n    int replacedCount = 0;\n    for (int i = 0; i < m; ++i)\n      if ((cand >> m - 1 - i & 1) == 1) {\n        // cand[i] = 1, abbr should show the original character\n        if (replacedCount > 0)\n          sb.append(replacedCount);\n        sb.append(target.charAt(i));\n        replacedCount = 0;\n      } else {\n        // cand[i] = 0, abbr can be replaced\n        ++replacedCount;\n      }\n    if (replacedCount > 0)\n      sb.append(replacedCount);\n    return sb.toString();\n  } \n\n  int getAbbrLen(final String abbr) {\n    int abbrLen = 0;\n    int i = 0;\n    int j = 0;\n    while (i < abbr.length()) {\n      if (Character.isAlphabetic(abbr.charAt(j)))\n        ++j;\n      else\n        while (j < abbr.length() && Character.isDigit(abbr.charAt(j)))\n          ++j;\n      ++abbrLen;\n      i = j;\n    }\n    return abbrLen;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "412. Fizz Buzz",
      "code": "class Solution {\n  public List<String> fizzBuzz(int n) {\n    List<String> ans = new ArrayList<>();\n\n    for (int i = 1; i <= n; ++i) {\n      StringBuilder sb = new StringBuilder();\n      if (i % 3 == 0)\n        sb.append(\"Fizz\");\n      if (i % 5 == 0)\n        sb.append(\"Buzz\");\n      ans.add(sb.length() == 0 ? String.valueOf(i) : sb.toString());\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "413. Arithmetic Slices",
      "code": "class Solution {\n  public int numberOfArithmeticSlices(int[] nums) {\n    final int n = nums.length;\n    if (n < 3)\n      return 0;\n\n    int[] dp = new int[n]; // dp[i] := # of arithmetic slices ends at nums[i]\n\n    for (int i = 2; i < n; ++i)\n      if (nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2])\n        dp[i] += dp[i - 1] + 1;\n\n    return Arrays.stream(dp).sum();\n  }\n }\n"
    }
  ],
  [
    {
      "id": "414. Third Maximum Number",
      "code": "public class Solution {\n  public int thirdMax(int[] nums) {\n    long max1 = Long.MIN_VALUE; // The maximum\n    long max2 = Long.MIN_VALUE; // 2nd maximum\n    long max3 = Long.MIN_VALUE; // 3rd maximum\n\n    for (final int num : nums)\n      if (num > max1) {\n        max3 = max2;\n        max2 = max1;\n        max1 = num;\n      } else if (max1 > num && num > max2) {\n        max3 = max2;\n        max2 = num;\n      } else if (max2 > num && num > max3) {\n        max3 = num;\n      } \n\n    return max3 == Long.MIN_VALUE ? (int) max1 : (int) max3;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "415. Add Strings",
      "code": "class Solution {\n  public String addStrings(String num1, String num2) {\n    StringBuilder sb = new StringBuilder();\n    int carry = 0;\n    int i = num1.length() - 1;\n    int j = num2.length() - 1;\n\n    while (i >= 0 || j >= 0 || carry > 0) {\n      if (i >= 0)\n        carry += num1.charAt(i--) - '0';\n      if (j >= 0)\n        carry += num2.charAt(j--) - '0';\n      sb.append(carry % 10);\n      carry /= 10;\n    } \n\n    return sb.reverse().toString();\n  }\n }\n"
    }
  ],
  [
    {
      "id": "416. Partition Equal Subset Sum",
      "code": "class Solution {\n  public boolean canPartition(int[] nums) {\n    final int sum = Arrays.stream(nums).sum();\n    if (sum % 2 == 1)\n      return false;\n    return knapsack(nums, sum / 2);\n  } \n\n  private boolean knapsack(int[] nums, int subsetSum) {\n    final int n = nums.length;\n    // dp[i][j] := true if j can be formed by nums[0..i)\n    boolean[][] dp = new boolean[n + 1][subsetSum + 1];\n    dp[0][0] = true;\n\n    for (int i = 1; i <= n; ++i) {\n      final int num = nums[i - 1];\n      for (int j = 0; j <= subsetSum; ++j)\n        if (j < num)\n          dp[i][j] = dp[i - 1][j];\n        else\n          dp[i][j] = dp[i - 1][j] || dp[i - 1][j - num];\n    } \n\n    return dp[n][subsetSum];\n  }\n }\n"
    }
  ],
  [
    {
      "id": "417. Pacific Atlantic Water Flow",
      "code": "class Solution {\n  public List<List<Integer>> pacificAtlantic(int[][] heights) {\n    final int m = heights.length;\n    final int n = heights[0].length;\n    List<List<Integer>> ans = new ArrayList<>();\n    Queue<int[]> qP = new ArrayDeque<>();\n    Queue<int[]> qA = new ArrayDeque<>();\n    boolean[][] seenP = new boolean[m][n];\n    boolean[][] seenA = new boolean[m][n];\n\n    for (int i = 0; i < m; ++i) {\n      qP.offer(new int[] {i, 0});\n      qA.offer(new int[] {i, n - 1});\n      seenP[i][0] = true;\n      seenA[i][n - 1] = true;\n    } \n\n    for (int j = 0; j < n; ++j) {\n      qP.offer(new int[] {0, j});\n      qA.offer(new int[] {m - 1, j});\n      seenP[0][j] = true;\n      seenA[m - 1][j] = true;\n    } \n\n    bfs(heights, qP, seenP);\n    bfs(heights, qA, seenA);\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (seenP[i][j] && seenA[i][j])\n          ans.add(new ArrayList<>(Arrays.asList(i, j)));\n\n    return ans;\n  } \n\n  private static final int[] dirs = {0, 1, 0, -1, 0};\n\n  private void bfs(int[][] heights, Queue<int[]> q, boolean[][] seen) {\n    while (!q.isEmpty()) {\n      final int i = q.peek()[0];\n      final int j = q.poll()[1];\n      final int h = heights[i][j];\n      for (int k = 0; k < 4; ++k) {\n        final int x = i + dirs[k];\n        final int y = j + dirs[k + 1];\n        if (x < 0 || x == heights.length || y < 0 || y == heights[0].length)\n          continue;\n        if (seen[x][y] || heights[x][y] < h)\n          continue;\n        q.offer(new int[] {x, y});\n        seen[x][y] = true;\n      }\n    }\n  }\n }\n"
    }
  ],
  [
    {
      "id": "418. Sentence Screen Fitting",
      "code": "class Solution {\n  public int wordsTyping(String[] sentence, int rows, int cols) {\n    final String combined = String.join(\" \", sentence) + \" \";\n    final int n = combined.length();\n    int i = 0; // (i % n) points to the index of combined in each row\n\n    while (rows-- > 0) {\n      i += cols;\n      if (combined.charAt(i % n) == ' ') {\n        ++i;\n      } else {\n        while (i > 0 && combined.charAt((i - 1) % n) != ' ')\n          --i;\n      }\n    } \n\n    return i / n;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "419. Battleships in a Board",
      "code": "class Solution {\n  public int countBattleships(char[][] board) {\n    int ans = 0;\n\n    for (int i = 0; i < board.length; ++i)\n      for (int j = 0; j < board[0].length; ++j) {\n        if (board[i][j] == '.')\n          continue;\n        if (i > 0 && board[i - 1][j] == 'X')\n          continue;\n        if (j > 0 && board[i][j - 1] == 'X')\n          continue;\n        ++ans;\n      } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "420. Strong Password Checker",
      "code": "class Solution {\n  public int strongPasswordChecker(String s) {\n    final int n = s.length();\n    final char[] chars = s.toCharArray();\n    final int missing = getMissing(chars);\n    // # of replacements to deal with 3 repeating characters\n    int replaces = 0;\n    // # of seqs that can be substituted with 1 deletions, (3k)-seqs\n    int oneSeq = 0;\n    // # of seqs that can be substituted with 2 deletions, (3k + 1)-seqs\n    int twoSeq = 0;\n\n    for (int i = 2; i < n;)\n      if (chars[i] == chars[i - 1] && chars[i - 1] == chars[i - 2]) {\n        int length = 2; // Length of repeating chars\n        while (i < n && chars[i] == chars[i - 1]) {\n          ++length;\n          ++i;\n        }\n        replaces += length / 3; // 'aaaaaaa' -> 'aaxaaxa'\n        if (length % 3 == 0)\n          ++oneSeq;\n        if (length % 3 == 1)\n          ++twoSeq;\n      } else {\n        ++i;\n      } \n\n    if (n < 6)\n      return Math.max(6 - n, missing);\n    if (n <= 20)\n      return Math.max(replaces, missing);\n\n    final int deletes = n - 20;\n    // Each replacement in (3k)-seqs can be substituted with 1 deletions\n    replaces -= Math.min(oneSeq, deletes);\n    // Each replacement in (3k + 1)-seqs can be substituted with 2 deletions\n    replaces -= Math.min(Math.max(deletes - oneSeq, 0), twoSeq * 2) / 2;\n    // Each replacement in other seqs can be substituted with 3 deletions\n    replaces -= Math.max(deletes - oneSeq - twoSeq * 2, 0) / 3;\n    return deletes + Math.max(replaces, missing);\n  } \n\n  private int getMissing(final char[] chars) {\n    int missing = 3;\n\n    for (final char c : chars)\n      if (Character.isUpperCase(c)) {\n        --missing;\n        break;\n      } \n\n    for (final char c : chars)\n      if (Character.isLowerCase(c)) {\n        --missing;\n        break;\n      } \n\n    for (final char c : chars)\n      if (Character.isDigit(c)) {\n        --missing;\n        break;\n      } \n\n    return missing;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "421. Maximum XOR of Two Numbers in an Array",
      "code": "class Solution {\n  public int findMaximumXOR(int[] nums) {\n    final int maxNum = Arrays.stream(nums).max().getAsInt();\n    if (maxNum == 0)\n      return 0;\n    final int maxBit = (int) (Math.log(maxNum) / Math.log(2));\n    int ans = 0;\n    int mask = 0;\n\n    // If ans is 11100 when i = 2, it means that before we reach the last two\n    // bits, 11100 is the maximum XOR we have, and we're going to explore if we\n    // can get another two '1's and put them into ans.\n    for (int i = maxBit; i >= 0; --i) {\n      // Mask grows like: 100...000, 110...000, 111...000, ..., 111...111.\n      mask |= 1 << i;\n      Set<Integer> prefixes = new HashSet<>();\n      // We only care about the left parts,\n      // If i = 2, nums = {1110, 1011, 0111}\n      //    . prefixes = {1100, 1000, 0100}\n      for (final int num : nums)\n        prefixes.add(num & mask);\n      // If i = 1 and before this iteration, the ans is 10100, it means that we\n      // want to grow the ans to 10100 | 1 << 1 = 10110 and we're looking for\n      // XOR of two prefixes = candidate.\n      final int candidate = ans | 1 << i;\n      for (final int prefix : prefixes)\n        if (prefixes.contains(prefix ^ candidate)) {\n          ans = candidate;\n          break;\n        }\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "422. Valid Word Square",
      "code": "class Solution {\n  public boolean validWordSquare(List<String> words) {\n    for (int i = 0; i < words.size(); ++i)\n      for (int j = 0; j < words.get(i).length(); ++j) {\n        if (words.size() <= j || words.get(j).length() <= i) // Out of bound\n          return false;\n        if (words.get(i).charAt(j) != words.get(j).charAt(i))\n          return false;\n      } \n\n    return true;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "423. Reconstruct Original Digits from English",
      "code": "class Solution {\n  public String originalDigits(String s) {\n    StringBuilder sb = new StringBuilder();\n    int[] count = new int[10];\n\n    for (final char c : s.toCharArray()) {\n      if (c == 'z')\n        ++count[0];\n      if (c == 'o')\n        ++count[1];\n      if (c == 'w')\n        ++count[2];\n      if (c == 'h')\n        ++count[3];\n      if (c == 'u')\n        ++count[4];\n      if (c == 'f')\n        ++count[5];\n      if (c == 'x')\n        ++count[6];\n      if (c == 's')\n        ++count[7];\n      if (c == 'g')\n        ++count[8];\n      if (c == 'i')\n        ++count[9];\n    } \n\n    count[1] -= count[0] + count[2] + count[4];\n    count[3] -= count[8];\n    count[5] -= count[4];\n    count[7] -= count[6];\n    count[9] -= count[5] + count[6] + count[8];\n\n    for (int i = 0; i < 10; ++i)\n      for (int j = 0; j < count[i]; ++j)\n        sb.append(i);\n\n    return sb.toString();\n  }\n }\n"
    }
  ],
  [
    {
      "id": "424. Longest Repeating Character Replacement",
      "code": "class Solution {\n  public int characterReplacement(String s, int k) {\n    int ans = 0;\n    int maxCount = 0;\n    int[] count = new int[128];\n\n    for (int l = 0, r = 0; r < s.length(); ++r) {\n      maxCount = Math.max(maxCount, ++count[s.charAt(r)]);\n      while (maxCount + k < r - l + 1)\n        --count[s.charAt(l++)];\n      ans = Math.max(ans, r - l + 1);\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "425. Word Squares",
      "code": "class TrieNode {\n  public TrieNode[] children = new TrieNode[26];\n  public List<String> startsWith = new ArrayList<>();\n} \n\n class Trie {\n  public Trie(final String[] words) {\n    for (final String word : words)\n      insert(word);\n  } \n\n  public List<String> findBy(final String prefix) {\n    TrieNode node = root;\n    for (final char c : prefix.toCharArray()) {\n      final int i = c - 'a';\n      if (node.children[i] == null)\n        return new ArrayList<>();\n      node = node.children[i];\n    }\n    return node.startsWith;\n  } \n\n  private TrieNode root = new TrieNode();\n\n  private void insert(final String word) {\n    TrieNode node = root;\n    for (final char c : word.toCharArray()) {\n      final int i = c - 'a';\n      if (node.children[i] == null)\n        node.children[i] = new TrieNode();\n      node = node.children[i];\n      node.startsWith.add(word);\n    }\n  }\n } \n\n class Solution {\n  public List<List<String>> wordSquares(String[] words) {\n    if (words.length == 0)\n      return new ArrayList<>();\n\n    final int n = words[0].length();\n    List<List<String>> ans = new ArrayList<>();\n    List<String> path = new ArrayList<>();\n    Trie trie = new Trie(words);\n\n    for (final String word : words) {\n      path.add(word);\n      dfs(trie, n, path, ans);\n      path.remove(path.size() - 1);\n    } \n\n    return ans;\n  } \n\n  private void dfs(Trie trie, final int n, List<String> path, List<List<String>> ans) {\n    if (path.size() == n) {\n      ans.add(new ArrayList<>(path));\n      return;\n    } \n\n    final String prefix = getPrefix(path);\n\n    for (final String s : trie.findBy(prefix)) {\n      path.add(s);\n      dfs(trie, n, path, ans);\n      path.remove(path.size() - 1);\n    }\n  } \n\n  // E.g. path = [\"wall\",\n  //              \"area\"]\n  //    prefix =  \"le..\"\n  private String getPrefix(List<String> path) {\n    StringBuilder sb = new StringBuilder();\n    final int index = path.size();\n    for (final String s : path)\n      sb.append(s.charAt(index));\n    return sb.toString();\n  }\n }\n"
    }
  ],
  [
    {
      "id": "426. Convert Binary Search Tree to Sorted Doubly Linked List",
      "code": "class Solution {\n  public Node treeToDoublyList(Node root) {\n    if (root == null)\n      return null;\n\n    Node leftHead = treeToDoublyList(root.left);\n    Node rightHead = treeToDoublyList(root.right);\n    root.left = root;\n    root.right = root;\n    return connect(connect(leftHead, root), rightHead);\n  } \n\n  private Node connect(Node node1, Node node2) {\n    if (node1 == null)\n      return node2;\n    if (node2 == null)\n      return node1;\n\n    Node tail1 = node1.left;\n    Node tail2 = node2.left;\n\n    // Connect node1's tail with node2\n    tail1.right = node2;\n    node2.left = tail1;\n\n    // Connect node2's tail with node1\n    tail2.right = node1;\n    node1.left = tail2;\n    return node1;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "427. Construct Quad Tree",
      "code": "class Solution {\n  public Node construct(int[][] grid) {\n    return helper(grid, 0, 0, grid.length);\n  } \n\n  private Node helper(int[][] grid, int i, int j, int w) {\n    if (allSame(grid, i, j, w))\n      return new Node(grid[i][j] == 1 ? true : false, true);\n\n    Node node = new Node(true, false);\n    node.topLeft = helper(grid, i, j, w / 2);\n    node.topRight = helper(grid, i, j + w / 2, w / 2);\n    node.bottomLeft = helper(grid, i + w / 2, j, w / 2);\n    node.bottomRight = helper(grid, i + w / 2, j + w / 2, w / 2);\n    return node;\n  } \n\n  private boolean allSame(int[][] grid, int i, int j, int w) {\n    for (int x = i; x < i + w; ++x)\n      for (int y = j; y < j + w; ++y)\n        if (grid[x][y] != grid[i][j])\n          return false;\n    return true;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "428. Serialize and Deserialize N-ary Tree",
      "code": "class Codec {\n  // Encodes a tree to a single string.\n  public String serialize(Node root) {\n    if (root == null)\n      return \"\";\n\n    StringBuilder sb = new StringBuilder().append(root.val).append(\",\");\n    Queue<Node> q = new ArrayDeque<>(Arrays.asList(root));\n\n    while (!q.isEmpty())\n      for (int sz = q.size(); sz > 0; --sz) {\n        Node node = q.poll();\n        if (node.children.isEmpty()) {\n          sb.append(\"n\");\n        } else {\n          for (Node child : node.children) {\n            q.offer(child);\n            sb.append(child.val).append(\"#\");\n          }\n        }\n        sb.append(\",\");\n      } \n\n    return sb.toString();\n  } \n\n  // Decodes your encoded data to tree.\n  public Node deserialize(String data) {\n    if (data.equals(\"\"))\n      return null;\n\n    final String[] vals = data.split(\",\");\n    Node root = new Node(Integer.parseInt(vals[0]));\n    Queue<Node> q = new ArrayDeque<>(Arrays.asList(root));\n\n    for (int i = 1; i < vals.length; ++i) {\n      Node parent = q.poll();\n      final String[] kids = vals[i].split(\"#\");\n      List<Node> children = new ArrayList<>();\n      for (final String kid : kids) {\n        if (kid.equals(\"n\"))\n          continue;\n        Node child = new Node(Integer.parseInt(kid));\n        children.add(child);\n        q.offer(child);\n      }\n      parent.children = children;\n    } \n\n    return root;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "429. N-ary Tree Level Order Traversal",
      "code": "class Solution {\n  public List<List<Integer>> levelOrder(Node root) {\n    if (root == null)\n      return new ArrayList<>();\n\n    List<List<Integer>> ans = new ArrayList<>();\n    Queue<Node> q = new ArrayDeque<>(Arrays.asList(root));\n\n    while (!q.isEmpty()) {\n      List<Integer> currLevel = new ArrayList<>();\n      for (int sz = q.size(); sz > 0; --sz) {\n        Node node = q.poll();\n        currLevel.add(node.val);\n        for (Node child : node.children)\n          q.offer(child);\n      }\n      ans.add(currLevel);\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "430. Flatten a Multilevel Doubly Linked List",
      "code": "class Solution {\n  public Node flatten(Node head) {\n    return flatten(head, null);\n  } \n\n  private Node flatten(Node head, Node rest) {\n    if (head == null)\n      return rest;\n\n    head.next = flatten(head.child, flatten(head.next, rest));\n    if (head.next != null)\n      head.next.prev = head;\n    head.child = null;\n    return head;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "431. Encode N-ary Tree to Binary Tree",
      "code": "class Codec {\n  // Encodes an n-ary tree to a binary tree.\n  public TreeNode encode(Node root) {\n    if (root == null)\n      return null;\n\n    TreeNode rootTreeNode = new TreeNode(root.val);\n    Queue<Pair<Node, TreeNode>> q = new ArrayDeque<>(Arrays.asList(new Pair<>(root, rootTreeNode)));\n\n    while (!q.isEmpty()) {\n      Node parentNode = q.peek().getKey();\n      TreeNode parentTreeNode = q.poll().getValue();\n      TreeNode prevTreeNode = null;\n      TreeNode headTreeNode = null;\n      for (Node child : parentNode.children) {\n        TreeNode currTreeNode = new TreeNode(child.val);\n        if (prevTreeNode == null)\n          headTreeNode = currTreeNode;\n        else\n          prevTreeNode.right = currTreeNode;\n        prevTreeNode = currTreeNode;\n        q.offer(new Pair<>(child, currTreeNode));\n      }\n      parentTreeNode.left = headTreeNode;\n    } \n\n    return rootTreeNode;\n  } \n\n  // Decodes your binary tree to an n-ary tree.\n  public Node decode(TreeNode root) {\n    if (root == null)\n      return null;\n\n    Node rootNode = new Node(root.val, new ArrayList<>());\n    Queue<Pair<Node, TreeNode>> q = new ArrayDeque<>(Arrays.asList(new Pair<>(rootNode, root)));\n\n    while (!q.isEmpty()) {\n      Node parentNode = q.peek().getKey();\n      TreeNode parentTreeNode = q.poll().getValue();\n      TreeNode sibling = parentTreeNode.left;\n      while (sibling != null) {\n        Node currNode = new Node(sibling.val, new ArrayList<>());\n        parentNode.children.add(currNode);\n        q.offer(new Pair<>(currNode, sibling));\n        sibling = sibling.right;\n      }\n    } \n\n    return rootNode;\n  }\n }\n"
    }
  ],
  null,
  [
    {
      "id": "433. Minimum Genetic Mutation",
      "code": "class Solution {\n  public int minMutation(String start, String end, String[] bank) {\n    Set<String> bankSet = new HashSet<>(Arrays.asList(bank));\n    if (!bankSet.contains(end))\n      return -1;\n\n    int ans = 0;\n    Queue<String> q = new ArrayDeque<>(Arrays.asList(start));\n\n    while (!q.isEmpty()) {\n      ++ans;\n      for (int sz = q.size(); sz > 0; --sz) {\n        StringBuilder sb = new StringBuilder(q.poll());\n        for (int j = 0; j < sb.length(); ++j) {\n          final char cache = sb.charAt(j);\n          for (final char c : new char[] {'A', 'C', 'G', 'T'}) {\n            sb.setCharAt(j, c);\n            final String word = sb.toString();\n            if (word.equals(end))\n              return ans;\n            if (bankSet.contains(word)) {\n              bankSet.remove(word);\n              q.offer(word);\n            }\n          }\n          sb.setCharAt(j, cache);\n        }\n      }\n    } \n\n    return -1;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "434. Number of Segments in a String",
      "code": "class Solution {\n  public int countSegments(String s) {\n    int ans = 0;\n\n    for (int i = 0; i < s.length(); ++i)\n      if (s.charAt(i) != ' ' && (i == 0 || s.charAt(i - 1) == ' '))\n        ++ans;\n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "435. Non-overlapping Intervals",
      "code": "class Solution {\n  public int eraseOverlapIntervals(int[][] intervals) {\n    if (intervals.length == 0)\n      return 0;\n\n    Arrays.sort(intervals, (a, b) -> a[1] - b[1]);\n\n    int ans = 0;\n    int currentEnd = intervals[0][1];\n\n    for (int i = 1; i < intervals.length; ++i)\n      if (intervals[i][0] >= currentEnd)\n        currentEnd = intervals[i][1];\n      else\n        ++ans;\n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "436. Find Right Interval",
      "code": "class Solution {\n  public int[] findRightInterval(int[][] intervals) {\n    final int n = intervals.length;\n\n    int[] ans = new int[n];\n    java.util.NavigableMap<Integer, Integer> startToIndex = new TreeMap<>();\n\n    for (int i = 0; i < n; ++i)\n      startToIndex.put(intervals[i][0], i);\n\n    for (int i = 0; i < n; ++i) {\n      Map.Entry<Integer, Integer> entry = startToIndex.ceilingEntry(intervals[i][1]);\n      if (entry == null)\n        ans[i] = -1;\n      else\n        ans[i] = entry.getValue();\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "437. Path Sum III",
      "code": "class Solution {\n  public int pathSum(TreeNode root, int sum) {\n    if (root == null)\n      return 0;\n    return dfs(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);\n  } \n\n  private int dfs(TreeNode root, int sum) {\n    if (root == null)\n      return 0;\n    return (sum == root.val ? 1 : 0) +\n        dfs(root.left, sum - root.val) +\n        dfs(root.right, sum - root.val);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "438. Find All Anagrams in a String",
      "code": "class Solution {\n  public List<Integer> findAnagrams(String s, String p) {\n    List<Integer> ans = new ArrayList<>();\n    int[] count = new int[128];\n    int required = p.length();\n\n    for (final char c : p.toCharArray())\n      ++count[c];\n\n    for (int l = 0, r = 0; r < s.length(); ++r) {\n      if (--count[s.charAt(r)] >= 0)\n        --required;\n      while (required == 0) {\n        if (r - l + 1 == p.length())\n          ans.add(l);\n        if (++count[s.charAt(l++)] > 0)\n          ++required;\n      }\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "439. Ternary Expression Parser",
      "code": "class Solution {\n  public String parseTernary(String expression) {\n    final char c = expression.charAt(i);\n\n    if (i + 1 == expression.length() || expression.charAt(i + 1) == ':') {\n      i += 2; // Skip ':'\n      return String.valueOf(c);\n    } \n\n    i += 2; // Skip '?'\n    final String first = parseTernary(expression);\n    final String second = parseTernary(expression);\n    return c == 'T' ? first : second;\n  } \n\n  private int i = 0;\n}\n"
    }
  ],
  [
    {
      "id": "440. K-th Smallest in Lexicographical Order",
      "code": "class Solution {\n  public int findKthNumber(int n, int k) {\n    long currNum = 1;\n\n    for (int i = 1; i < k;) {\n      long gap = getGap(currNum, currNum + 1, n);\n      if (i + gap <= k) {\n        i += gap;\n        ++currNum;\n      } else {\n        ++i;\n        currNum *= 10;\n      }\n    } \n\n    return (int) currNum;\n  } \n\n  private long getGap(long a, long b, long n) {\n    long gap = 0;\n    while (a <= n) {\n      gap += Math.min(n + 1, b) - a;\n      a *= 10;\n      b *= 10;\n    }\n    return gap;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "441. Arranging Coins",
      "code": "class Solution {\n  public int arrangeCoins(long n) {\n    return (int) (-1 + Math.sqrt(8 * n + 1)) / 2;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "442. Find All Duplicates in an Array",
      "code": "class Solution {\n  public List<Integer> findDuplicates(int[] nums) {\n    List<Integer> ans = new ArrayList<>();\n\n    for (final int num : nums) {\n      nums[Math.abs(num) - 1] *= -1;\n      if (nums[Math.abs(num) - 1] > 0)\n        ans.add(Math.abs(num));\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "443. String Compression",
      "code": "class Solution {\n  public int compress(char[] chars) {\n    int ans = 0;\n\n    for (int i = 0; i < chars.length;) {\n      final char letter = chars[i];\n      int count = 0;\n      while (i < chars.length && chars[i] == letter) {\n        ++count;\n        ++i;\n      }\n      chars[ans++] = letter;\n      if (count > 1)\n        for (final char c : String.valueOf(count).toCharArray())\n          chars[ans++] = c;\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "444. Sequence Reconstruction",
      "code": "class Solution {\n  public boolean sequenceReconstruction(int[] org, List<List<Integer>> seqs) {\n    if (seqs.isEmpty())\n      return false;\n\n    final int n = org.length;\n    List<Integer>[] graph = new List[n];\n    int[] inDegree = new int[n];\n\n    for (int i = 0; i < n; ++i)\n      graph[i] = new ArrayList<>();\n\n    // Build graph\n    for (List<Integer> seq : seqs) {\n      if (seq.size() == 1 && seq.get(0) < 1 || seq.get(0) > n) {\n        return false;\n      } else {\n        for (int i = 0; i + 1 < seq.size(); ++i) {\n          final int u = seq.get(i);\n          final int v = seq.get(i + 1);\n          if (u < 1 || u > n || v < 1 || v > n)\n            return false;\n          graph[u - 1].add(v - 1);\n          ++inDegree[v - 1];\n        }\n      }\n    } \n\n    // Topology\n    Queue<Integer> q = IntStream.range(0, n)\n                           .filter(i -> inDegree[i] == 0)\n                           .boxed()\n                           .collect(Collectors.toCollection(ArrayDeque::new));\n\n    int i = 0; // org's index\n\n    while (!q.isEmpty()) {\n      if (q.size() > 1)\n        return false;\n      final int u = q.poll();\n      if (u != org[i] - 1)\n        return false;\n      ++i;\n      for (final int v : graph[u])\n        if (--inDegree[v] == 0)\n          q.offer(v);\n    } \n\n    return i == n;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "445. Add Two Numbers II",
      "code": "class Solution {\n  public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n    Deque<ListNode> stack1 = new ArrayDeque<>();\n    Deque<ListNode> stack2 = new ArrayDeque<>();\n\n    while (l1 != null) {\n      stack1.push(l1);\n      l1 = l1.next;\n    } \n\n    while (l2 != null) {\n      stack2.push(l2);\n      l2 = l2.next;\n    } \n\n    ListNode head = null;\n    int carry = 0;\n\n    while (carry > 0 || !stack1.isEmpty() || !stack2.isEmpty()) {\n      if (!stack1.isEmpty())\n        carry += stack1.pop().val;\n      if (!stack2.isEmpty())\n        carry += stack2.pop().val;\n      ListNode node = new ListNode(carry % 10);\n      node.next = head;\n      head = node;\n      carry /= 10;\n    } \n\n    return head;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "446. Arithmetic Slices II - Subsequence",
      "code": "class Solution {\n  public int numberOfArithmeticSlices(int[] nums) {\n    final int n = nums.length;\n    int ans = 0;\n    // dp[i][j] := # of subseqs end w/ nums[j] nums[i]\n    int[][] dp = new int[n][n];\n    Map<Long, List<Integer>> numToIndices = new HashMap<>();\n\n    for (int i = 0; i < n; ++i) {\n      numToIndices.putIfAbsent((long) nums[i], new ArrayList<>());\n      numToIndices.get((long) nums[i]).add(i);\n    } \n\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < i; ++j) {\n        final long target = nums[j] * 2L - nums[i];\n        if (numToIndices.containsKey(target))\n          for (final int k : numToIndices.get(target))\n            if (k < j)\n              dp[i][j] += (dp[j][k] + 1);\n        ans += dp[i][j];\n      } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "447. Number of Boomerangs",
      "code": "class Solution {\n  public int numberOfBoomerangs(int[][] points) {\n    int ans = 0;\n\n    for (int[] p : points) {\n      Map<Integer, Integer> distCount = new HashMap<>();\n      for (int[] q : points) {\n        final int dist = (int) getDist(p, q);\n        distCount.put(dist, distCount.getOrDefault(dist, 0) + 1);\n      }\n      for (final int freq : distCount.values())\n        ans += freq * (freq - 1); // C(freq, 2)\n    } \n\n    return ans;\n  } \n\n  private double getDist(int[] p, int[] q) {\n    return Math.pow(p[0] - q[0], 2) + Math.pow(p[1] - q[1], 2);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "448. Find All Numbers Disappeared in an Array",
      "code": "class Solution {\n  public List<Integer> findDisappearedNumbers(int[] nums) {\n    List<Integer> ans = new ArrayList<>();\n\n    for (final int num : nums) {\n      final int index = Math.abs(num) - 1;\n      nums[index] = -Math.abs(nums[index]);\n    } \n\n    for (int i = 0; i < nums.length; ++i)\n      if (nums[i] > 0)\n        ans.add(i + 1);\n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "449. Serialize and Deserialize BST",
      "code": "public class Codec {\n  // Encodes a tree to a single string.\n  public String serialize(TreeNode root) {\n    if (root == null)\n      return \"\";\n\n    StringBuilder sb = new StringBuilder();\n\n    serialize(root, sb);\n    return sb.toString();\n  } \n\n  // Decodes your encoded data to tree.\n  public TreeNode deserialize(String data) {\n    if (data.isEmpty())\n      return null;\n\n    final String[] vals = data.split(\" \");\n    Queue<Integer> q = new ArrayDeque<>();\n\n    for (final String val : vals)\n      q.offer(Integer.parseInt(val));\n\n    return deserialize(Integer.MIN_VALUE, Integer.MAX_VALUE, q);\n  } \n\n  private void serialize(TreeNode root, StringBuilder sb) {\n    if (root == null)\n      return;\n\n    sb.append(root.val).append(\" \");\n    serialize(root.left, sb);\n    serialize(root.right, sb);\n  } \n\n  private TreeNode deserialize(int min, int max, Queue<Integer> q) {\n    if (q.isEmpty())\n      return null;\n\n    final int val = q.peek();\n    if (val < min || val > max)\n      return null;\n\n    q.poll();\n    TreeNode root = new TreeNode(val);\n    root.left = deserialize(min, val, q);\n    root.right = deserialize(val, max, q);\n    return root;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "450. Delete Node in a BST",
      "code": "class Solution {\n  public TreeNode deleteNode(TreeNode root, int key) {\n    if (root == null)\n      return null;\n    if (root.val == key) {\n      if (root.left == null)\n        return root.right;\n      if (root.right == null)\n        return root.left;\n      TreeNode minNode = getMin(root.right);\n      root.right = deleteNode(root.right, minNode.val);\n      minNode.left = root.left;\n      minNode.right = root.right;\n      root = minNode;\n    } else if (root.val < key) {\n      root.right = deleteNode(root.right, key);\n    } else { root.val > key\n      root.left = deleteNode(root.left, key);\n    }\n    return root;\n  } \n\n  private TreeNode getMin(TreeNode node) {\n    while (node.left != null)\n      node = node.left;\n    return node;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "451. Sort Characters By Frequency",
      "code": "class Solution {\n  public String frequencySort(String s) {\n    final int n = s.length();\n    StringBuilder sb = new StringBuilder();\n    int[] count = new int[128];\n    // bucket[i] := stores chars that appear i times in s\n    List<Character>[] bucket = new List[n + 1];\n\n    for (final char c : s.toCharArray())\n      ++count[c];\n\n    for (int i = 0; i < 128; ++i) {\n      final int freq = count[i];\n      if (freq > 0) {\n        if (bucket[freq] == null)\n          bucket[freq] = new ArrayList<>();\n        bucket[freq].add((char) i);\n      }\n    } \n\n    for (int freq = n; freq > 0; --freq)\n      if (bucket[freq] != null)\n        for (final char c : bucket[freq])\n          for (int i = 0; i < freq; ++i)\n            sb.append(c);\n\n    return sb.toString();\n  }\n }\n"
    }
  ],
  [
    {
      "id": "452. Minimum Number of Arrows to Burst Balloons",
      "code": "class Solution {\n  public int findMinArrowShots(int[][] points) {\n    Arrays.sort(points, (a, b) -> a[1] - b[1]);\n\n    int ans = 1;\n    int arrowX = points[0][1];\n\n    for (int i = 1; i < points.length; ++i)\n      if (points[i][0] > arrowX) {\n        arrowX = points[i][1];\n        ++ans;\n      } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "453. Minimum Moves to Equal Array Elements",
      "code": "class Solution {\n  public int minMoves(int[] nums) {\n    final int sum = Arrays.stream(nums).sum();\n    final int min = Arrays.stream(nums).min().getAsInt();\n    return sum - min * nums.length;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "454. 4Sum II",
      "code": "class Solution {\n  public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\n    int ans = 0;\n    Map<Integer, Integer> count = new HashMap<>();\n\n    for (final int a : nums1)\n      for (final int b : nums2)\n        count.merge(a + b, 1, Integer::sum);\n\n    for (final int c : nums3)\n      for (final int d : nums4)\n        if (count.containsKey(-c - d))\n          ans += count.get(-c - d);\n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "455. Assign Cookies",
      "code": "class Solution {\n  public int findContentChildren(int[] g, int[] s) {\n    Arrays.sort(g);\n    Arrays.sort(s);\n\n    int i = 0;\n    for (int j = 0; i < g.length && j < s.length; ++j)\n      if (g[i] <= s[j])\n        ++i;\n\n    return i;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "456. 132 Pattern",
      "code": "class Solution {\n  public boolean find132pattern(int[] nums) {\n    Deque<Integer> stack = new ArrayDeque<>(); // Max stack\n    int ak = Integer.MIN_VALUE;                // We want to find a seq ai < ak < aj\n\n    for (int i = nums.length - 1; i >= 0; --i) {\n      if (nums[i] < ak) // Ai < ak, we're done because ai must also smaller than aj\n        return true;\n      while (!stack.isEmpty() && stack.peek() < nums[i])\n        ak = stack.pop();\n      stack.push(nums[i]); // nums[i] is a candidate of aj\n    } \n\n    return false;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "457. Circular Array Loop",
      "code": "class Solution {\n  public boolean circularArrayLoop(int[] nums) {\n    if (nums.length < 2)\n      return false;\n\n    for (int i = 0; i < nums.length; ++i) {\n      if (nums[i] == 0)\n        continue;\n      int slow = i;\n      int fast = advance(nums, slow);\n      while (nums[i] * nums[fast] > 0 && nums[i] * nums[advance(nums, fast)] > 0) {\n        if (slow == fast) {\n          if (slow == advance(nums, slow))\n            break;\n          return true;\n        }\n        slow = advance(nums, slow);\n        fast = advance(nums, advance(nums, fast));\n      } \n\n      slow = i;\n      final int sign = nums[i];\n      while (sign * nums[slow] > 0) {\n        final int next = advance(nums, slow);\n        nums[slow] = 0;\n        slow = next;\n      }\n    } \n\n    return false;\n  } \n\n  private int advance(int[] nums, int i) {\n    final int n = nums.length;\n    final int val = (i + nums[i]) % n;\n    return i + nums[i] >= 0 ? val : n + val;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "458. Poor Pigs",
      "code": "class Solution {\n  public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\n    return (int) Math.ceil(Math.log(buckets) / Math.log(minutesToTest / minutesToDie + 1));\n  }\n }\n"
    }
  ],
  [
    {
      "id": "459. Repeated Substring Pattern",
      "code": "class Solution {\n  public boolean repeatedSubstringPattern(String s) {\n    final String ss = s + s;\n    return ss.substring(1, ss.length() - 1).contains(s);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "460. LFU Cache",
      "code": "class LFUCache {\n  public LFUCache(int capacity) {\n    this.capacity = capacity;\n  } \n\n  public int get(int key) {\n    if (!keyToVal.containsKey(key))\n      return -1;\n\n    final int freq = keyToFreq.get(key);\n    freqToLRUKeys.get(freq).remove(key);\n    if (freq == minFreq && freqToLRUKeys.get(freq).isEmpty()) {\n      freqToLRUKeys.remove(freq);\n      ++minFreq;\n    } \n\n    // Increase key's freq by 1\n    // Add this key to next freq's list\n    putFreq(key, freq + 1);\n    return keyToVal.get(key);\n  } \n\n  public void put(int key, int value) {\n    if (capacity == 0)\n      return;\n    if (keyToVal.containsKey(key)) {\n      keyToVal.put(key, value);\n      get(key); // Update key's count\n      return;\n    } \n\n    if (keyToVal.size() == capacity) {\n      // Evict LRU key from the minFreq list\n      final int keyToEvict = freqToLRUKeys.get(minFreq).iterator().next();\n      freqToLRUKeys.get(minFreq).remove(keyToEvict);\n      keyToVal.remove(keyToEvict);\n    } \n\n    minFreq = 1;\n    putFreq(key, minFreq);    // Add new key and freq\n    keyToVal.put(key, value); // Add new key and value\n  } \n\n  private int capacity;\n  private int minFreq = 0;\n  private Map<Integer, Integer> keyToVal = new HashMap<>();\n  private Map<Integer, Integer> keyToFreq = new HashMap<>();\n  private Map<Integer, LinkedHashSet<Integer>> freqToLRUKeys = new HashMap<>();\n\n  private void putFreq(int key, int freq) {\n    keyToFreq.put(key, freq);\n    freqToLRUKeys.putIfAbsent(freq, new LinkedHashSet<>());\n    freqToLRUKeys.get(freq).add(key);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "461. Hamming Distance",
      "code": "class Solution {\n  public int hammingDistance(int x, int y) {\n    int ans = 0;\n\n    while (x > 0 || y > 0) {\n      ans += (x & 1) ^ (y & 1);\n      x >>= 1;\n      y >>= 1;\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "462. Minimum Moves to Equal Array Elements II",
      "code": "class Solution {\n  public int minMoves2(int[] nums) {\n    final int n = nums.length;\n    final int median = quickSelect(nums, 0, n - 1, (n + 1) / 2);\n    int ans = 0;\n\n    for (final int num : nums)\n      ans += Math.abs(num - median);\n\n    return ans;\n  } \n\n  private int quickSelect(int[] nums, int l, int r, int k) {\n    final int randIndex = new Random().nextInt(r - l + 1) + l;\n    swap(nums, randIndex, r);\n    final int pivot = nums[r];\n\n    int nextSwapped = l;\n    for (int i = l; i < r; ++i)\n      if (nums[i] <= pivot)\n        swap(nums, nextSwapped++, i);\n    swap(nums, nextSwapped, r);\n\n    final int count = nextSwapped - l + 1;\n    if (count == k)\n      return nums[nextSwapped];\n    if (count > k)\n      return quickSelect(nums, l, nextSwapped - 1, k);\n    return quickSelect(nums, nextSwapped + 1, r, k - count);\n  } \n\n  private void swap(int[] nums, int i, int j) {\n    final int temp = nums[i];\n    nums[i] = nums[j];\n    nums[j] = temp;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "463. Island Perimeter",
      "code": "class Solution {\n  public int islandPerimeter(int[][] grid) {\n    int islands = 0;\n    int neighbors = 0;\n\n    for (int i = 0; i < grid.length; ++i)\n      for (int j = 0; j < grid[0].length; ++j)\n        if (grid[i][j] == 1) {\n          ++islands;\n          if (i - 1 >= 0 && grid[i - 1][j] == 1)\n            ++neighbors;\n          if (j - 1 >= 0 && grid[i][j - 1] == 1)\n            ++neighbors;\n        } \n\n    return islands * 4 - neighbors * 2;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "464. Can I Win",
      "code": "class Solution {\n  public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\n    if (desiredTotal <= 0)\n      return true;\n\n    final int sum = maxChoosableInteger * (maxChoosableInteger + 1) / 2;\n    if (sum < desiredTotal)\n      return false;\n\n    return dp(desiredTotal, 0, maxChoosableInteger);\n  } \n\n  // true: can win, false: can't win\n  private Map<Integer, Boolean> memo = new HashMap<>();\n\n  // state: record integers that have been chosen\n  private boolean dp(int total, int state, int n) {\n    if (total <= 0)\n      return false;\n    if (memo.containsKey(state))\n      return memo.get(state);\n\n    for (int i = 1; i <= n; ++i) {\n      if ((state & 1 << i) == 1) // Integer i is used\n        continue;\n      if (!dp(total - i, state | 1 << i, n))\n        return true;\n    } \n\n    memo.put(state, false);\n    return false;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "465. Optimal Account Balancing",
      "code": "class Solution {\n  public int minTransfers(int[][] transactions) {\n    int[] balance = new int[21];\n    List<Integer> debt = new ArrayList<>();\n\n    for (int[] t : transactions) {\n      final int from = t[0];\n      final int to = t[1];\n      final int amount = t[2];\n      balance[from] -= amount;\n      balance[to] += amount;\n    } \n\n    for (final int b : balance)\n      if (b != 0)\n        debt.add(b);\n\n    return dfs(debt, 0);\n  } \n\n  private int dfs(List<Integer> debt, int s) {\n    while (s < debt.size() && debt.get(s) == 0)\n      ++s;\n    if (s == debt.size())\n      return 0;\n\n    int ans = Integer.MAX_VALUE;\n\n    for (int i = s + 1; i < debt.size(); ++i)\n      if (debt.get(i) * debt.get(s) < 0) {\n        debt.set(i, debt.get(i) + debt.get(s)); // Debt.get(s) is settled\n        ans = Math.min(ans, 1 + dfs(debt, s + 1));\n        debt.set(i, debt.get(i) - debt.get(s)); // Backtrack\n      } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "466. Count The Repetitions",
      "code": "class Record {\n  public int count;\n  public int nextIndex;\n  public Record(int count, int nextIndex) {\n    this.count = count;\n    this.nextIndex = nextIndex;\n  }\n};\n\n class Solution {\n  public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\n    List<Record> records = new ArrayList<>(); // [count(s1 matches s2[i:]), next index of s2[i:]]\n\n    for (int i = 0; i < s2.length(); ++i) {\n      int count = 0;\n      int nextIndex = i;\n      for (int j = 0; j < s1.length(); ++j)\n        if (s2.charAt(nextIndex) == s1.charAt(j))\n          if (++nextIndex == s2.length()) { // Have a match\n            ++count;\n            nextIndex = 0;\n          }\n      records.add(new Record(count, nextIndex));\n    } \n\n    int matches = 0; // S1 matches s2\n    int index = 0;\n\n    while (n1-- > 0) {\n      matches += records.get(index).count;\n      index = records.get(index).nextIndex;\n    } \n\n    return matches / n2; // S1 matches S2\n  }\n }\n"
    }
  ],
  [
    {
      "id": "467. Unique Substrings in Wraparound String",
      "code": "class Solution {\n  public int findSubstringInWraproundString(String p) {\n    int maxLength = 1;\n    int[] count = new int[26]; // Substrings end at i\n\n    for (int i = 0; i < p.length(); ++i) {\n      if (i > 0 && (p.charAt(i) - p.charAt(i - 1) == 1 || p.charAt(i - 1) - p.charAt(i) == 25))\n        ++maxLength;\n      else\n        maxLength = 1;\n      final int index = p.charAt(i) - 'a';\n      count[index] = Math.max(count[index], maxLength);\n    } \n\n    return Arrays.stream(count).sum();\n  }\n }\n"
    }
  ],
  [
    {
      "id": "468. Validate IP Address",
      "code": "class Solution {\n  public String validIPAddress(String IP) {\n    if (IP.chars().filter(c -> c == '.').count() == 3) {\n      for (final String digit : IP.split(\"\\\\.\", -1))\n        if (!isIPv4(digit))\n          return \"Neither\";\n      return \"IPv4\";\n    } \n\n    if (IP.chars().filter(c -> c == ':').count() == 7) {\n      for (final String digit : IP.split(\"\\\\:\", -1))\n        if (!isIPv6(digit))\n          return \"Neither\";\n      return \"IPv6\";\n    } \n\n    return \"Neither\";\n  } \n\n  private static final String validIPv6Chars = \"0123456789abcdefABCDEF\";\n\n  private boolean isIPv4(final String digit) {\n    if (digit.isEmpty() || digit.length() > 3)\n      return false;\n    if (digit.length() > 1 && digit.charAt(0) == '0')\n      return false;\n\n    for (final char c : digit.toCharArray())\n      if (c < '0' || c > '9')\n        return false;\n\n    final int num = Integer.parseInt(digit);\n    return 0 <= num && num <= 255;\n  } \n\n  private boolean isIPv6(final String digit) {\n    if (digit.isEmpty() || digit.length() > 4)\n      return false;\n\n    for (final char c : digit.toCharArray())\n      if (!validIPv6Chars.contains(\"\" + c))\n        return false;\n\n    return true;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "469. Convex Polygon",
      "code": "class Solution {\n  public boolean isConvex(List<List<Integer>> points) {\n    final int n = points.size();\n    long sign = 0;\n\n    for (int i = 0; i < n; ++i) {\n      final int cross = getCross(points.get(i), points.get((i + 1) % n), points.get((i + 2) % n));\n      if (cross == 0) // P, q, r are collinear\n        continue;\n      if (sign == 0) // Find first cross that's not 0\n        sign = cross;\n      else if (cross * sign < 0)\n        return false;\n    } \n\n    return true;\n  } \n\n  private int getCross(List<Integer> p, List<Integer> q, List<Integer> r) {\n    return (q.get(0) - p.get(0)) * (r.get(1) - p.get(1)) -\n        (q.get(1) - p.get(1)) * (r.get(0) - p.get(0));\n  }\n }\n"
    }
  ],
  null,
  [
    {
      "id": "471. Encode String with Shortest Length",
      "code": "class Solution {\n  public String encode(String s) {\n    final int n = s.length();\n    // dp[i][j] := shortest encoded String of s[i..j]\n    dp = new String[n][n];\n    return encode(s, 0, n - 1);\n  } \n\n  private String[][] dp;\n\n  private String encode(final String s, int i, int j) {\n    if (dp[i][j] != null)\n      return dp[i][j];\n\n    final String curr = s.substring(i, j + 1);\n    dp[i][j] = curr;\n\n    if (dp[i][j].length() < 5)\n      return dp[i][j];\n\n    // Try all possible partitions\n    for (int k = i; k < j; ++k) {\n      final String l = encode(s, i, k);\n      final String r = encode(s, k + 1, j);\n      if (l.length() + r.length() < dp[i][j].length())\n        dp[i][j] = l + r;\n    } \n\n    // Try to compress theString\n    // E.g. s = aabaabaab -> 3[aab]\n    for (int k = i; k <= j; ++k) {\n      final String pattern = s.substring(i, k + 1);\n      if (curr.length() % pattern.length() == 0 && curr.replaceAll(pattern, \"\").isEmpty()) {\n        final String candidate =\n            String.valueOf(curr.length() / pattern.length()) + \"[\" + encode(s, i, k) + \"]\";\n        if (candidate.length() < dp[i][j].length())\n          dp[i][j] = candidate;\n      }\n    } \n\n    return dp[i][j];\n  }\n }\n"
    }
  ],
  [
    {
      "id": "472. Concatenated Words",
      "code": "class Solution {\n  public List<String> findAllConcatenatedWordsInADict(String[] words) {\n    List<String> ans = new ArrayList<>();\n    Set<String> wordSet = new HashSet<>(Arrays.asList(words));\n    Map<String, Boolean> memo = new HashMap<>();\n\n    for (final String word : words)\n      if (wordBreak(word, wordSet, memo))\n        ans.add(word);\n\n    return ans;\n  } \n\n  private boolean wordBreak(final String word, Set<String> wordSet, Map<String, Boolean> memo) {\n    if (memo.containsKey(word))\n      return memo.get(word);\n\n    for (int i = 1; i < word.length(); ++i) {\n      final String prefix = word.substring(0, i);\n      final String suffix = word.substring(i);\n      if (wordSet.contains(prefix) &&\n          (wordSet.contains(suffix) || wordBreak(suffix, wordSet, memo))) {\n        memo.put(word, true);\n        return true;\n      }\n    } \n\n    memo.put(word, false);\n    return false;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "473. Matchsticks to Square",
      "code": "class Solution {\n  public boolean makesquare(int[] matchsticks) {\n    if (matchsticks.length < 4)\n      return false;\n\n    final int perimeter = Arrays.stream(matchsticks).sum();\n    if (perimeter % 4 != 0)\n      return false;\n\n    int[] edges = new int[4];\n    Arrays.fill(edges, perimeter / 4);\n    Arrays.sort(edges); // can't do \"Arrays.sort(edges, (a, b) -> b - a);\" in Java\n    return dfs(matchsticks, matchsticks.length - 1, edges);\n  } \n\n  private boolean dfs(int[] matchsticks, int selected, int[] edges) {\n    if (selected == -1)\n      return Arrays.stream(edges).allMatch(edge -> edge == 0);\n\n    for (int i = 0; i < 4; ++i) {\n      if (matchsticks[selected] > edges[i])\n        continue;\n      edges[i] -= matchsticks[selected];\n      if (dfs(matchsticks, selected - 1, edges))\n        return true;\n      edges[i] += matchsticks[selected];\n    } \n\n    return false;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "474. Ones and Zeroes",
      "code": "class Solution {\n  public int findMaxForm(String[] strs, int m, int n) {\n    // dp[i][j] := max size of the subset given i 0's and j 1's are available\n    int[][] dp = new int[m + 1][n + 1];\n\n    for (final String s : strs) {\n      final int count0 = (int) s.chars().filter(c -> c == '0').count();\n      final int count1 = (int) s.length() - count0;\n      for (int i = m; i >= count0; --i)\n        for (int j = n; j >= count1; --j)\n          dp[i][j] = Math.max(dp[i][j], dp[i - count0][j - count1] + 1);\n    } \n\n    return dp[m][n];\n  }\n }\n"
    }
  ],
  [
    {
      "id": "475. Heaters",
      "code": "class Solution {\n  public int findRadius(int[] houses, int[] heaters) {\n    Arrays.sort(houses);\n    Arrays.sort(heaters);\n\n    int ans = 0;\n    int i = 0; // Point to the heater that currently used\n\n    for (final int house : houses) {\n      while (i + 1 < heaters.length && house - heaters[i] > heaters[i + 1] - house)\n        ++i; // Next heater is better\n      ans = Math.max(ans, Math.abs(heaters[i] - house));\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "476. Number Complement",
      "code": "class Solution {\n  public int findComplement(int num) {\n    for (long i = 1; i <= num; i <<= 1)\n      num ^= i;\n    return num;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "477. Total Hamming Distance",
      "code": "class Solution {\n  public int totalHammingDistance(int[] nums) {\n    int ans = 0;\n    int mask = 1;\n\n    for (int i = 0; i < 30; ++i) {\n      final int onesCount = getCount(nums, mask);\n      final int zerosCount = nums.length - onesCount;\n      ans += onesCount * zerosCount;\n      mask <<= 1;\n    } \n\n    return ans;\n  } \n\n  private int getCount(int[] nums, int mask) {\n    int count = 0;\n    for (final int num : nums)\n      if ((num & mask) > 0)\n        ++count;\n    return count;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "478. Generate Random Point in a Circle",
      "code": "class Solution {\n  public Solution(double radius, double x_center, double y_center) {\n    this.radius = radius;\n    this.x_center = x_center;\n    this.y_center = y_center;\n  } \n\n  public double[] randPoint() {\n    final double length = Math.sqrt(Math.random()) * radius;\n    final double degree = Math.random() * 2 * Math.PI;\n    final double x = x_center + length * Math.cos(degree);\n    final double y = y_center + length * Math.sin(degree);\n    return new double[] {x, y};\n  } \n\n  private double radius;\n  private double x_center;\n  private double y_center;\n}\n"
    }
  ],
  [
    {
      "id": "479. Largest Palindrome Product",
      "code": "class Solution {\n  public int largestPalindrome(int n) {\n    if (n == 1)\n      return 9;\n\n    final int kMod = 1337;\n    final int upper = (int) Math.pow(10, n) - 1;\n    final int lower = (int) Math.pow(10, n - 1) - 1;\n\n    for (int i = upper; i > lower; --i) {\n      final long cand = getPalindromeCandidate(i);\n      for (long j = upper; j * j >= cand; --j)\n        if (cand % j == 0)\n          return (int) (cand % kMod);\n    } \n\n    throw new IllegalArgumentException();\n  } \n\n  private long getPalindromeCandidate(int i) {\n    final String reversed = new StringBuilder().append(i).reverse().toString();\n    return Long.valueOf(i + reversed);\n  }\n }\n"
    }
  ],
  null,
  null,
  [
    {
      "id": "482. License Key Formatting",
      "code": "class Solution {\n  public String licenseKeyFormatting(String s, int k) {\n    StringBuilder sb = new StringBuilder();\n    int length = 0;\n\n    for (int i = s.length() - 1; i >= 0; --i) {\n      if (s.charAt(i) == '-')\n        continue;\n      if (length > 0 && length % k == 0)\n        sb.append('-');\n      sb.append(Character.toUpperCase(s.charAt(i)));\n      ++length;\n    } \n\n    return sb.reverse().toString();\n  }\n }\n"
    }
  ],
  [
    {
      "id": "483. Smallest Good Base",
      "code": "class Solution {\n  public String smallestGoodBase(String n) {\n    final long num = Long.parseLong(n);\n    final int log2 = (int) (Math.log(num) / Math.log(2));\n\n    for (int m = log2; m >= 2; --m) {\n      int k = (int) Math.floor(Math.pow(num, 1.0 / m));\n      long sum = 1;\n      long prod = 1;\n      for (int i = 0; i < m; ++i) {\n        prod *= k;\n        sum += prod;\n      }\n      if (sum == num)\n        return String.valueOf(k);\n    } \n\n    return String.valueOf(num - 1);\n  }\n }\n"
    }
  ],
  [
    {
      "id": "484. Find Permutation",
      "code": "class Solution {\n  public int[] findPermutation(String s) {\n    int[] ans = new int[s.length() + 1];\n    int ansIndex = 0;\n    Deque<Integer> stack = new ArrayDeque<>();\n\n    for (int i = 0; i < s.length(); ++i) {\n      stack.push(i + 1);\n      if (s.charAt(i) == 'I')\n        while (!stack.isEmpty())\n          ans[ansIndex++] = stack.pop();\n    }\n    stack.push(s.length() + 1);\n\n    while (!stack.isEmpty())\n      ans[ansIndex++] = stack.pop();\n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "485. Max Consecutive Ones",
      "code": "class Solution {\n  public int findMaxConsecutiveOnes(int[] nums) {\n    int ans = 0;\n    int sum = 0;\n\n    for (final int num : nums)\n      if (num == 1)\n        ans = Math.max(ans, ++sum);\n      else\n        sum = 0;\n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "486. Predict the Winner",
      "code": "class Solution {\n  public boolean PredictTheWinner(int[] nums) {\n    final int n = nums.length;\n    // dp[i][j] := max number you can get more than your opponent in nums[i..j]\n    int[][] dp = new int[n][n];\n\n    for (int i = 0; i < n; ++i)\n      dp[i][i] = nums[i];\n\n    for (int d = 1; d < n; ++d)\n      for (int i = 0; i + d < n; ++i) {\n        final int j = i + d;\n        dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);\n      } \n\n    return dp[0][n - 1] >= 0;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "487. Max Consecutive Ones II",
      "code": "class Solution {\n  public int findMaxConsecutiveOnes(int[] nums) {\n    int ans = 0;\n    int zeros = 0;\n\n    for (int l = 0, r = 0; r < nums.length; ++r) {\n      if (nums[r] == 0)\n        ++zeros;\n      while (zeros == 2)\n        if (nums[l++] == 0)\n          --zeros;\n      ans = Math.max(ans, r - l + 1);\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "488. Zuma Game",
      "code": "class Solution {\n  public int findMinStep(String board, String hand) {\n    Map<String, Integer> memo = new HashMap<>();\n    final int ans = dfs(board + '#', hand, memo);\n    return ans == Integer.MAX_VALUE ? -1 : ans;\n  } \n\n  private int dfs(String board, final String hand, Map<String, Integer> memo) {\n    final String hashKey = board + '#' + hand;\n    if (memo.containsKey(hashKey))\n      return memo.get(hashKey);\n    board = deDup(board);\n    if (board.equals(\"#\"))\n      return 0;\n\n    Set<Character> boardSet = new HashSet<>();\n    for (final char c : board.toCharArray())\n      boardSet.add(c);\n\n    StringBuilder sb = new StringBuilder();\n    for (final char h : hand.toCharArray())\n      if (boardSet.contains(h))\n        sb.append(h);\n    final String hs = sb.toString();\n    if (sb.length() == 0) // Infeasible\n      return Integer.MAX_VALUE;\n\n    int ans = Integer.MAX_VALUE;\n\n    for (int i = 0; i < board.length(); ++i)\n      for (int j = 0; j < hs.length(); ++j) {\n        // Place hs[j] in board[i]\n        final String newHand = hs.substring(0, j) + hs.substring(j + 1);\n        String newBoard = board.substring(0, i) + hs.charAt(j) + board.substring(i);\n        final int res = dfs(newBoard, newHand, memo);\n        if (res < Integer.MAX_VALUE)\n          ans = Math.min(ans, 1 + res);\n      } \n\n    memo.put(hashKey, ans);\n    return ans;\n  } \n\n  private String deDup(String board) {\n    int start = 0; // Start index of a color sequenece\n    for (int i = 0; i < board.length(); ++i)\n      if (board.charAt(i) != board.charAt(start)) {\n        if (i - start >= 3)\n          return deDup(board.substring(0, start) + board.substring(i));\n        start = i; // Meet a new sequence\n      }\n    return board;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "489. Robot Room Cleaner",
      "code": "/**\n * // This is the robot's control interface.\n * // You should not implement it, or speculate about its implementation\n * interface Robot {\n *   // Returns true if the cell in front is open and robot moves into the cell.\n *   // Returns false if the cell in front is blocked and robot stays in the current cell.\n *   public boolean move();\n *\n *   // Robot will stay in the same cell after calling turnLeft/turnRight.\n *   // Each turn will be 90 degrees.\n *   public void turnLeft();\n *   public void turnRight();\n *\n *   // Clean the current cell.\n *   public void clean();\n * }\n */\n\n class Solution {\n  public void cleanRoom(Robot robot) {\n    dfs(robot, 0, 0, 0, new HashSet<>());\n  } \n\n  private static final int[] dirs = {0, 1, 0, -1, 0};\n\n  private void dfs(Robot robot, int d, int i, int j, Set<Pair<Integer, Integer>> seen) {\n    seen.add(new Pair<>(i, j));\n    robot.clean();\n\n    // Explore clockwise: 0: ^, 1: >, 2: v, 3: <\n    // The order is important since the idea is always turn right\n    for (int k = 0; k < 4; ++k) {\n      final int newD = (d + k) % 4;\n      final int x = i + dirs[newD];\n      final int y = j + dirs[newD + 1];\n      if (!seen.contains(new Pair<>(x, y)) && robot.move()) {\n        dfs(robot, newD, x, y, seen);\n        // Go back to the previous cell\n        robot.turnRight();\n        robot.turnRight();\n        robot.move();\n        // Go back to the original direction\n        robot.turnRight();\n        robot.turnRight();\n      }\n      robot.turnRight(); // Always turn the robot clockwise\n    }\n  }\n }\n"
    }
  ],
  [
    {
      "id": "490. The Maze",
      "code": "class Solution {\n  public boolean hasPath(int[][] maze, int[] start, int[] destination) {\n    final int m = maze.length;\n    final int n = maze[0].length;\n    final int[] dirs = {0, 1, 0, -1, 0};\n    Queue<int[]> q = new ArrayDeque<>(Arrays.asList(new int[] {start[0], start[1]}));\n    boolean[][] seen = new boolean[m][n];\n    seen[start[0]][start[1]] = true;\n\n    while (!q.isEmpty()) {\n      final int i = q.peek()[0];\n      final int j = q.poll()[1];\n      for (int k = 0; k < 4; ++k) {\n        int x = i;\n        int y = j;\n        while (isValid(maze, x + dirs[k], y + dirs[k + 1])) {\n          x += dirs[k];\n          y += dirs[k + 1];\n        }\n        if (x == destination[0] && y == destination[1])\n          return true;\n        if (seen[x][y])\n          continue;\n        q.offer(new int[] {x, y});\n        seen[x][y] = true;\n      }\n    } \n\n    return false;\n  } \n\n  private boolean isValid(int[][] maze, int x, int y) {\n    return 0 <= x && x < maze.length && 0 <= y && y < maze[0].length && maze[x][y] == 0;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "491. Non-decreasing Subsequences",
      "code": "class Solution {\n  public List<List<Integer>> findSubsequences(int[] nums) {\n    List<List<Integer>> ans = new LinkedList<>();\n    dfs(nums, 0, new LinkedList<>(), ans);\n    return ans;\n  } \n\n  private void dfs(int[] nums, int s, LinkedList<Integer> path, List<List<Integer>> ans) {\n    if (path.size() > 1)\n      ans.add(new LinkedList<>(path));\n\n    Set<Integer> used = new HashSet<>();\n\n    for (int i = s; i < nums.length; ++i) {\n      if (used.contains(nums[i]))\n        continue;\n      if (path.isEmpty() || nums[i] >= path.getLast()) {\n        used.add(nums[i]);\n        path.addLast(nums[i]);\n        dfs(nums, i + 1, path, ans);\n        path.removeLast();\n      }\n    }\n  }\n }\n"
    }
  ],
  [
    {
      "id": "492. Construct the Rectangle",
      "code": "class Solution {\n  public int[] constructRectangle(int area) {\n    int width = (int) Math.sqrt(area);\n\n    while (area % width > 0)\n      --width;\n\n    return new int[] {area / width, width};\n  }\n }\n"
    }
  ],
  null,
  [
    {
      "id": "494. Target Sum",
      "code": "class Solution {\n  public int findTargetSumWays(int[] nums, int target) {\n    final int sum = Arrays.stream(nums).sum();\n    if (sum < Math.abs(target) || (sum + target) % 2 == 1)\n      return 0;\n    return knapsack(nums, (sum + target) / 2);\n  } \n\n  private int knapsack(int[] nums, int target) {\n    final int n = nums.length;\n    // dp[i][j] := # of ways to sum to j by nums[0..i)\n    int[][] dp = new int[n + 1][target + 1];\n    dp[0][0] = 1;\n\n    for (int i = 1; i <= n; ++i) {\n      final int num = nums[i - 1];\n      for (int j = 0; j <= target; ++j)\n        if (j < num)\n          dp[i][j] = dp[i - 1][j];\n        else\n          dp[i][j] = dp[i - 1][j] + dp[i - 1][j - num];\n    } \n\n    return dp[n][target];\n  }\n }\n"
    }
  ],
  [
    {
      "id": "495. Teemo Attacking",
      "code": "class Solution {\n  public int findPoisonedDuration(int[] timeSeries, int duration) {\n    if (duration == 0)\n      return 0;\n\n    int ans = 0;\n\n    for (int i = 0; i + 1 < timeSeries.length; ++i)\n      ans += Math.min(timeSeries[i + 1] - timeSeries[i], duration);\n\n    return ans + duration;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "496. Next Greater Element I",
      "code": "class Solution {\n  public int[] nextGreaterElement(int[] nums1, int[] nums2) {\n    List<Integer> ans = new ArrayList<>();\n    Map<Integer, Integer> numToNextGreater = new HashMap<>();\n    Deque<Integer> stack = new ArrayDeque<>(); // Decreasing stack\n\n    for (final int num : nums2) {\n      while (!stack.isEmpty() && stack.peek() < num)\n        numToNextGreater.put(stack.pop(), num);\n      stack.push(num);\n    } \n\n    for (final int num : nums1)\n      if (numToNextGreater.containsKey(num))\n        ans.add(numToNextGreater.get(num));\n      else\n        ans.add(-1);\n\n    return ans.stream().mapToInt(Integer::intValue).toArray();\n  }\n }\n"
    }
  ],
  [
    {
      "id": "497. Random Point in Non-overlapping Rectangles",
      "code": "class Solution {\n  public Solution(int[][] rects) {\n    this.rects = rects;\n    areas = new int[rects.length];\n    for (int i = 0; i < rects.length; ++i)\n      areas[i] = getArea(rects[i]) + (i > 0 ? areas[i - 1] : 0);\n  } \n\n  public int[] pick() {\n    final int target = rand.nextInt(areas[areas.length - 1]);\n    final int index = firstGreater(areas, target);\n    final int[] r = rects[index];\n    return new int[] {\n        rand.nextInt(r[2] - r[0] + 1) + r[0],\n        rand.nextInt(r[3] - r[1] + 1) + r[1],\n    };\n  } \n\n  private int[][] rects;\n  private int[] areas;\n  private Random rand = new Random();\n\n  private int getArea(int[] r) {\n    return (r[2] - r[0] + 1) * (r[3] - r[1] + 1);\n  } \n\n  private int firstGreater(int[] areas, int target) {\n    int l = 0;\n    int r = areas.length;\n    while (l < r) {\n      final int m = (l + r) / 2;\n      if (areas[m] > target)\n        r = m;\n      else\n        l = m + 1;\n    }\n    return l;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "498. Diagonal Traverse",
      "code": "class Solution {\n  public int[] findDiagonalOrder(int[][] matrix) {\n    final int m = matrix.length;\n    final int n = matrix[0].length;\n    int[] ans = new int[m * n];\n    int d = 1; // Left-bottom -> right-top\n    int row = 0;\n    int col = 0;\n\n    for (int i = 0; i < m * n; ++i) {\n      ans[i] = matrix[row][col];\n      row -= d;\n      col += d;\n      // Out of bound\n      if (row == m) {\n        row = m - 1;\n        col += 2;\n        d = -d;\n      }\n      if (col == n) {\n        col = n - 1;\n        row += 2;\n        d = -d;\n      }\n      if (row < 0) {\n        row = 0;\n        d = -d;\n      }\n      if (col < 0) {\n        col = 0;\n        d = -d;\n      }\n    } \n\n    return ans;\n  }\n }\n"
    }
  ],
  [
    {
      "id": "499. The Maze III",
      "code": "class Solution {\n  public String findShortestWay(int[][] maze, int[] ball, int[] hole) {\n    dfs(maze, ball[0], ball[1], hole, 0, 0, 0, \"\");\n    return ans;\n  } \n\n  private String ans = \"impossible\";\n  private int minSteps = Integer.MAX_VALUE;\n\n  private void dfs(int[][] maze, int i, int j, int[] hole, int dx, int dy, int steps,\n                   final String path) {\n    if (steps >= minSteps)\n      return;\n\n    if (dx != 0 || dy != 0) { // Both are zero for the initial ball position\n      while (i + dx >= 0 && i + dx < maze.length && j + dy >= 0 && j + dy < maze[0].length &&\n             maze[i + dx][j + dy] != 1) {\n        i += dx;\n        j += dy;\n        ++steps;\n        if (i == hole[0] && j == hole[1] && steps < minSteps) {\n          minSteps = steps;\n          ans = path;\n        }\n      }\n    } \n\n    if (maze[i][j] == 0 || steps + 2 < maze[i][j]) {\n      maze[i][j] = steps + 2; // +2 to because of maze[i][j] == 0 || 1\n      if (dx == 0)\n        dfs(maze, i, j, hole, 1, 0, steps, path + \"d\");\n      if (dy == 0)\n        dfs(maze, i, j, hole, 0, -1, steps, path + \"l\");\n      if (dy == 0)\n        dfs(maze, i, j, hole, 0, 1, steps, path + \"r\");\n      if (dx == 0)\n        dfs(maze, i, j, hole, -1, 0, steps, path + \"u\");\n    }\n  }\n }\n"
    }
  ]
]
