[
  "class Solution {\n  public int[] twoSum(int[] nums, int target) {\n    Map<Integer, Integer> numToIndex = new HashMap<>();\n\n    for (int i = 0; i < nums.length; ++i) {\n      if (numToIndex.containsKey(target - nums[i]))\n        return new int[] {numToIndex.get(target - nums[i]), i};\n      numToIndex.put(nums[i], i);\n    }\n\n    throw new IllegalArgumentException();\n  }\n}\n",
  "class Solution {\n  public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n    ListNode dummy = new ListNode(0);\n    ListNode curr = dummy;\n    int carry = 0;\n\n    while (l1 != null || l2 != null || carry > 0) {\n      if (l1 != null) {\n        carry += l1.val;\n        l1 = l1.next;\n      }\n      if (l2 != null) {\n        carry += l2.val;\n        l2 = l2.next;\n      }\n      curr.next = new ListNode(carry % 10);\n      carry /= 10;\n      curr = curr.next;\n    }\n\n    return dummy.next;\n  }\n}\n",
  "class Solution {\n  public int lengthOfLongestSubstring(String s) {\n    int ans = 0;\n    int[] count = new int[128];\n\n    for (int l = 0, r = 0; r < s.length(); ++r) {\n      ++count[s.charAt(r)];\n      while (count[s.charAt(r)] > 1)\n        --count[s.charAt(l++)];\n      ans = Math.max(ans, r - l + 1);\n    }\n\n    return ans;\n  }\n}\n",
  "class Solution {\n  public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n    final int n1 = nums1.length;\n    final int n2 = nums2.length;\n    if (n1 > n2)\n      return findMedianSortedArrays(nums2, nums1);\n\n    int l = 0;\n    int r = n1;\n\n    while (l <= r) {\n      final int partition1 = (l + r) / 2;\n      final int partition2 = (n1 + n2 + 1) / 2 - partition1;\n      final int maxLeft1 = partition1 == 0 ? Integer.MIN_VALUE : nums1[partition1 - 1];\n      final int maxLeft2 = partition2 == 0 ? Integer.MIN_VALUE : nums2[partition2 - 1];\n      final int minRight1 = partition1 == n1 ? Integer.MAX_VALUE : nums1[partition1];\n      final int minRight2 = partition2 == n2 ? Integer.MAX_VALUE : nums2[partition2];\n      if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1)\n        return (n1 + n2) % 2 == 0\n            ? (Math.max(maxLeft1, maxLeft2) + Math.min(minRight1, minRight2)) * 0.5\n            : Math.max(maxLeft1, maxLeft2);\n      else if (maxLeft1 > minRight2)\n        r = partition1 - 1;\n      else\n        l = partition1 + 1;\n    }\n\n    throw new IllegalArgumentException();\n  }\n}\n",
  "class Solution {\n  public String longestPalindrome(String s) {\n    if (s.isEmpty())\n      return \"\";\n\n    // [start, end] indices of the longest palindrome in s\n    int[] indices = {0, 0};\n\n    for (int i = 0; i < s.length(); ++i) {\n      int[] indices1 = extend(s, i, i);\n      if (indices1[1] - indices1[0] > indices[1] - indices[0])\n        indices = indices1;\n      if (i + 1 < s.length() && s.charAt(i) == s.charAt(i + 1)) {\n        int[] indices2 = extend(s, i, i + 1);\n        if (indices2[1] - indices2[0] > indices[1] - indices[0])\n          indices = indices2;\n      }\n    }\n\n    return s.substring(indices[0], indices[1] + 1);\n  }\n\n  // Returns [start, end] indices of the longest palindrome extended from s[i..j]\n  private int[] extend(final String s, int i, int j) {\n    for (; i >= 0 && j < s.length(); --i, ++j)\n      if (s.charAt(i) != s.charAt(j))\n        break;\n    return new int[] {i + 1, j - 1};\n  }\n}\n",
  "class Solution {\n  public String convert(String s, int numRows) {\n    StringBuilder sb = new StringBuilder();\n    List<Character>[] rows = new List[numRows];\n    int k = 0;\n    int direction = numRows == 1 ? 0 : -1;\n\n    for (int i = 0; i < numRows; ++i)\n      rows[i] = new ArrayList<>();\n\n    for (final char c : s.toCharArray()) {\n      rows[k].add(c);\n      if (k == 0 || k == numRows - 1)\n        direction *= -1;\n      k += direction;\n    }\n\n    for (List<Character> row : rows)\n      for (final char c : row)\n        sb.append(c);\n\n    return sb.toString();\n  }\n}\n",
  "class Solution {\n  public int reverse(int x) {\n    long ans = 0;\n\n    while (x != 0) {\n      ans = ans * 10 + x % 10;\n      x /= 10;\n    }\n\n    return (ans < Integer.MIN_VALUE || ans > Integer.MAX_VALUE) ? 0 : (int) ans;\n  }\n}\n",
  "class Solution {\n  public int myAtoi(String s) {\n    s = s.strip();\n    if (s.isEmpty())\n      return 0;\n\n    final int sign = s.charAt(0) == '-' ? -1 : 1;\n    if (s.charAt(0) == '+' || s.charAt(0) == '-')\n      s = s.substring(1);\n\n    long num = 0;\n\n    for (final char c : s.toCharArray()) {\n      if (!Character.isDigit(c))\n        break;\n      num = num * 10 + (c - '0');\n      if (sign * num <= Integer.MIN_VALUE)\n        return Integer.MIN_VALUE;\n      if (sign * num >= Integer.MAX_VALUE)\n        return Integer.MAX_VALUE;\n    }\n\n    return sign * (int) num;\n  }\n}\n",
  "class Solution {\n  public boolean isPalindrome(int x) {\n    if (x < 0)\n      return false;\n\n    long reversed = 0;\n    int y = x;\n\n    while (y > 0) {\n      reversed = reversed * 10 + y % 10;\n      y /= 10;\n    }\n\n    return reversed == x;\n  }\n}\n"
]
